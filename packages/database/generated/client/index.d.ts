/**
 * Client
 **/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types; // general types
import $Public = runtime.Types.Public;
import $Utils = runtime.Types.Utils;
import $Extensions = runtime.Types.Extensions;
import $Result = runtime.Types.Result;

export type PrismaPromise<T> = $Public.PrismaPromise<T>;

/**
 * Model User
 *
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>;
/**
 * Model Account
 *
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>;
/**
 * Model Session
 *
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>;
/**
 * Model VerificationToken
 *
 */
export type VerificationToken = $Result.DefaultSelection<Prisma.$VerificationTokenPayload>;
/**
 * Model ApiKey
 *
 */
export type ApiKey = $Result.DefaultSelection<Prisma.$ApiKeyPayload>;
/**
 * Model AuditLog
 *
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>;
/**
 * Model Hackathon
 *
 */
export type Hackathon = $Result.DefaultSelection<Prisma.$HackathonPayload>;
/**
 * Model Track
 *
 */
export type Track = $Result.DefaultSelection<Prisma.$TrackPayload>;
/**
 * Model Team
 *
 */
export type Team = $Result.DefaultSelection<Prisma.$TeamPayload>;
/**
 * Model TeamMember
 *
 */
export type TeamMember = $Result.DefaultSelection<Prisma.$TeamMemberPayload>;
/**
 * Model Mentor
 *
 */
export type Mentor = $Result.DefaultSelection<Prisma.$MentorPayload>;
/**
 * Model MentorSession
 *
 */
export type MentorSession = $Result.DefaultSelection<Prisma.$MentorSessionPayload>;
/**
 * Model Judge
 *
 */
export type Judge = $Result.DefaultSelection<Prisma.$JudgePayload>;
/**
 * Model Criteria
 *
 */
export type Criteria = $Result.DefaultSelection<Prisma.$CriteriaPayload>;
/**
 * Model Submission
 *
 */
export type Submission = $Result.DefaultSelection<Prisma.$SubmissionPayload>;
/**
 * Model Score
 *
 */
export type Score = $Result.DefaultSelection<Prisma.$ScorePayload>;
/**
 * Model Challenge
 *
 */
export type Challenge = $Result.DefaultSelection<Prisma.$ChallengePayload>;
/**
 * Model ChallengeSubmission
 *
 */
export type ChallengeSubmission = $Result.DefaultSelection<Prisma.$ChallengeSubmissionPayload>;
/**
 * Model Announcement
 *
 */
export type Announcement = $Result.DefaultSelection<Prisma.$AnnouncementPayload>;
/**
 * Model CommentThread
 *
 */
export type CommentThread = $Result.DefaultSelection<Prisma.$CommentThreadPayload>;
/**
 * Model Comment
 *
 */
export type Comment = $Result.DefaultSelection<Prisma.$CommentPayload>;
/**
 * Model GamificationProfile
 *
 */
export type GamificationProfile = $Result.DefaultSelection<Prisma.$GamificationProfilePayload>;
/**
 * Model Badge
 *
 */
export type Badge = $Result.DefaultSelection<Prisma.$BadgePayload>;
/**
 * Model XpEvent
 *
 */
export type XpEvent = $Result.DefaultSelection<Prisma.$XpEventPayload>;
/**
 * Model LeaderboardSnapshot
 *
 */
export type LeaderboardSnapshot = $Result.DefaultSelection<Prisma.$LeaderboardSnapshotPayload>;
/**
 * Model Notification
 *
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>;
/**
 * Model Report
 *
 */
export type Report = $Result.DefaultSelection<Prisma.$ReportPayload>;
/**
 * Model File
 *
 */
export type File = $Result.DefaultSelection<Prisma.$FilePayload>;

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
    BANK_ADMIN: 'BANK_ADMIN';
    ORGANIZER: 'ORGANIZER';
    MODERATOR: 'MODERATOR';
    JUDGE: 'JUDGE';
    MENTOR: 'MENTOR';
    SPONSOR: 'SPONSOR';
    PROJECT_OWNER: 'PROJECT_OWNER';
    PARTICIPANT: 'PARTICIPANT';
    VIEWER: 'VIEWER';
  };

  export type Role = (typeof Role)[keyof typeof Role];

  export const HackathonStatus: {
    DRAFT: 'DRAFT';
    UPCOMING: 'UPCOMING';
    LIVE: 'LIVE';
    JUDGING: 'JUDGING';
    CLOSED: 'CLOSED';
  };

  export type HackathonStatus = (typeof HackathonStatus)[keyof typeof HackathonStatus];

  export const HackathonLocation: {
    VIRTUAL: 'VIRTUAL';
    HYBRID: 'HYBRID';
    ONSITE: 'ONSITE';
  };

  export type HackathonLocation = (typeof HackathonLocation)[keyof typeof HackathonLocation];

  export const TeamMemberRole: {
    LEAD: 'LEAD';
    MEMBER: 'MEMBER';
  };

  export type TeamMemberRole = (typeof TeamMemberRole)[keyof typeof TeamMemberRole];

  export const SubmissionStatus: {
    DRAFT: 'DRAFT';
    SUBMITTED: 'SUBMITTED';
    FINAL: 'FINAL';
    DISQUALIFIED: 'DISQUALIFIED';
  };

  export type SubmissionStatus = (typeof SubmissionStatus)[keyof typeof SubmissionStatus];

  export const RewardType: {
    CASH: 'CASH';
    PRIZE: 'PRIZE';
    INTERNSHIP: 'INTERNSHIP';
    RECOGNITION: 'RECOGNITION';
  };

  export type RewardType = (typeof RewardType)[keyof typeof RewardType];

  export const ChallengeStatus: {
    DRAFT: 'DRAFT';
    OPEN: 'OPEN';
    REVIEW: 'REVIEW';
    CLOSED: 'CLOSED';
  };

  export type ChallengeStatus = (typeof ChallengeStatus)[keyof typeof ChallengeStatus];

  export const ChallengeVisibility: {
    PUBLIC: 'PUBLIC';
    PRIVATE: 'PRIVATE';
  };

  export type ChallengeVisibility = (typeof ChallengeVisibility)[keyof typeof ChallengeVisibility];

  export const ChallengeSubmissionStatus: {
    SUBMITTED: 'SUBMITTED';
    UNDER_REVIEW: 'UNDER_REVIEW';
    ACCEPTED: 'ACCEPTED';
    REJECTED: 'REJECTED';
    WINNER: 'WINNER';
  };

  export type ChallengeSubmissionStatus =
    (typeof ChallengeSubmissionStatus)[keyof typeof ChallengeSubmissionStatus];

  export const AnnouncementScope: {
    GLOBAL: 'GLOBAL';
    HACKATHON: 'HACKATHON';
    CHALLENGE: 'CHALLENGE';
  };

  export type AnnouncementScope = (typeof AnnouncementScope)[keyof typeof AnnouncementScope];

  export const CommentEntityType: {
    HACKATHON: 'HACKATHON';
    CHALLENGE: 'CHALLENGE';
    SUBMISSION: 'SUBMISSION';
    CHALLENGE_SUBMISSION: 'CHALLENGE_SUBMISSION';
  };

  export type CommentEntityType = (typeof CommentEntityType)[keyof typeof CommentEntityType];

  export const LeaderboardScope: {
    GLOBAL: 'GLOBAL';
    HACKATHON: 'HACKATHON';
    CHALLENGE: 'CHALLENGE';
  };

  export type LeaderboardScope = (typeof LeaderboardScope)[keyof typeof LeaderboardScope];

  export const LeaderboardPeriod: {
    ALLTIME: 'ALLTIME';
    SEASON: 'SEASON';
    MONTH: 'MONTH';
    WEEK: 'WEEK';
  };

  export type LeaderboardPeriod = (typeof LeaderboardPeriod)[keyof typeof LeaderboardPeriod];

  export const ReportStatus: {
    OPEN: 'OPEN';
    INVESTIGATING: 'INVESTIGATING';
    RESOLVED: 'RESOLVED';
    DISMISSED: 'DISMISSED';
  };

  export type ReportStatus = (typeof ReportStatus)[keyof typeof ReportStatus];
}

export type Role = $Enums.Role;

export const Role: typeof $Enums.Role;

export type HackathonStatus = $Enums.HackathonStatus;

export const HackathonStatus: typeof $Enums.HackathonStatus;

export type HackathonLocation = $Enums.HackathonLocation;

export const HackathonLocation: typeof $Enums.HackathonLocation;

export type TeamMemberRole = $Enums.TeamMemberRole;

export const TeamMemberRole: typeof $Enums.TeamMemberRole;

export type SubmissionStatus = $Enums.SubmissionStatus;

export const SubmissionStatus: typeof $Enums.SubmissionStatus;

export type RewardType = $Enums.RewardType;

export const RewardType: typeof $Enums.RewardType;

export type ChallengeStatus = $Enums.ChallengeStatus;

export const ChallengeStatus: typeof $Enums.ChallengeStatus;

export type ChallengeVisibility = $Enums.ChallengeVisibility;

export const ChallengeVisibility: typeof $Enums.ChallengeVisibility;

export type ChallengeSubmissionStatus = $Enums.ChallengeSubmissionStatus;

export const ChallengeSubmissionStatus: typeof $Enums.ChallengeSubmissionStatus;

export type AnnouncementScope = $Enums.AnnouncementScope;

export const AnnouncementScope: typeof $Enums.AnnouncementScope;

export type CommentEntityType = $Enums.CommentEntityType;

export const CommentEntityType: typeof $Enums.CommentEntityType;

export type LeaderboardScope = $Enums.LeaderboardScope;

export const LeaderboardScope: typeof $Enums.LeaderboardScope;

export type LeaderboardPeriod = $Enums.LeaderboardPeriod;

export const LeaderboardPeriod: typeof $Enums.LeaderboardPeriod;

export type ReportStatus = $Enums.ReportStatus;

export const ReportStatus: typeof $Enums.ReportStatus;

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions
    ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition>
      ? Prisma.GetEvents<ClientOptions['log']>
      : never
    : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] };

  /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(
    eventType: V,
    callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void
  ): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void;

  /**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(
    query: TemplateStringsArray | Prisma.Sql,
    ...values: any[]
  ): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(
    query: TemplateStringsArray | Prisma.Sql,
    ...values: any[]
  ): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(
    arg: [...P],
    options?: { isolationLevel?: Prisma.TransactionIsolationLevel }
  ): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>;

  $transaction<R>(
    fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>,
    options?: {
      maxWait?: number;
      timeout?: number;
      isolationLevel?: Prisma.TransactionIsolationLevel;
    }
  ): $Utils.JsPromise<R>;

  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Accounts
   * const accounts = await prisma.account.findMany()
   * ```
   */
  get account(): Prisma.AccountDelegate<ExtArgs>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Sessions
   * const sessions = await prisma.session.findMany()
   * ```
   */
  get session(): Prisma.SessionDelegate<ExtArgs>;

  /**
   * `prisma.verificationToken`: Exposes CRUD operations for the **VerificationToken** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more VerificationTokens
   * const verificationTokens = await prisma.verificationToken.findMany()
   * ```
   */
  get verificationToken(): Prisma.VerificationTokenDelegate<ExtArgs>;

  /**
   * `prisma.apiKey`: Exposes CRUD operations for the **ApiKey** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more ApiKeys
   * const apiKeys = await prisma.apiKey.findMany()
   * ```
   */
  get apiKey(): Prisma.ApiKeyDelegate<ExtArgs>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more AuditLogs
   * const auditLogs = await prisma.auditLog.findMany()
   * ```
   */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs>;

  /**
   * `prisma.hackathon`: Exposes CRUD operations for the **Hackathon** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Hackathons
   * const hackathons = await prisma.hackathon.findMany()
   * ```
   */
  get hackathon(): Prisma.HackathonDelegate<ExtArgs>;

  /**
   * `prisma.track`: Exposes CRUD operations for the **Track** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Tracks
   * const tracks = await prisma.track.findMany()
   * ```
   */
  get track(): Prisma.TrackDelegate<ExtArgs>;

  /**
   * `prisma.team`: Exposes CRUD operations for the **Team** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Teams
   * const teams = await prisma.team.findMany()
   * ```
   */
  get team(): Prisma.TeamDelegate<ExtArgs>;

  /**
   * `prisma.teamMember`: Exposes CRUD operations for the **TeamMember** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more TeamMembers
   * const teamMembers = await prisma.teamMember.findMany()
   * ```
   */
  get teamMember(): Prisma.TeamMemberDelegate<ExtArgs>;

  /**
   * `prisma.mentor`: Exposes CRUD operations for the **Mentor** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Mentors
   * const mentors = await prisma.mentor.findMany()
   * ```
   */
  get mentor(): Prisma.MentorDelegate<ExtArgs>;

  /**
   * `prisma.mentorSession`: Exposes CRUD operations for the **MentorSession** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more MentorSessions
   * const mentorSessions = await prisma.mentorSession.findMany()
   * ```
   */
  get mentorSession(): Prisma.MentorSessionDelegate<ExtArgs>;

  /**
   * `prisma.judge`: Exposes CRUD operations for the **Judge** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Judges
   * const judges = await prisma.judge.findMany()
   * ```
   */
  get judge(): Prisma.JudgeDelegate<ExtArgs>;

  /**
   * `prisma.criteria`: Exposes CRUD operations for the **Criteria** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Criteria
   * const criteria = await prisma.criteria.findMany()
   * ```
   */
  get criteria(): Prisma.CriteriaDelegate<ExtArgs>;

  /**
   * `prisma.submission`: Exposes CRUD operations for the **Submission** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Submissions
   * const submissions = await prisma.submission.findMany()
   * ```
   */
  get submission(): Prisma.SubmissionDelegate<ExtArgs>;

  /**
   * `prisma.score`: Exposes CRUD operations for the **Score** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Scores
   * const scores = await prisma.score.findMany()
   * ```
   */
  get score(): Prisma.ScoreDelegate<ExtArgs>;

  /**
   * `prisma.challenge`: Exposes CRUD operations for the **Challenge** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Challenges
   * const challenges = await prisma.challenge.findMany()
   * ```
   */
  get challenge(): Prisma.ChallengeDelegate<ExtArgs>;

  /**
   * `prisma.challengeSubmission`: Exposes CRUD operations for the **ChallengeSubmission** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more ChallengeSubmissions
   * const challengeSubmissions = await prisma.challengeSubmission.findMany()
   * ```
   */
  get challengeSubmission(): Prisma.ChallengeSubmissionDelegate<ExtArgs>;

  /**
   * `prisma.announcement`: Exposes CRUD operations for the **Announcement** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Announcements
   * const announcements = await prisma.announcement.findMany()
   * ```
   */
  get announcement(): Prisma.AnnouncementDelegate<ExtArgs>;

  /**
   * `prisma.commentThread`: Exposes CRUD operations for the **CommentThread** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more CommentThreads
   * const commentThreads = await prisma.commentThread.findMany()
   * ```
   */
  get commentThread(): Prisma.CommentThreadDelegate<ExtArgs>;

  /**
   * `prisma.comment`: Exposes CRUD operations for the **Comment** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Comments
   * const comments = await prisma.comment.findMany()
   * ```
   */
  get comment(): Prisma.CommentDelegate<ExtArgs>;

  /**
   * `prisma.gamificationProfile`: Exposes CRUD operations for the **GamificationProfile** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more GamificationProfiles
   * const gamificationProfiles = await prisma.gamificationProfile.findMany()
   * ```
   */
  get gamificationProfile(): Prisma.GamificationProfileDelegate<ExtArgs>;

  /**
   * `prisma.badge`: Exposes CRUD operations for the **Badge** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Badges
   * const badges = await prisma.badge.findMany()
   * ```
   */
  get badge(): Prisma.BadgeDelegate<ExtArgs>;

  /**
   * `prisma.xpEvent`: Exposes CRUD operations for the **XpEvent** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more XpEvents
   * const xpEvents = await prisma.xpEvent.findMany()
   * ```
   */
  get xpEvent(): Prisma.XpEventDelegate<ExtArgs>;

  /**
   * `prisma.leaderboardSnapshot`: Exposes CRUD operations for the **LeaderboardSnapshot** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more LeaderboardSnapshots
   * const leaderboardSnapshots = await prisma.leaderboardSnapshot.findMany()
   * ```
   */
  get leaderboardSnapshot(): Prisma.LeaderboardSnapshotDelegate<ExtArgs>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Notifications
   * const notifications = await prisma.notification.findMany()
   * ```
   */
  get notification(): Prisma.NotificationDelegate<ExtArgs>;

  /**
   * `prisma.report`: Exposes CRUD operations for the **Report** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Reports
   * const reports = await prisma.report.findMany()
   * ```
   */
  get report(): Prisma.ReportDelegate<ExtArgs>;

  /**
   * `prisma.file`: Exposes CRUD operations for the **File** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Files
   * const files = await prisma.file.findMany()
   * ```
   */
  get file(): Prisma.FileDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF;

  export type PrismaPromise<T> = $Public.PrismaPromise<T>;

  /**
   * Validator
   */
  export import validator = runtime.Public.validator;

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError;
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError;
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError;
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError;
  export import PrismaClientValidationError = runtime.PrismaClientValidationError;
  export import NotFoundError = runtime.NotFoundError;

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag;
  export import empty = runtime.empty;
  export import join = runtime.join;
  export import raw = runtime.raw;
  export import Sql = runtime.Sql;

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal;

  export type DecimalJsLike = runtime.DecimalJsLike;

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics;
  export type Metric<T> = runtime.Metric<T>;
  export type MetricHistogram = runtime.MetricHistogram;
  export type MetricHistogramBucket = runtime.MetricHistogramBucket;

  /**
   * Extensions
   */
  export import Extension = $Extensions.UserArgs;
  export import getExtensionContext = runtime.Extensions.getExtensionContext;
  export import Args = $Public.Args;
  export import Payload = $Public.Payload;
  export import Result = $Public.Result;
  export import Exact = $Public.Exact;

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string;
  };

  export const prismaVersion: PrismaVersion;

  /**
   * Utility Types
   */

  export import JsonObject = runtime.JsonObject;
  export import JsonArray = runtime.JsonArray;
  export import JsonValue = runtime.JsonValue;
  export import InputJsonObject = runtime.InputJsonObject;
  export import InputJsonArray = runtime.InputJsonArray;
  export import InputJsonValue = runtime.InputJsonValue;

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
     * Type of `Prisma.DbNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class DbNull {
      private DbNull: never;
      private constructor();
    }

    /**
     * Type of `Prisma.JsonNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class JsonNull {
      private JsonNull: never;
      private constructor();
    }

    /**
     * Type of `Prisma.AnyNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class AnyNull {
      private AnyNull: never;
      private constructor();
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull;

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull;

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull;

  type SelectAndInclude = {
    select: any;
    include: any;
  };

  type SelectAndOmit = {
    select: any;
    omit: any;
  };

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<
    ReturnType<T>
  >;

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
    [P in K]: T[P];
  };

  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K;
  }[keyof T];

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K;
  };

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>;

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  } & (T extends SelectAndInclude
    ? 'Please either choose `select` or `include`.'
    : T extends SelectAndOmit
      ? 'Please either choose `select` or `omit`.'
      : {});

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  } & K;

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> = T extends object
    ? U extends object
      ? (Without<T, U> & U) | (Without<U, T> & T)
      : U
    : T;

  /**
   * Is T a Record?
   */
  type IsObject<T extends any> =
    T extends Array<any>
      ? False
      : T extends Date
        ? False
        : T extends Uint8Array
          ? False
          : T extends BigInt
            ? False
            : T extends object
              ? True
              : False;

  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T;

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O>; // With K possibilities
    }[K];

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>;

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>;

  type _Either<O extends object, K extends Key, strict extends Boolean> = {
    1: EitherStrict<O, K>;
    0: EitherLoose<O, K>;
  }[strict];

  type Either<O extends object, K extends Key, strict extends Boolean = 1> = O extends unknown
    ? _Either<O, K, strict>
    : never;

  export type Union = any;

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K];
  } & {};

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (U extends unknown ? (k: U) => void : never) extends (
    k: infer I
  ) => void
    ? I
    : never;

  export type Overwrite<O extends object, O1 extends object> = {
    [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<
    Overwrite<
      U,
      {
        [K in keyof U]-?: At<U, K>;
      }
    >
  >;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
    1: AtStrict<O, K>;
    0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function
    ? A
    : {
        [K in keyof A]: A[K];
      } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
      ?
          | (K extends keyof O ? { [P in K]: O[P] } & O : O)
          | ({ [P in keyof O as P extends K ? K : never]-?: O[P] } & O)
      : never
  >;

  type _Strict<U, _U = U> = U extends unknown
    ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>>
    : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False;

  // /**
  // 1
  // */
  export type True = 1;

  /**
  0
  */
  export type False = 0;

  export type Not<B extends Boolean> = {
    0: 1;
    1: 0;
  }[B];

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
      ? 1
      : 0;

  export type Has<U extends Union, U1 extends Union> = Not<Extends<Exclude<U1, U>, U1>>;

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0;
      1: 1;
    };
    1: {
      0: 1;
      1: 1;
    };
  }[B1][B2];

  export type Keys<U extends Union> = U extends unknown ? keyof U : never;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object
    ? {
        [P in keyof T]: P extends keyof O ? O[P] : never;
      }
    : never;

  type FieldPaths<T, U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>> =
    IsObject<T> extends True ? U : T;

  type GetHavingFields<T> = {
    [K in keyof T]: Or<Or<Extends<'OR', K>, Extends<'AND', K>>, Extends<'NOT', K>> extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
        ? never
        : K;
  }[keyof T];

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never;
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>;
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T;

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<
    T,
    MaybeTupleToUnion<K>
  >;

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T;

  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>;

  type FieldRefInputType<Model, FieldType> = Model extends never
    ? never
    : FieldRef<Model, FieldType>;

  export const ModelName: {
    User: 'User';
    Account: 'Account';
    Session: 'Session';
    VerificationToken: 'VerificationToken';
    ApiKey: 'ApiKey';
    AuditLog: 'AuditLog';
    Hackathon: 'Hackathon';
    Track: 'Track';
    Team: 'Team';
    TeamMember: 'TeamMember';
    Mentor: 'Mentor';
    MentorSession: 'MentorSession';
    Judge: 'Judge';
    Criteria: 'Criteria';
    Submission: 'Submission';
    Score: 'Score';
    Challenge: 'Challenge';
    ChallengeSubmission: 'ChallengeSubmission';
    Announcement: 'Announcement';
    CommentThread: 'CommentThread';
    Comment: 'Comment';
    GamificationProfile: 'GamificationProfile';
    Badge: 'Badge';
    XpEvent: 'XpEvent';
    LeaderboardSnapshot: 'LeaderboardSnapshot';
    Notification: 'Notification';
    Report: 'Report';
    File: 'File';
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName];

  export type Datasources = {
    db?: Datasource;
  };

  interface TypeMapCb
    extends $Utils.Fn<
      { extArgs: $Extensions.InternalArgs; clientOptions: PrismaClientOptions },
      $Utils.Record<string, any>
    > {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>;
  }

  export type TypeMap<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    ClientOptions = {},
  > = {
    meta: {
      modelProps:
        | 'user'
        | 'account'
        | 'session'
        | 'verificationToken'
        | 'apiKey'
        | 'auditLog'
        | 'hackathon'
        | 'track'
        | 'team'
        | 'teamMember'
        | 'mentor'
        | 'mentorSession'
        | 'judge'
        | 'criteria'
        | 'submission'
        | 'score'
        | 'challenge'
        | 'challengeSubmission'
        | 'announcement'
        | 'commentThread'
        | 'comment'
        | 'gamificationProfile'
        | 'badge'
        | 'xpEvent'
        | 'leaderboardSnapshot'
        | 'notification'
        | 'report'
        | 'file';
      txIsolationLevel: Prisma.TransactionIsolationLevel;
    };
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>;
        fields: Prisma.UserFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[];
          };
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[];
          };
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateUser>;
          };
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>;
            result: $Utils.Optional<UserGroupByOutputType>[];
          };
          count: {
            args: Prisma.UserCountArgs<ExtArgs>;
            result: $Utils.Optional<UserCountAggregateOutputType> | number;
          };
        };
      };
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>;
        fields: Prisma.AccountFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>;
          };
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>;
          };
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[];
          };
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>;
          };
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[];
          };
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>;
          };
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>;
          };
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>;
          };
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateAccount>;
          };
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>;
            result: $Utils.Optional<AccountGroupByOutputType>[];
          };
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>;
            result: $Utils.Optional<AccountCountAggregateOutputType> | number;
          };
        };
      };
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>;
        fields: Prisma.SessionFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>;
          };
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>;
          };
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[];
          };
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>;
          };
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[];
          };
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>;
          };
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>;
          };
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>;
          };
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateSession>;
          };
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>;
            result: $Utils.Optional<SessionGroupByOutputType>[];
          };
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>;
            result: $Utils.Optional<SessionCountAggregateOutputType> | number;
          };
        };
      };
      VerificationToken: {
        payload: Prisma.$VerificationTokenPayload<ExtArgs>;
        fields: Prisma.VerificationTokenFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.VerificationTokenFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.VerificationTokenFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>;
          };
          findFirst: {
            args: Prisma.VerificationTokenFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.VerificationTokenFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>;
          };
          findMany: {
            args: Prisma.VerificationTokenFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[];
          };
          create: {
            args: Prisma.VerificationTokenCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>;
          };
          createMany: {
            args: Prisma.VerificationTokenCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.VerificationTokenCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[];
          };
          delete: {
            args: Prisma.VerificationTokenDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>;
          };
          update: {
            args: Prisma.VerificationTokenUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>;
          };
          deleteMany: {
            args: Prisma.VerificationTokenDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.VerificationTokenUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.VerificationTokenUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>;
          };
          aggregate: {
            args: Prisma.VerificationTokenAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateVerificationToken>;
          };
          groupBy: {
            args: Prisma.VerificationTokenGroupByArgs<ExtArgs>;
            result: $Utils.Optional<VerificationTokenGroupByOutputType>[];
          };
          count: {
            args: Prisma.VerificationTokenCountArgs<ExtArgs>;
            result: $Utils.Optional<VerificationTokenCountAggregateOutputType> | number;
          };
        };
      };
      ApiKey: {
        payload: Prisma.$ApiKeyPayload<ExtArgs>;
        fields: Prisma.ApiKeyFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.ApiKeyFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.ApiKeyFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>;
          };
          findFirst: {
            args: Prisma.ApiKeyFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.ApiKeyFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>;
          };
          findMany: {
            args: Prisma.ApiKeyFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>[];
          };
          create: {
            args: Prisma.ApiKeyCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>;
          };
          createMany: {
            args: Prisma.ApiKeyCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.ApiKeyCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>[];
          };
          delete: {
            args: Prisma.ApiKeyDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>;
          };
          update: {
            args: Prisma.ApiKeyUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>;
          };
          deleteMany: {
            args: Prisma.ApiKeyDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.ApiKeyUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.ApiKeyUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>;
          };
          aggregate: {
            args: Prisma.ApiKeyAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateApiKey>;
          };
          groupBy: {
            args: Prisma.ApiKeyGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ApiKeyGroupByOutputType>[];
          };
          count: {
            args: Prisma.ApiKeyCountArgs<ExtArgs>;
            result: $Utils.Optional<ApiKeyCountAggregateOutputType> | number;
          };
        };
      };
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>;
        fields: Prisma.AuditLogFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>;
          };
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>;
          };
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[];
          };
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>;
          };
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[];
          };
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>;
          };
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>;
          };
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>;
          };
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateAuditLog>;
          };
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>;
            result: $Utils.Optional<AuditLogGroupByOutputType>[];
          };
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>;
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number;
          };
        };
      };
      Hackathon: {
        payload: Prisma.$HackathonPayload<ExtArgs>;
        fields: Prisma.HackathonFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.HackathonFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$HackathonPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.HackathonFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$HackathonPayload>;
          };
          findFirst: {
            args: Prisma.HackathonFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$HackathonPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.HackathonFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$HackathonPayload>;
          };
          findMany: {
            args: Prisma.HackathonFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$HackathonPayload>[];
          };
          create: {
            args: Prisma.HackathonCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$HackathonPayload>;
          };
          createMany: {
            args: Prisma.HackathonCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.HackathonCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$HackathonPayload>[];
          };
          delete: {
            args: Prisma.HackathonDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$HackathonPayload>;
          };
          update: {
            args: Prisma.HackathonUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$HackathonPayload>;
          };
          deleteMany: {
            args: Prisma.HackathonDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.HackathonUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.HackathonUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$HackathonPayload>;
          };
          aggregate: {
            args: Prisma.HackathonAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateHackathon>;
          };
          groupBy: {
            args: Prisma.HackathonGroupByArgs<ExtArgs>;
            result: $Utils.Optional<HackathonGroupByOutputType>[];
          };
          count: {
            args: Prisma.HackathonCountArgs<ExtArgs>;
            result: $Utils.Optional<HackathonCountAggregateOutputType> | number;
          };
        };
      };
      Track: {
        payload: Prisma.$TrackPayload<ExtArgs>;
        fields: Prisma.TrackFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.TrackFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TrackPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.TrackFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TrackPayload>;
          };
          findFirst: {
            args: Prisma.TrackFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TrackPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.TrackFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TrackPayload>;
          };
          findMany: {
            args: Prisma.TrackFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TrackPayload>[];
          };
          create: {
            args: Prisma.TrackCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TrackPayload>;
          };
          createMany: {
            args: Prisma.TrackCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.TrackCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TrackPayload>[];
          };
          delete: {
            args: Prisma.TrackDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TrackPayload>;
          };
          update: {
            args: Prisma.TrackUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TrackPayload>;
          };
          deleteMany: {
            args: Prisma.TrackDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.TrackUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.TrackUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TrackPayload>;
          };
          aggregate: {
            args: Prisma.TrackAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateTrack>;
          };
          groupBy: {
            args: Prisma.TrackGroupByArgs<ExtArgs>;
            result: $Utils.Optional<TrackGroupByOutputType>[];
          };
          count: {
            args: Prisma.TrackCountArgs<ExtArgs>;
            result: $Utils.Optional<TrackCountAggregateOutputType> | number;
          };
        };
      };
      Team: {
        payload: Prisma.$TeamPayload<ExtArgs>;
        fields: Prisma.TeamFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.TeamFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TeamPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.TeamFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>;
          };
          findFirst: {
            args: Prisma.TeamFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TeamPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.TeamFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>;
          };
          findMany: {
            args: Prisma.TeamFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>[];
          };
          create: {
            args: Prisma.TeamCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>;
          };
          createMany: {
            args: Prisma.TeamCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.TeamCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>[];
          };
          delete: {
            args: Prisma.TeamDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>;
          };
          update: {
            args: Prisma.TeamUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>;
          };
          deleteMany: {
            args: Prisma.TeamDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.TeamUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.TeamUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>;
          };
          aggregate: {
            args: Prisma.TeamAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateTeam>;
          };
          groupBy: {
            args: Prisma.TeamGroupByArgs<ExtArgs>;
            result: $Utils.Optional<TeamGroupByOutputType>[];
          };
          count: {
            args: Prisma.TeamCountArgs<ExtArgs>;
            result: $Utils.Optional<TeamCountAggregateOutputType> | number;
          };
        };
      };
      TeamMember: {
        payload: Prisma.$TeamMemberPayload<ExtArgs>;
        fields: Prisma.TeamMemberFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.TeamMemberFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.TeamMemberFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>;
          };
          findFirst: {
            args: Prisma.TeamMemberFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.TeamMemberFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>;
          };
          findMany: {
            args: Prisma.TeamMemberFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>[];
          };
          create: {
            args: Prisma.TeamMemberCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>;
          };
          createMany: {
            args: Prisma.TeamMemberCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.TeamMemberCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>[];
          };
          delete: {
            args: Prisma.TeamMemberDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>;
          };
          update: {
            args: Prisma.TeamMemberUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>;
          };
          deleteMany: {
            args: Prisma.TeamMemberDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.TeamMemberUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.TeamMemberUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>;
          };
          aggregate: {
            args: Prisma.TeamMemberAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateTeamMember>;
          };
          groupBy: {
            args: Prisma.TeamMemberGroupByArgs<ExtArgs>;
            result: $Utils.Optional<TeamMemberGroupByOutputType>[];
          };
          count: {
            args: Prisma.TeamMemberCountArgs<ExtArgs>;
            result: $Utils.Optional<TeamMemberCountAggregateOutputType> | number;
          };
        };
      };
      Mentor: {
        payload: Prisma.$MentorPayload<ExtArgs>;
        fields: Prisma.MentorFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.MentorFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MentorPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.MentorFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MentorPayload>;
          };
          findFirst: {
            args: Prisma.MentorFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MentorPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.MentorFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MentorPayload>;
          };
          findMany: {
            args: Prisma.MentorFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MentorPayload>[];
          };
          create: {
            args: Prisma.MentorCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MentorPayload>;
          };
          createMany: {
            args: Prisma.MentorCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.MentorCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MentorPayload>[];
          };
          delete: {
            args: Prisma.MentorDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MentorPayload>;
          };
          update: {
            args: Prisma.MentorUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MentorPayload>;
          };
          deleteMany: {
            args: Prisma.MentorDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.MentorUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.MentorUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MentorPayload>;
          };
          aggregate: {
            args: Prisma.MentorAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateMentor>;
          };
          groupBy: {
            args: Prisma.MentorGroupByArgs<ExtArgs>;
            result: $Utils.Optional<MentorGroupByOutputType>[];
          };
          count: {
            args: Prisma.MentorCountArgs<ExtArgs>;
            result: $Utils.Optional<MentorCountAggregateOutputType> | number;
          };
        };
      };
      MentorSession: {
        payload: Prisma.$MentorSessionPayload<ExtArgs>;
        fields: Prisma.MentorSessionFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.MentorSessionFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MentorSessionPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.MentorSessionFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MentorSessionPayload>;
          };
          findFirst: {
            args: Prisma.MentorSessionFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MentorSessionPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.MentorSessionFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MentorSessionPayload>;
          };
          findMany: {
            args: Prisma.MentorSessionFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MentorSessionPayload>[];
          };
          create: {
            args: Prisma.MentorSessionCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MentorSessionPayload>;
          };
          createMany: {
            args: Prisma.MentorSessionCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.MentorSessionCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MentorSessionPayload>[];
          };
          delete: {
            args: Prisma.MentorSessionDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MentorSessionPayload>;
          };
          update: {
            args: Prisma.MentorSessionUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MentorSessionPayload>;
          };
          deleteMany: {
            args: Prisma.MentorSessionDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.MentorSessionUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.MentorSessionUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MentorSessionPayload>;
          };
          aggregate: {
            args: Prisma.MentorSessionAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateMentorSession>;
          };
          groupBy: {
            args: Prisma.MentorSessionGroupByArgs<ExtArgs>;
            result: $Utils.Optional<MentorSessionGroupByOutputType>[];
          };
          count: {
            args: Prisma.MentorSessionCountArgs<ExtArgs>;
            result: $Utils.Optional<MentorSessionCountAggregateOutputType> | number;
          };
        };
      };
      Judge: {
        payload: Prisma.$JudgePayload<ExtArgs>;
        fields: Prisma.JudgeFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.JudgeFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$JudgePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.JudgeFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$JudgePayload>;
          };
          findFirst: {
            args: Prisma.JudgeFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$JudgePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.JudgeFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$JudgePayload>;
          };
          findMany: {
            args: Prisma.JudgeFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$JudgePayload>[];
          };
          create: {
            args: Prisma.JudgeCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$JudgePayload>;
          };
          createMany: {
            args: Prisma.JudgeCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.JudgeCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$JudgePayload>[];
          };
          delete: {
            args: Prisma.JudgeDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$JudgePayload>;
          };
          update: {
            args: Prisma.JudgeUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$JudgePayload>;
          };
          deleteMany: {
            args: Prisma.JudgeDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.JudgeUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.JudgeUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$JudgePayload>;
          };
          aggregate: {
            args: Prisma.JudgeAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateJudge>;
          };
          groupBy: {
            args: Prisma.JudgeGroupByArgs<ExtArgs>;
            result: $Utils.Optional<JudgeGroupByOutputType>[];
          };
          count: {
            args: Prisma.JudgeCountArgs<ExtArgs>;
            result: $Utils.Optional<JudgeCountAggregateOutputType> | number;
          };
        };
      };
      Criteria: {
        payload: Prisma.$CriteriaPayload<ExtArgs>;
        fields: Prisma.CriteriaFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.CriteriaFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CriteriaPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.CriteriaFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CriteriaPayload>;
          };
          findFirst: {
            args: Prisma.CriteriaFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CriteriaPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.CriteriaFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CriteriaPayload>;
          };
          findMany: {
            args: Prisma.CriteriaFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CriteriaPayload>[];
          };
          create: {
            args: Prisma.CriteriaCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CriteriaPayload>;
          };
          createMany: {
            args: Prisma.CriteriaCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.CriteriaCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CriteriaPayload>[];
          };
          delete: {
            args: Prisma.CriteriaDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CriteriaPayload>;
          };
          update: {
            args: Prisma.CriteriaUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CriteriaPayload>;
          };
          deleteMany: {
            args: Prisma.CriteriaDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.CriteriaUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.CriteriaUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CriteriaPayload>;
          };
          aggregate: {
            args: Prisma.CriteriaAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateCriteria>;
          };
          groupBy: {
            args: Prisma.CriteriaGroupByArgs<ExtArgs>;
            result: $Utils.Optional<CriteriaGroupByOutputType>[];
          };
          count: {
            args: Prisma.CriteriaCountArgs<ExtArgs>;
            result: $Utils.Optional<CriteriaCountAggregateOutputType> | number;
          };
        };
      };
      Submission: {
        payload: Prisma.$SubmissionPayload<ExtArgs>;
        fields: Prisma.SubmissionFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.SubmissionFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SubmissionPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.SubmissionFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SubmissionPayload>;
          };
          findFirst: {
            args: Prisma.SubmissionFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SubmissionPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.SubmissionFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SubmissionPayload>;
          };
          findMany: {
            args: Prisma.SubmissionFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SubmissionPayload>[];
          };
          create: {
            args: Prisma.SubmissionCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SubmissionPayload>;
          };
          createMany: {
            args: Prisma.SubmissionCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.SubmissionCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SubmissionPayload>[];
          };
          delete: {
            args: Prisma.SubmissionDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SubmissionPayload>;
          };
          update: {
            args: Prisma.SubmissionUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SubmissionPayload>;
          };
          deleteMany: {
            args: Prisma.SubmissionDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.SubmissionUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.SubmissionUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SubmissionPayload>;
          };
          aggregate: {
            args: Prisma.SubmissionAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateSubmission>;
          };
          groupBy: {
            args: Prisma.SubmissionGroupByArgs<ExtArgs>;
            result: $Utils.Optional<SubmissionGroupByOutputType>[];
          };
          count: {
            args: Prisma.SubmissionCountArgs<ExtArgs>;
            result: $Utils.Optional<SubmissionCountAggregateOutputType> | number;
          };
        };
      };
      Score: {
        payload: Prisma.$ScorePayload<ExtArgs>;
        fields: Prisma.ScoreFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.ScoreFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ScorePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.ScoreFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ScorePayload>;
          };
          findFirst: {
            args: Prisma.ScoreFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ScorePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.ScoreFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ScorePayload>;
          };
          findMany: {
            args: Prisma.ScoreFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ScorePayload>[];
          };
          create: {
            args: Prisma.ScoreCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ScorePayload>;
          };
          createMany: {
            args: Prisma.ScoreCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.ScoreCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ScorePayload>[];
          };
          delete: {
            args: Prisma.ScoreDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ScorePayload>;
          };
          update: {
            args: Prisma.ScoreUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ScorePayload>;
          };
          deleteMany: {
            args: Prisma.ScoreDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.ScoreUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.ScoreUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ScorePayload>;
          };
          aggregate: {
            args: Prisma.ScoreAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateScore>;
          };
          groupBy: {
            args: Prisma.ScoreGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ScoreGroupByOutputType>[];
          };
          count: {
            args: Prisma.ScoreCountArgs<ExtArgs>;
            result: $Utils.Optional<ScoreCountAggregateOutputType> | number;
          };
        };
      };
      Challenge: {
        payload: Prisma.$ChallengePayload<ExtArgs>;
        fields: Prisma.ChallengeFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.ChallengeFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.ChallengeFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload>;
          };
          findFirst: {
            args: Prisma.ChallengeFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.ChallengeFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload>;
          };
          findMany: {
            args: Prisma.ChallengeFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload>[];
          };
          create: {
            args: Prisma.ChallengeCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload>;
          };
          createMany: {
            args: Prisma.ChallengeCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.ChallengeCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload>[];
          };
          delete: {
            args: Prisma.ChallengeDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload>;
          };
          update: {
            args: Prisma.ChallengeUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload>;
          };
          deleteMany: {
            args: Prisma.ChallengeDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.ChallengeUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.ChallengeUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload>;
          };
          aggregate: {
            args: Prisma.ChallengeAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateChallenge>;
          };
          groupBy: {
            args: Prisma.ChallengeGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ChallengeGroupByOutputType>[];
          };
          count: {
            args: Prisma.ChallengeCountArgs<ExtArgs>;
            result: $Utils.Optional<ChallengeCountAggregateOutputType> | number;
          };
        };
      };
      ChallengeSubmission: {
        payload: Prisma.$ChallengeSubmissionPayload<ExtArgs>;
        fields: Prisma.ChallengeSubmissionFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.ChallengeSubmissionFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ChallengeSubmissionPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.ChallengeSubmissionFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ChallengeSubmissionPayload>;
          };
          findFirst: {
            args: Prisma.ChallengeSubmissionFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ChallengeSubmissionPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.ChallengeSubmissionFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ChallengeSubmissionPayload>;
          };
          findMany: {
            args: Prisma.ChallengeSubmissionFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ChallengeSubmissionPayload>[];
          };
          create: {
            args: Prisma.ChallengeSubmissionCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ChallengeSubmissionPayload>;
          };
          createMany: {
            args: Prisma.ChallengeSubmissionCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.ChallengeSubmissionCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ChallengeSubmissionPayload>[];
          };
          delete: {
            args: Prisma.ChallengeSubmissionDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ChallengeSubmissionPayload>;
          };
          update: {
            args: Prisma.ChallengeSubmissionUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ChallengeSubmissionPayload>;
          };
          deleteMany: {
            args: Prisma.ChallengeSubmissionDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.ChallengeSubmissionUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.ChallengeSubmissionUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ChallengeSubmissionPayload>;
          };
          aggregate: {
            args: Prisma.ChallengeSubmissionAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateChallengeSubmission>;
          };
          groupBy: {
            args: Prisma.ChallengeSubmissionGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ChallengeSubmissionGroupByOutputType>[];
          };
          count: {
            args: Prisma.ChallengeSubmissionCountArgs<ExtArgs>;
            result: $Utils.Optional<ChallengeSubmissionCountAggregateOutputType> | number;
          };
        };
      };
      Announcement: {
        payload: Prisma.$AnnouncementPayload<ExtArgs>;
        fields: Prisma.AnnouncementFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.AnnouncementFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.AnnouncementFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>;
          };
          findFirst: {
            args: Prisma.AnnouncementFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.AnnouncementFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>;
          };
          findMany: {
            args: Prisma.AnnouncementFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>[];
          };
          create: {
            args: Prisma.AnnouncementCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>;
          };
          createMany: {
            args: Prisma.AnnouncementCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.AnnouncementCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>[];
          };
          delete: {
            args: Prisma.AnnouncementDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>;
          };
          update: {
            args: Prisma.AnnouncementUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>;
          };
          deleteMany: {
            args: Prisma.AnnouncementDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.AnnouncementUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.AnnouncementUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>;
          };
          aggregate: {
            args: Prisma.AnnouncementAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateAnnouncement>;
          };
          groupBy: {
            args: Prisma.AnnouncementGroupByArgs<ExtArgs>;
            result: $Utils.Optional<AnnouncementGroupByOutputType>[];
          };
          count: {
            args: Prisma.AnnouncementCountArgs<ExtArgs>;
            result: $Utils.Optional<AnnouncementCountAggregateOutputType> | number;
          };
        };
      };
      CommentThread: {
        payload: Prisma.$CommentThreadPayload<ExtArgs>;
        fields: Prisma.CommentThreadFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.CommentThreadFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CommentThreadPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.CommentThreadFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CommentThreadPayload>;
          };
          findFirst: {
            args: Prisma.CommentThreadFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CommentThreadPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.CommentThreadFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CommentThreadPayload>;
          };
          findMany: {
            args: Prisma.CommentThreadFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CommentThreadPayload>[];
          };
          create: {
            args: Prisma.CommentThreadCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CommentThreadPayload>;
          };
          createMany: {
            args: Prisma.CommentThreadCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.CommentThreadCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CommentThreadPayload>[];
          };
          delete: {
            args: Prisma.CommentThreadDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CommentThreadPayload>;
          };
          update: {
            args: Prisma.CommentThreadUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CommentThreadPayload>;
          };
          deleteMany: {
            args: Prisma.CommentThreadDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.CommentThreadUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.CommentThreadUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CommentThreadPayload>;
          };
          aggregate: {
            args: Prisma.CommentThreadAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateCommentThread>;
          };
          groupBy: {
            args: Prisma.CommentThreadGroupByArgs<ExtArgs>;
            result: $Utils.Optional<CommentThreadGroupByOutputType>[];
          };
          count: {
            args: Prisma.CommentThreadCountArgs<ExtArgs>;
            result: $Utils.Optional<CommentThreadCountAggregateOutputType> | number;
          };
        };
      };
      Comment: {
        payload: Prisma.$CommentPayload<ExtArgs>;
        fields: Prisma.CommentFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.CommentFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.CommentFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>;
          };
          findFirst: {
            args: Prisma.CommentFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.CommentFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>;
          };
          findMany: {
            args: Prisma.CommentFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[];
          };
          create: {
            args: Prisma.CommentCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>;
          };
          createMany: {
            args: Prisma.CommentCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.CommentCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[];
          };
          delete: {
            args: Prisma.CommentDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>;
          };
          update: {
            args: Prisma.CommentUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>;
          };
          deleteMany: {
            args: Prisma.CommentDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.CommentUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.CommentUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>;
          };
          aggregate: {
            args: Prisma.CommentAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateComment>;
          };
          groupBy: {
            args: Prisma.CommentGroupByArgs<ExtArgs>;
            result: $Utils.Optional<CommentGroupByOutputType>[];
          };
          count: {
            args: Prisma.CommentCountArgs<ExtArgs>;
            result: $Utils.Optional<CommentCountAggregateOutputType> | number;
          };
        };
      };
      GamificationProfile: {
        payload: Prisma.$GamificationProfilePayload<ExtArgs>;
        fields: Prisma.GamificationProfileFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.GamificationProfileFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$GamificationProfilePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.GamificationProfileFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$GamificationProfilePayload>;
          };
          findFirst: {
            args: Prisma.GamificationProfileFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$GamificationProfilePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.GamificationProfileFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$GamificationProfilePayload>;
          };
          findMany: {
            args: Prisma.GamificationProfileFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$GamificationProfilePayload>[];
          };
          create: {
            args: Prisma.GamificationProfileCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$GamificationProfilePayload>;
          };
          createMany: {
            args: Prisma.GamificationProfileCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.GamificationProfileCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$GamificationProfilePayload>[];
          };
          delete: {
            args: Prisma.GamificationProfileDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$GamificationProfilePayload>;
          };
          update: {
            args: Prisma.GamificationProfileUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$GamificationProfilePayload>;
          };
          deleteMany: {
            args: Prisma.GamificationProfileDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.GamificationProfileUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.GamificationProfileUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$GamificationProfilePayload>;
          };
          aggregate: {
            args: Prisma.GamificationProfileAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateGamificationProfile>;
          };
          groupBy: {
            args: Prisma.GamificationProfileGroupByArgs<ExtArgs>;
            result: $Utils.Optional<GamificationProfileGroupByOutputType>[];
          };
          count: {
            args: Prisma.GamificationProfileCountArgs<ExtArgs>;
            result: $Utils.Optional<GamificationProfileCountAggregateOutputType> | number;
          };
        };
      };
      Badge: {
        payload: Prisma.$BadgePayload<ExtArgs>;
        fields: Prisma.BadgeFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.BadgeFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$BadgePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.BadgeFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>;
          };
          findFirst: {
            args: Prisma.BadgeFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$BadgePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.BadgeFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>;
          };
          findMany: {
            args: Prisma.BadgeFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>[];
          };
          create: {
            args: Prisma.BadgeCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>;
          };
          createMany: {
            args: Prisma.BadgeCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.BadgeCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>[];
          };
          delete: {
            args: Prisma.BadgeDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>;
          };
          update: {
            args: Prisma.BadgeUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>;
          };
          deleteMany: {
            args: Prisma.BadgeDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.BadgeUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.BadgeUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>;
          };
          aggregate: {
            args: Prisma.BadgeAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateBadge>;
          };
          groupBy: {
            args: Prisma.BadgeGroupByArgs<ExtArgs>;
            result: $Utils.Optional<BadgeGroupByOutputType>[];
          };
          count: {
            args: Prisma.BadgeCountArgs<ExtArgs>;
            result: $Utils.Optional<BadgeCountAggregateOutputType> | number;
          };
        };
      };
      XpEvent: {
        payload: Prisma.$XpEventPayload<ExtArgs>;
        fields: Prisma.XpEventFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.XpEventFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$XpEventPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.XpEventFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$XpEventPayload>;
          };
          findFirst: {
            args: Prisma.XpEventFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$XpEventPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.XpEventFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$XpEventPayload>;
          };
          findMany: {
            args: Prisma.XpEventFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$XpEventPayload>[];
          };
          create: {
            args: Prisma.XpEventCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$XpEventPayload>;
          };
          createMany: {
            args: Prisma.XpEventCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.XpEventCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$XpEventPayload>[];
          };
          delete: {
            args: Prisma.XpEventDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$XpEventPayload>;
          };
          update: {
            args: Prisma.XpEventUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$XpEventPayload>;
          };
          deleteMany: {
            args: Prisma.XpEventDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.XpEventUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.XpEventUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$XpEventPayload>;
          };
          aggregate: {
            args: Prisma.XpEventAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateXpEvent>;
          };
          groupBy: {
            args: Prisma.XpEventGroupByArgs<ExtArgs>;
            result: $Utils.Optional<XpEventGroupByOutputType>[];
          };
          count: {
            args: Prisma.XpEventCountArgs<ExtArgs>;
            result: $Utils.Optional<XpEventCountAggregateOutputType> | number;
          };
        };
      };
      LeaderboardSnapshot: {
        payload: Prisma.$LeaderboardSnapshotPayload<ExtArgs>;
        fields: Prisma.LeaderboardSnapshotFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.LeaderboardSnapshotFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LeaderboardSnapshotPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.LeaderboardSnapshotFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LeaderboardSnapshotPayload>;
          };
          findFirst: {
            args: Prisma.LeaderboardSnapshotFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LeaderboardSnapshotPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.LeaderboardSnapshotFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LeaderboardSnapshotPayload>;
          };
          findMany: {
            args: Prisma.LeaderboardSnapshotFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LeaderboardSnapshotPayload>[];
          };
          create: {
            args: Prisma.LeaderboardSnapshotCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LeaderboardSnapshotPayload>;
          };
          createMany: {
            args: Prisma.LeaderboardSnapshotCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.LeaderboardSnapshotCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LeaderboardSnapshotPayload>[];
          };
          delete: {
            args: Prisma.LeaderboardSnapshotDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LeaderboardSnapshotPayload>;
          };
          update: {
            args: Prisma.LeaderboardSnapshotUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LeaderboardSnapshotPayload>;
          };
          deleteMany: {
            args: Prisma.LeaderboardSnapshotDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.LeaderboardSnapshotUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.LeaderboardSnapshotUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$LeaderboardSnapshotPayload>;
          };
          aggregate: {
            args: Prisma.LeaderboardSnapshotAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateLeaderboardSnapshot>;
          };
          groupBy: {
            args: Prisma.LeaderboardSnapshotGroupByArgs<ExtArgs>;
            result: $Utils.Optional<LeaderboardSnapshotGroupByOutputType>[];
          };
          count: {
            args: Prisma.LeaderboardSnapshotCountArgs<ExtArgs>;
            result: $Utils.Optional<LeaderboardSnapshotCountAggregateOutputType> | number;
          };
        };
      };
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>;
        fields: Prisma.NotificationFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>;
          };
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>;
          };
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[];
          };
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>;
          };
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[];
          };
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>;
          };
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>;
          };
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>;
          };
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateNotification>;
          };
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>;
            result: $Utils.Optional<NotificationGroupByOutputType>[];
          };
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>;
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number;
          };
        };
      };
      Report: {
        payload: Prisma.$ReportPayload<ExtArgs>;
        fields: Prisma.ReportFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.ReportFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ReportPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.ReportFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>;
          };
          findFirst: {
            args: Prisma.ReportFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ReportPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.ReportFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>;
          };
          findMany: {
            args: Prisma.ReportFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>[];
          };
          create: {
            args: Prisma.ReportCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>;
          };
          createMany: {
            args: Prisma.ReportCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.ReportCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>[];
          };
          delete: {
            args: Prisma.ReportDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>;
          };
          update: {
            args: Prisma.ReportUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>;
          };
          deleteMany: {
            args: Prisma.ReportDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.ReportUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.ReportUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>;
          };
          aggregate: {
            args: Prisma.ReportAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateReport>;
          };
          groupBy: {
            args: Prisma.ReportGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ReportGroupByOutputType>[];
          };
          count: {
            args: Prisma.ReportCountArgs<ExtArgs>;
            result: $Utils.Optional<ReportCountAggregateOutputType> | number;
          };
        };
      };
      File: {
        payload: Prisma.$FilePayload<ExtArgs>;
        fields: Prisma.FileFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.FileFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FilePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.FileFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FilePayload>;
          };
          findFirst: {
            args: Prisma.FileFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FilePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.FileFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FilePayload>;
          };
          findMany: {
            args: Prisma.FileFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FilePayload>[];
          };
          create: {
            args: Prisma.FileCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FilePayload>;
          };
          createMany: {
            args: Prisma.FileCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.FileCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FilePayload>[];
          };
          delete: {
            args: Prisma.FileDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FilePayload>;
          };
          update: {
            args: Prisma.FileUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FilePayload>;
          };
          deleteMany: {
            args: Prisma.FileDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.FileUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.FileUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FilePayload>;
          };
          aggregate: {
            args: Prisma.FileAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateFile>;
          };
          groupBy: {
            args: Prisma.FileGroupByArgs<ExtArgs>;
            result: $Utils.Optional<FileGroupByOutputType>[];
          };
          count: {
            args: Prisma.FileCountArgs<ExtArgs>;
            result: $Utils.Optional<FileCountAggregateOutputType> | number;
          };
        };
      };
    };
  } & {
    other: {
      payload: any;
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]];
          result: any;
        };
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]];
          result: any;
        };
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]];
          result: any;
        };
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]];
          result: any;
        };
      };
    };
  };
  export const defineExtension: $Extensions.ExtendsHook<
    'define',
    Prisma.TypeMapCb,
    $Extensions.DefaultArgs
  >;
  export type DefaultPrismaClient = PrismaClient;
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal';
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources;
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string;
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat;
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     *
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[];
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number;
      timeout?: number;
      isolationLevel?: Prisma.TransactionIsolationLevel;
    };
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error';
  export type LogDefinition = {
    level: LogLevel;
    emit: 'stdout' | 'event';
  };

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition
    ? T['emit'] extends 'event'
      ? T['level']
      : never
    : never;
  export type GetEvents<T extends any> =
    T extends Array<LogLevel | LogDefinition>
      ? GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
      : never;

  export type QueryEvent = {
    timestamp: Date;
    query: string;
    params: string;
    duration: number;
    target: string;
  };

  export type LogEvent = {
    timestamp: Date;
    message: string;
    target: string;
  };
  /* End Types for Logging */

  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy';

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName;
    action: PrismaAction;
    args: any;
    dataPath: string[];
    runInTransaction: boolean;
  };

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>
  ) => $Utils.JsPromise<T>;

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>;

  export type Datasource = {
    url?: string;
  };

  /**
   * Count Types
   */

  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    accounts: number;
    sessions: number;
    apiKeys: number;
    auditLogs: number;
    teamMemberships: number;
    mentorProfiles: number;
    judgeAssignments: number;
    challengeSubmissions: number;
    comments: number;
    xpEvents: number;
    notifications: number;
    reports: number;
    uploadedFiles: number;
    ownedChallenges: number;
  };

  export type UserCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs;
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs;
    apiKeys?: boolean | UserCountOutputTypeCountApiKeysArgs;
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs;
    teamMemberships?: boolean | UserCountOutputTypeCountTeamMembershipsArgs;
    mentorProfiles?: boolean | UserCountOutputTypeCountMentorProfilesArgs;
    judgeAssignments?: boolean | UserCountOutputTypeCountJudgeAssignmentsArgs;
    challengeSubmissions?: boolean | UserCountOutputTypeCountChallengeSubmissionsArgs;
    comments?: boolean | UserCountOutputTypeCountCommentsArgs;
    xpEvents?: boolean | UserCountOutputTypeCountXpEventsArgs;
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs;
    reports?: boolean | UserCountOutputTypeCountReportsArgs;
    uploadedFiles?: boolean | UserCountOutputTypeCountUploadedFilesArgs;
    ownedChallenges?: boolean | UserCountOutputTypeCountOwnedChallengesArgs;
  };

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AccountWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: SessionWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountApiKeysArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ApiKeyWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AuditLogWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTeamMembershipsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: TeamMemberWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMentorProfilesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: MentorWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountJudgeAssignmentsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: JudgeWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountChallengeSubmissionsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ChallengeSubmissionWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCommentsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: CommentWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountXpEventsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: XpEventWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: NotificationWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReportsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ReportWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUploadedFilesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: FileWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOwnedChallengesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ChallengeWhereInput;
  };

  /**
   * Count Type HackathonCountOutputType
   */

  export type HackathonCountOutputType = {
    tracks: number;
    teams: number;
    mentors: number;
    judges: number;
    criteria: number;
    submissions: number;
    announcements: number;
  };

  export type HackathonCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    tracks?: boolean | HackathonCountOutputTypeCountTracksArgs;
    teams?: boolean | HackathonCountOutputTypeCountTeamsArgs;
    mentors?: boolean | HackathonCountOutputTypeCountMentorsArgs;
    judges?: boolean | HackathonCountOutputTypeCountJudgesArgs;
    criteria?: boolean | HackathonCountOutputTypeCountCriteriaArgs;
    submissions?: boolean | HackathonCountOutputTypeCountSubmissionsArgs;
    announcements?: boolean | HackathonCountOutputTypeCountAnnouncementsArgs;
  };

  // Custom InputTypes
  /**
   * HackathonCountOutputType without action
   */
  export type HackathonCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the HackathonCountOutputType
     */
    select?: HackathonCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * HackathonCountOutputType without action
   */
  export type HackathonCountOutputTypeCountTracksArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: TrackWhereInput;
  };

  /**
   * HackathonCountOutputType without action
   */
  export type HackathonCountOutputTypeCountTeamsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: TeamWhereInput;
  };

  /**
   * HackathonCountOutputType without action
   */
  export type HackathonCountOutputTypeCountMentorsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: MentorWhereInput;
  };

  /**
   * HackathonCountOutputType without action
   */
  export type HackathonCountOutputTypeCountJudgesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: JudgeWhereInput;
  };

  /**
   * HackathonCountOutputType without action
   */
  export type HackathonCountOutputTypeCountCriteriaArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: CriteriaWhereInput;
  };

  /**
   * HackathonCountOutputType without action
   */
  export type HackathonCountOutputTypeCountSubmissionsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: SubmissionWhereInput;
  };

  /**
   * HackathonCountOutputType without action
   */
  export type HackathonCountOutputTypeCountAnnouncementsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AnnouncementWhereInput;
  };

  /**
   * Count Type TrackCountOutputType
   */

  export type TrackCountOutputType = {
    submissions: number;
  };

  export type TrackCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    submissions?: boolean | TrackCountOutputTypeCountSubmissionsArgs;
  };

  // Custom InputTypes
  /**
   * TrackCountOutputType without action
   */
  export type TrackCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TrackCountOutputType
     */
    select?: TrackCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * TrackCountOutputType without action
   */
  export type TrackCountOutputTypeCountSubmissionsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: SubmissionWhereInput;
  };

  /**
   * Count Type TeamCountOutputType
   */

  export type TeamCountOutputType = {
    members: number;
    submissions: number;
    challengeSubmissions: number;
  };

  export type TeamCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    members?: boolean | TeamCountOutputTypeCountMembersArgs;
    submissions?: boolean | TeamCountOutputTypeCountSubmissionsArgs;
    challengeSubmissions?: boolean | TeamCountOutputTypeCountChallengeSubmissionsArgs;
  };

  // Custom InputTypes
  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TeamCountOutputType
     */
    select?: TeamCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountMembersArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: TeamMemberWhereInput;
  };

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountSubmissionsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: SubmissionWhereInput;
  };

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountChallengeSubmissionsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ChallengeSubmissionWhereInput;
  };

  /**
   * Count Type MentorCountOutputType
   */

  export type MentorCountOutputType = {
    sessions: number;
  };

  export type MentorCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    sessions?: boolean | MentorCountOutputTypeCountSessionsArgs;
  };

  // Custom InputTypes
  /**
   * MentorCountOutputType without action
   */
  export type MentorCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MentorCountOutputType
     */
    select?: MentorCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * MentorCountOutputType without action
   */
  export type MentorCountOutputTypeCountSessionsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: MentorSessionWhereInput;
  };

  /**
   * Count Type JudgeCountOutputType
   */

  export type JudgeCountOutputType = {
    scores: number;
  };

  export type JudgeCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    scores?: boolean | JudgeCountOutputTypeCountScoresArgs;
  };

  // Custom InputTypes
  /**
   * JudgeCountOutputType without action
   */
  export type JudgeCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the JudgeCountOutputType
     */
    select?: JudgeCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * JudgeCountOutputType without action
   */
  export type JudgeCountOutputTypeCountScoresArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ScoreWhereInput;
  };

  /**
   * Count Type CriteriaCountOutputType
   */

  export type CriteriaCountOutputType = {
    scores: number;
  };

  export type CriteriaCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    scores?: boolean | CriteriaCountOutputTypeCountScoresArgs;
  };

  // Custom InputTypes
  /**
   * CriteriaCountOutputType without action
   */
  export type CriteriaCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CriteriaCountOutputType
     */
    select?: CriteriaCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * CriteriaCountOutputType without action
   */
  export type CriteriaCountOutputTypeCountScoresArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ScoreWhereInput;
  };

  /**
   * Count Type SubmissionCountOutputType
   */

  export type SubmissionCountOutputType = {
    scores: number;
  };

  export type SubmissionCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    scores?: boolean | SubmissionCountOutputTypeCountScoresArgs;
  };

  // Custom InputTypes
  /**
   * SubmissionCountOutputType without action
   */
  export type SubmissionCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SubmissionCountOutputType
     */
    select?: SubmissionCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * SubmissionCountOutputType without action
   */
  export type SubmissionCountOutputTypeCountScoresArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ScoreWhereInput;
  };

  /**
   * Count Type ChallengeCountOutputType
   */

  export type ChallengeCountOutputType = {
    submissions: number;
  };

  export type ChallengeCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    submissions?: boolean | ChallengeCountOutputTypeCountSubmissionsArgs;
  };

  // Custom InputTypes
  /**
   * ChallengeCountOutputType without action
   */
  export type ChallengeCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ChallengeCountOutputType
     */
    select?: ChallengeCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * ChallengeCountOutputType without action
   */
  export type ChallengeCountOutputTypeCountSubmissionsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ChallengeSubmissionWhereInput;
  };

  /**
   * Count Type CommentThreadCountOutputType
   */

  export type CommentThreadCountOutputType = {
    comments: number;
  };

  export type CommentThreadCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    comments?: boolean | CommentThreadCountOutputTypeCountCommentsArgs;
  };

  // Custom InputTypes
  /**
   * CommentThreadCountOutputType without action
   */
  export type CommentThreadCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CommentThreadCountOutputType
     */
    select?: CommentThreadCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * CommentThreadCountOutputType without action
   */
  export type CommentThreadCountOutputTypeCountCommentsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: CommentWhereInput;
  };

  /**
   * Count Type CommentCountOutputType
   */

  export type CommentCountOutputType = {
    replies: number;
  };

  export type CommentCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    replies?: boolean | CommentCountOutputTypeCountRepliesArgs;
  };

  // Custom InputTypes
  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CommentCountOutputType
     */
    select?: CommentCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeCountRepliesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: CommentWhereInput;
  };

  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null;
    _min: UserMinAggregateOutputType | null;
    _max: UserMaxAggregateOutputType | null;
  };

  export type UserMinAggregateOutputType = {
    id: string | null;
    email: string | null;
    emailVerified: Date | null;
    name: string | null;
    handle: string | null;
    avatarUrl: string | null;
    bio: string | null;
    organization: string | null;
    password: string | null;
    totpSecret: string | null;
    totpEnabled: boolean | null;
    passwordResetToken: string | null;
    passwordResetExpires: Date | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    lastLoginAt: Date | null;
    isActive: boolean | null;
    isBanned: boolean | null;
  };

  export type UserMaxAggregateOutputType = {
    id: string | null;
    email: string | null;
    emailVerified: Date | null;
    name: string | null;
    handle: string | null;
    avatarUrl: string | null;
    bio: string | null;
    organization: string | null;
    password: string | null;
    totpSecret: string | null;
    totpEnabled: boolean | null;
    passwordResetToken: string | null;
    passwordResetExpires: Date | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    lastLoginAt: Date | null;
    isActive: boolean | null;
    isBanned: boolean | null;
  };

  export type UserCountAggregateOutputType = {
    id: number;
    email: number;
    emailVerified: number;
    name: number;
    handle: number;
    avatarUrl: number;
    bio: number;
    organization: number;
    password: number;
    roles: number;
    totpSecret: number;
    totpEnabled: number;
    passwordResetToken: number;
    passwordResetExpires: number;
    createdAt: number;
    updatedAt: number;
    lastLoginAt: number;
    isActive: number;
    isBanned: number;
    _all: number;
  };

  export type UserMinAggregateInputType = {
    id?: true;
    email?: true;
    emailVerified?: true;
    name?: true;
    handle?: true;
    avatarUrl?: true;
    bio?: true;
    organization?: true;
    password?: true;
    totpSecret?: true;
    totpEnabled?: true;
    passwordResetToken?: true;
    passwordResetExpires?: true;
    createdAt?: true;
    updatedAt?: true;
    lastLoginAt?: true;
    isActive?: true;
    isBanned?: true;
  };

  export type UserMaxAggregateInputType = {
    id?: true;
    email?: true;
    emailVerified?: true;
    name?: true;
    handle?: true;
    avatarUrl?: true;
    bio?: true;
    organization?: true;
    password?: true;
    totpSecret?: true;
    totpEnabled?: true;
    passwordResetToken?: true;
    passwordResetExpires?: true;
    createdAt?: true;
    updatedAt?: true;
    lastLoginAt?: true;
    isActive?: true;
    isBanned?: true;
  };

  export type UserCountAggregateInputType = {
    id?: true;
    email?: true;
    emailVerified?: true;
    name?: true;
    handle?: true;
    avatarUrl?: true;
    bio?: true;
    organization?: true;
    password?: true;
    roles?: true;
    totpSecret?: true;
    totpEnabled?: true;
    passwordResetToken?: true;
    passwordResetExpires?: true;
    createdAt?: true;
    updatedAt?: true;
    lastLoginAt?: true;
    isActive?: true;
    isBanned?: true;
    _all?: true;
  };

  export type UserAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Users
     **/
    _count?: true | UserCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: UserMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: UserMaxAggregateInputType;
  };

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
    [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>;
  };

  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      where?: UserWhereInput;
      orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[];
      by: UserScalarFieldEnum[] | UserScalarFieldEnum;
      having?: UserScalarWhereWithAggregatesInput;
      take?: number;
      skip?: number;
      _count?: UserCountAggregateInputType | true;
      _min?: UserMinAggregateInputType;
      _max?: UserMaxAggregateInputType;
    };

  export type UserGroupByOutputType = {
    id: string;
    email: string;
    emailVerified: Date | null;
    name: string | null;
    handle: string | null;
    avatarUrl: string | null;
    bio: string | null;
    organization: string | null;
    password: string | null;
    roles: $Enums.Role[];
    totpSecret: string | null;
    totpEnabled: boolean;
    passwordResetToken: string | null;
    passwordResetExpires: Date | null;
    createdAt: Date;
    updatedAt: Date;
    lastLoginAt: Date | null;
    isActive: boolean;
    isBanned: boolean;
    _count: UserCountAggregateOutputType | null;
    _min: UserMinAggregateOutputType | null;
    _max: UserMaxAggregateOutputType | null;
  };

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> & {
        [P in keyof T & keyof UserGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], UserGroupByOutputType[P]>
          : GetScalarType<T[P], UserGroupByOutputType[P]>;
      }
    >
  >;

  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        email?: boolean;
        emailVerified?: boolean;
        name?: boolean;
        handle?: boolean;
        avatarUrl?: boolean;
        bio?: boolean;
        organization?: boolean;
        password?: boolean;
        roles?: boolean;
        totpSecret?: boolean;
        totpEnabled?: boolean;
        passwordResetToken?: boolean;
        passwordResetExpires?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        lastLoginAt?: boolean;
        isActive?: boolean;
        isBanned?: boolean;
        accounts?: boolean | User$accountsArgs<ExtArgs>;
        sessions?: boolean | User$sessionsArgs<ExtArgs>;
        apiKeys?: boolean | User$apiKeysArgs<ExtArgs>;
        auditLogs?: boolean | User$auditLogsArgs<ExtArgs>;
        teamMemberships?: boolean | User$teamMembershipsArgs<ExtArgs>;
        mentorProfiles?: boolean | User$mentorProfilesArgs<ExtArgs>;
        judgeAssignments?: boolean | User$judgeAssignmentsArgs<ExtArgs>;
        challengeSubmissions?: boolean | User$challengeSubmissionsArgs<ExtArgs>;
        comments?: boolean | User$commentsArgs<ExtArgs>;
        gamificationProfile?: boolean | User$gamificationProfileArgs<ExtArgs>;
        xpEvents?: boolean | User$xpEventsArgs<ExtArgs>;
        notifications?: boolean | User$notificationsArgs<ExtArgs>;
        reports?: boolean | User$reportsArgs<ExtArgs>;
        uploadedFiles?: boolean | User$uploadedFilesArgs<ExtArgs>;
        ownedChallenges?: boolean | User$ownedChallengesArgs<ExtArgs>;
        _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>;
      },
      ExtArgs['result']['user']
    >;

  export type UserSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      email?: boolean;
      emailVerified?: boolean;
      name?: boolean;
      handle?: boolean;
      avatarUrl?: boolean;
      bio?: boolean;
      organization?: boolean;
      password?: boolean;
      roles?: boolean;
      totpSecret?: boolean;
      totpEnabled?: boolean;
      passwordResetToken?: boolean;
      passwordResetExpires?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      lastLoginAt?: boolean;
      isActive?: boolean;
      isBanned?: boolean;
    },
    ExtArgs['result']['user']
  >;

  export type UserSelectScalar = {
    id?: boolean;
    email?: boolean;
    emailVerified?: boolean;
    name?: boolean;
    handle?: boolean;
    avatarUrl?: boolean;
    bio?: boolean;
    organization?: boolean;
    password?: boolean;
    roles?: boolean;
    totpSecret?: boolean;
    totpEnabled?: boolean;
    passwordResetToken?: boolean;
    passwordResetExpires?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    lastLoginAt?: boolean;
    isActive?: boolean;
    isBanned?: boolean;
  };

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | User$accountsArgs<ExtArgs>;
    sessions?: boolean | User$sessionsArgs<ExtArgs>;
    apiKeys?: boolean | User$apiKeysArgs<ExtArgs>;
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>;
    teamMemberships?: boolean | User$teamMembershipsArgs<ExtArgs>;
    mentorProfiles?: boolean | User$mentorProfilesArgs<ExtArgs>;
    judgeAssignments?: boolean | User$judgeAssignmentsArgs<ExtArgs>;
    challengeSubmissions?: boolean | User$challengeSubmissionsArgs<ExtArgs>;
    comments?: boolean | User$commentsArgs<ExtArgs>;
    gamificationProfile?: boolean | User$gamificationProfileArgs<ExtArgs>;
    xpEvents?: boolean | User$xpEventsArgs<ExtArgs>;
    notifications?: boolean | User$notificationsArgs<ExtArgs>;
    reports?: boolean | User$reportsArgs<ExtArgs>;
    uploadedFiles?: boolean | User$uploadedFilesArgs<ExtArgs>;
    ownedChallenges?: boolean | User$ownedChallengesArgs<ExtArgs>;
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type UserIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: 'User';
    objects: {
      accounts: Prisma.$AccountPayload<ExtArgs>[];
      sessions: Prisma.$SessionPayload<ExtArgs>[];
      apiKeys: Prisma.$ApiKeyPayload<ExtArgs>[];
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[];
      teamMemberships: Prisma.$TeamMemberPayload<ExtArgs>[];
      mentorProfiles: Prisma.$MentorPayload<ExtArgs>[];
      judgeAssignments: Prisma.$JudgePayload<ExtArgs>[];
      challengeSubmissions: Prisma.$ChallengeSubmissionPayload<ExtArgs>[];
      comments: Prisma.$CommentPayload<ExtArgs>[];
      gamificationProfile: Prisma.$GamificationProfilePayload<ExtArgs> | null;
      xpEvents: Prisma.$XpEventPayload<ExtArgs>[];
      notifications: Prisma.$NotificationPayload<ExtArgs>[];
      reports: Prisma.$ReportPayload<ExtArgs>[];
      uploadedFiles: Prisma.$FilePayload<ExtArgs>[];
      ownedChallenges: Prisma.$ChallengePayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        email: string;
        emailVerified: Date | null;
        name: string | null;
        handle: string | null;
        avatarUrl: string | null;
        bio: string | null;
        organization: string | null;
        password: string | null;
        roles: $Enums.Role[];
        totpSecret: string | null;
        totpEnabled: boolean;
        passwordResetToken: string | null;
        passwordResetExpires: Date | null;
        createdAt: Date;
        updatedAt: Date;
        lastLoginAt: Date | null;
        isActive: boolean;
        isBanned: boolean;
      },
      ExtArgs['result']['user']
    >;
    composites: {};
  };

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<
    Prisma.$UserPayload,
    S
  >;

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    UserFindManyArgs,
    'select' | 'include' | 'distinct'
  > & {
    select?: UserCountAggregateInputType | true;
  };

  export interface UserDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User']; meta: { name: 'User' } };
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(
      args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUnique'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(
      args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(
      args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirst'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirstOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     *
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     *
     */
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findMany'>>;

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     *
     */
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'create'>,
      never,
      ExtArgs
    >;

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends UserCreateManyArgs>(
      args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(
      args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'createManyAndReturn'>
    >;

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     *
     */
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'delete'>,
      never,
      ExtArgs
    >;

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'update'>,
      never,
      ExtArgs
    >;

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'upsert'>,
      never,
      ExtArgs
    >;

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
     **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends UserAggregateArgs>(
      args: Subset<T, UserAggregateArgs>
    ): Prisma.PrismaPromise<GetUserAggregateType<T>>;

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the User model
     */
    readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$accountsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findMany'> | Null
    >;
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$sessionsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, 'findMany'> | Null
    >;
    apiKeys<T extends User$apiKeysArgs<ExtArgs> = {}>(
      args?: Subset<T, User$apiKeysArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, 'findMany'> | Null
    >;
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$auditLogsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, 'findMany'> | Null
    >;
    teamMemberships<T extends User$teamMembershipsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$teamMembershipsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, 'findMany'> | Null
    >;
    mentorProfiles<T extends User$mentorProfilesArgs<ExtArgs> = {}>(
      args?: Subset<T, User$mentorProfilesArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$MentorPayload<ExtArgs>, T, 'findMany'> | Null
    >;
    judgeAssignments<T extends User$judgeAssignmentsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$judgeAssignmentsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JudgePayload<ExtArgs>, T, 'findMany'> | Null>;
    challengeSubmissions<T extends User$challengeSubmissionsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$challengeSubmissionsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ChallengeSubmissionPayload<ExtArgs>, T, 'findMany'> | Null
    >;
    comments<T extends User$commentsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$commentsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'findMany'> | Null
    >;
    gamificationProfile<T extends User$gamificationProfileArgs<ExtArgs> = {}>(
      args?: Subset<T, User$gamificationProfileArgs<ExtArgs>>
    ): Prisma__GamificationProfileClient<
      $Result.GetResult<Prisma.$GamificationProfilePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null,
      null,
      ExtArgs
    >;
    xpEvents<T extends User$xpEventsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$xpEventsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$XpEventPayload<ExtArgs>, T, 'findMany'> | Null
    >;
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$notificationsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'findMany'> | Null
    >;
    reports<T extends User$reportsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$reportsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, 'findMany'> | Null
    >;
    uploadedFiles<T extends User$uploadedFilesArgs<ExtArgs> = {}>(
      args?: Subset<T, User$uploadedFilesArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, 'findMany'> | Null>;
    ownedChallenges<T extends User$ownedChallengesArgs<ExtArgs> = {}>(
      args?: Subset<T, User$ownedChallengesArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, 'findMany'> | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<'User', 'String'>;
    readonly email: FieldRef<'User', 'String'>;
    readonly emailVerified: FieldRef<'User', 'DateTime'>;
    readonly name: FieldRef<'User', 'String'>;
    readonly handle: FieldRef<'User', 'String'>;
    readonly avatarUrl: FieldRef<'User', 'String'>;
    readonly bio: FieldRef<'User', 'String'>;
    readonly organization: FieldRef<'User', 'String'>;
    readonly password: FieldRef<'User', 'String'>;
    readonly roles: FieldRef<'User', 'Role[]'>;
    readonly totpSecret: FieldRef<'User', 'String'>;
    readonly totpEnabled: FieldRef<'User', 'Boolean'>;
    readonly passwordResetToken: FieldRef<'User', 'String'>;
    readonly passwordResetExpires: FieldRef<'User', 'DateTime'>;
    readonly createdAt: FieldRef<'User', 'DateTime'>;
    readonly updatedAt: FieldRef<'User', 'DateTime'>;
    readonly lastLoginAt: FieldRef<'User', 'DateTime'>;
    readonly isActive: FieldRef<'User', 'Boolean'>;
    readonly isBanned: FieldRef<'User', 'Boolean'>;
  }

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput;
  };

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput;
  };

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[];
  };

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[];
  };

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the User
       */
      select?: UserSelect<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: UserInclude<ExtArgs> | null;
      /**
       * Filter, which Users to fetch.
       */
      where?: UserWhereInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
       *
       * Determine the order of Users to fetch.
       */
      orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
       *
       * Sets the position for listing Users.
       */
      cursor?: UserWhereUniqueInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Take `±n` Users from the position of the cursor.
       */
      take?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Skip the first `n` Users.
       */
      skip?: number;
      distinct?: UserScalarFieldEnum | UserScalarFieldEnum[];
    };

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>;
  };

  /**
   * User createMany
   */
  export type UserCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>;
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput;
  };

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>;
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput;
  };

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput;
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>;
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>;
  };

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput;
  };

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput;
  };

  /**
   * User.accounts
   */
  export type User$accountsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
    where?: AccountWhereInput;
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[];
    cursor?: AccountWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[];
  };

  /**
   * User.sessions
   */
  export type User$sessionsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    where?: SessionWhereInput;
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[];
    cursor?: SessionWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[];
  };

  /**
   * User.apiKeys
   */
  export type User$apiKeysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the ApiKey
       */
      select?: ApiKeySelect<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: ApiKeyInclude<ExtArgs> | null;
      where?: ApiKeyWhereInput;
      orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[];
      cursor?: ApiKeyWhereUniqueInput;
      take?: number;
      skip?: number;
      distinct?: ApiKeyScalarFieldEnum | ApiKeyScalarFieldEnum[];
    };

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
    where?: AuditLogWhereInput;
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[];
    cursor?: AuditLogWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[];
  };

  /**
   * User.teamMemberships
   */
  export type User$teamMembershipsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null;
    where?: TeamMemberWhereInput;
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[];
    cursor?: TeamMemberWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[];
  };

  /**
   * User.mentorProfiles
   */
  export type User$mentorProfilesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Mentor
     */
    select?: MentorSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorInclude<ExtArgs> | null;
    where?: MentorWhereInput;
    orderBy?: MentorOrderByWithRelationInput | MentorOrderByWithRelationInput[];
    cursor?: MentorWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: MentorScalarFieldEnum | MentorScalarFieldEnum[];
  };

  /**
   * User.judgeAssignments
   */
  export type User$judgeAssignmentsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Judge
     */
    select?: JudgeSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JudgeInclude<ExtArgs> | null;
    where?: JudgeWhereInput;
    orderBy?: JudgeOrderByWithRelationInput | JudgeOrderByWithRelationInput[];
    cursor?: JudgeWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: JudgeScalarFieldEnum | JudgeScalarFieldEnum[];
  };

  /**
   * User.challengeSubmissions
   */
  export type User$challengeSubmissionsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ChallengeSubmission
     */
    select?: ChallengeSubmissionSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeSubmissionInclude<ExtArgs> | null;
    where?: ChallengeSubmissionWhereInput;
    orderBy?:
      | ChallengeSubmissionOrderByWithRelationInput
      | ChallengeSubmissionOrderByWithRelationInput[];
    cursor?: ChallengeSubmissionWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ChallengeSubmissionScalarFieldEnum | ChallengeSubmissionScalarFieldEnum[];
  };

  /**
   * User.comments
   */
  export type User$commentsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null;
    where?: CommentWhereInput;
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[];
    cursor?: CommentWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[];
  };

  /**
   * User.gamificationProfile
   */
  export type User$gamificationProfileArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the GamificationProfile
     */
    select?: GamificationProfileSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GamificationProfileInclude<ExtArgs> | null;
    where?: GamificationProfileWhereInput;
  };

  /**
   * User.xpEvents
   */
  export type User$xpEventsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the XpEvent
     */
    select?: XpEventSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XpEventInclude<ExtArgs> | null;
    where?: XpEventWhereInput;
    orderBy?: XpEventOrderByWithRelationInput | XpEventOrderByWithRelationInput[];
    cursor?: XpEventWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: XpEventScalarFieldEnum | XpEventScalarFieldEnum[];
  };

  /**
   * User.notifications
   */
  export type User$notificationsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    where?: NotificationWhereInput;
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[];
    cursor?: NotificationWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[];
  };

  /**
   * User.reports
   */
  export type User$reportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the Report
       */
      select?: ReportSelect<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: ReportInclude<ExtArgs> | null;
      where?: ReportWhereInput;
      orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[];
      cursor?: ReportWhereUniqueInput;
      take?: number;
      skip?: number;
      distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[];
    };

  /**
   * User.uploadedFiles
   */
  export type User$uploadedFilesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null;
    where?: FileWhereInput;
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[];
    cursor?: FileWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[];
  };

  /**
   * User.ownedChallenges
   */
  export type User$ownedChallengesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null;
    where?: ChallengeWhereInput;
    orderBy?: ChallengeOrderByWithRelationInput | ChallengeOrderByWithRelationInput[];
    cursor?: ChallengeWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ChallengeScalarFieldEnum | ChallengeScalarFieldEnum[];
  };

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the User
       */
      select?: UserSelect<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: UserInclude<ExtArgs> | null;
    };

  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null;
    _avg: AccountAvgAggregateOutputType | null;
    _sum: AccountSumAggregateOutputType | null;
    _min: AccountMinAggregateOutputType | null;
    _max: AccountMaxAggregateOutputType | null;
  };

  export type AccountAvgAggregateOutputType = {
    expires_at: number | null;
  };

  export type AccountSumAggregateOutputType = {
    expires_at: number | null;
  };

  export type AccountMinAggregateOutputType = {
    id: string | null;
    userId: string | null;
    type: string | null;
    provider: string | null;
    providerAccountId: string | null;
    refresh_token: string | null;
    access_token: string | null;
    expires_at: number | null;
    token_type: string | null;
    scope: string | null;
    id_token: string | null;
    session_state: string | null;
  };

  export type AccountMaxAggregateOutputType = {
    id: string | null;
    userId: string | null;
    type: string | null;
    provider: string | null;
    providerAccountId: string | null;
    refresh_token: string | null;
    access_token: string | null;
    expires_at: number | null;
    token_type: string | null;
    scope: string | null;
    id_token: string | null;
    session_state: string | null;
  };

  export type AccountCountAggregateOutputType = {
    id: number;
    userId: number;
    type: number;
    provider: number;
    providerAccountId: number;
    refresh_token: number;
    access_token: number;
    expires_at: number;
    token_type: number;
    scope: number;
    id_token: number;
    session_state: number;
    _all: number;
  };

  export type AccountAvgAggregateInputType = {
    expires_at?: true;
  };

  export type AccountSumAggregateInputType = {
    expires_at?: true;
  };

  export type AccountMinAggregateInputType = {
    id?: true;
    userId?: true;
    type?: true;
    provider?: true;
    providerAccountId?: true;
    refresh_token?: true;
    access_token?: true;
    expires_at?: true;
    token_type?: true;
    scope?: true;
    id_token?: true;
    session_state?: true;
  };

  export type AccountMaxAggregateInputType = {
    id?: true;
    userId?: true;
    type?: true;
    provider?: true;
    providerAccountId?: true;
    refresh_token?: true;
    access_token?: true;
    expires_at?: true;
    token_type?: true;
    scope?: true;
    id_token?: true;
    session_state?: true;
  };

  export type AccountCountAggregateInputType = {
    id?: true;
    userId?: true;
    type?: true;
    provider?: true;
    providerAccountId?: true;
    refresh_token?: true;
    access_token?: true;
    expires_at?: true;
    token_type?: true;
    scope?: true;
    id_token?: true;
    session_state?: true;
    _all?: true;
  };

  export type AccountAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Accounts.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Accounts
     **/
    _count?: true | AccountCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: AccountAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: AccountSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: AccountMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: AccountMaxAggregateInputType;
  };

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
    [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>;
  };

  export type AccountGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AccountWhereInput;
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[];
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum;
    having?: AccountScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: AccountCountAggregateInputType | true;
    _avg?: AccountAvgAggregateInputType;
    _sum?: AccountSumAggregateInputType;
    _min?: AccountMinAggregateInputType;
    _max?: AccountMaxAggregateInputType;
  };

  export type AccountGroupByOutputType = {
    id: string;
    userId: string;
    type: string;
    provider: string;
    providerAccountId: string;
    refresh_token: string | null;
    access_token: string | null;
    expires_at: number | null;
    token_type: string | null;
    scope: string | null;
    id_token: string | null;
    session_state: string | null;
    _count: AccountCountAggregateOutputType | null;
    _avg: AccountAvgAggregateOutputType | null;
    _sum: AccountSumAggregateOutputType | null;
    _min: AccountMinAggregateOutputType | null;
    _max: AccountMaxAggregateOutputType | null;
  };

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> & {
        [P in keyof T & keyof AccountGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
          : GetScalarType<T[P], AccountGroupByOutputType[P]>;
      }
    >
  >;

  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        userId?: boolean;
        type?: boolean;
        provider?: boolean;
        providerAccountId?: boolean;
        refresh_token?: boolean;
        access_token?: boolean;
        expires_at?: boolean;
        token_type?: boolean;
        scope?: boolean;
        id_token?: boolean;
        session_state?: boolean;
        user?: boolean | UserDefaultArgs<ExtArgs>;
      },
      ExtArgs['result']['account']
    >;

  export type AccountSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      type?: boolean;
      provider?: boolean;
      providerAccountId?: boolean;
      refresh_token?: boolean;
      access_token?: boolean;
      expires_at?: boolean;
      token_type?: boolean;
      scope?: boolean;
      id_token?: boolean;
      session_state?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['account']
  >;

  export type AccountSelectScalar = {
    id?: boolean;
    userId?: boolean;
    type?: boolean;
    provider?: boolean;
    providerAccountId?: boolean;
    refresh_token?: boolean;
    access_token?: boolean;
    expires_at?: boolean;
    token_type?: boolean;
    scope?: boolean;
    id_token?: boolean;
    session_state?: boolean;
  };

  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type AccountIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      name: 'Account';
      objects: {
        user: Prisma.$UserPayload<ExtArgs>;
      };
      scalars: $Extensions.GetPayloadResult<
        {
          id: string;
          userId: string;
          type: string;
          provider: string;
          providerAccountId: string;
          refresh_token: string | null;
          access_token: string | null;
          expires_at: number | null;
          token_type: string | null;
          scope: string | null;
          id_token: string | null;
          session_state: string | null;
        },
        ExtArgs['result']['account']
      >;
      composites: {};
    };

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> =
    $Result.GetResult<Prisma.$AccountPayload, S>;

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    AccountFindManyArgs,
    'select' | 'include' | 'distinct'
  > & {
    select?: AccountCountAggregateInputType | true;
  };

  export interface AccountDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account']; meta: { name: 'Account' } };
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(
      args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>
    ): Prisma__AccountClient<
      $Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findUnique'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(
      args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AccountClient<
      $Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findUniqueOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(
      args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>
    ): Prisma__AccountClient<
      $Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findFirst'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AccountClient<
      $Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findFirstOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     *
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     *
     */
    findMany<T extends AccountFindManyArgs>(
      args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findMany'>>;

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     *
     */
    create<T extends AccountCreateArgs>(
      args: SelectSubset<T, AccountCreateArgs<ExtArgs>>
    ): Prisma__AccountClient<
      $Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'create'>,
      never,
      ExtArgs
    >;

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends AccountCreateManyArgs>(
      args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(
      args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'createManyAndReturn'>
    >;

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     *
     */
    delete<T extends AccountDeleteArgs>(
      args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>
    ): Prisma__AccountClient<
      $Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'delete'>,
      never,
      ExtArgs
    >;

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends AccountUpdateArgs>(
      args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>
    ): Prisma__AccountClient<
      $Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'update'>,
      never,
      ExtArgs
    >;

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends AccountDeleteManyArgs>(
      args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends AccountUpdateManyArgs>(
      args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(
      args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>
    ): Prisma__AccountClient<
      $Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'upsert'>,
      never,
      ExtArgs
    >;

    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
     **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends AccountAggregateArgs>(
      args: Subset<T, AccountAggregateArgs>
    ): Prisma.PrismaPromise<GetAccountAggregateType<T>>;

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Account model
     */
    readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null,
      Null,
      ExtArgs
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly id: FieldRef<'Account', 'String'>;
    readonly userId: FieldRef<'Account', 'String'>;
    readonly type: FieldRef<'Account', 'String'>;
    readonly provider: FieldRef<'Account', 'String'>;
    readonly providerAccountId: FieldRef<'Account', 'String'>;
    readonly refresh_token: FieldRef<'Account', 'String'>;
    readonly access_token: FieldRef<'Account', 'String'>;
    readonly expires_at: FieldRef<'Account', 'Int'>;
    readonly token_type: FieldRef<'Account', 'String'>;
    readonly scope: FieldRef<'Account', 'String'>;
    readonly id_token: FieldRef<'Account', 'String'>;
    readonly session_state: FieldRef<'Account', 'String'>;
  }

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput;
  };

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput;
  };

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Accounts.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[];
  };

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Accounts.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[];
  };

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Accounts.
     */
    skip?: number;
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[];
  };

  /**
   * Account create
   */
  export type AccountCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>;
  };

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Account update
   */
  export type AccountUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>;
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput;
  };

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>;
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput;
  };

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput;
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>;
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>;
  };

  /**
   * Account delete
   */
  export type AccountDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput;
  };

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput;
  };

  /**
   * Account without action
   */
  export type AccountDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null;
  };

  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null;
    _min: SessionMinAggregateOutputType | null;
    _max: SessionMaxAggregateOutputType | null;
  };

  export type SessionMinAggregateOutputType = {
    id: string | null;
    sessionToken: string | null;
    userId: string | null;
    expires: Date | null;
  };

  export type SessionMaxAggregateOutputType = {
    id: string | null;
    sessionToken: string | null;
    userId: string | null;
    expires: Date | null;
  };

  export type SessionCountAggregateOutputType = {
    id: number;
    sessionToken: number;
    userId: number;
    expires: number;
    _all: number;
  };

  export type SessionMinAggregateInputType = {
    id?: true;
    sessionToken?: true;
    userId?: true;
    expires?: true;
  };

  export type SessionMaxAggregateInputType = {
    id?: true;
    sessionToken?: true;
    userId?: true;
    expires?: true;
  };

  export type SessionCountAggregateInputType = {
    id?: true;
    sessionToken?: true;
    userId?: true;
    expires?: true;
    _all?: true;
  };

  export type SessionAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Sessions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Sessions
     **/
    _count?: true | SessionCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: SessionMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: SessionMaxAggregateInputType;
  };

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
    [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>;
  };

  export type SessionGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: SessionWhereInput;
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[];
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum;
    having?: SessionScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: SessionCountAggregateInputType | true;
    _min?: SessionMinAggregateInputType;
    _max?: SessionMaxAggregateInputType;
  };

  export type SessionGroupByOutputType = {
    id: string;
    sessionToken: string;
    userId: string;
    expires: Date;
    _count: SessionCountAggregateOutputType | null;
    _min: SessionMinAggregateOutputType | null;
    _max: SessionMaxAggregateOutputType | null;
  };

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> & {
        [P in keyof T & keyof SessionGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
          : GetScalarType<T[P], SessionGroupByOutputType[P]>;
      }
    >
  >;

  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        sessionToken?: boolean;
        userId?: boolean;
        expires?: boolean;
        user?: boolean | UserDefaultArgs<ExtArgs>;
      },
      ExtArgs['result']['session']
    >;

  export type SessionSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      sessionToken?: boolean;
      userId?: boolean;
      expires?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['session']
  >;

  export type SessionSelectScalar = {
    id?: boolean;
    sessionToken?: boolean;
    userId?: boolean;
    expires?: boolean;
  };

  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type SessionIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      name: 'Session';
      objects: {
        user: Prisma.$UserPayload<ExtArgs>;
      };
      scalars: $Extensions.GetPayloadResult<
        {
          id: string;
          sessionToken: string;
          userId: string;
          expires: Date;
        },
        ExtArgs['result']['session']
      >;
      composites: {};
    };

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> =
    $Result.GetResult<Prisma.$SessionPayload, S>;

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    SessionFindManyArgs,
    'select' | 'include' | 'distinct'
  > & {
    select?: SessionCountAggregateInputType | true;
  };

  export interface SessionDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session']; meta: { name: 'Session' } };
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(
      args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>
    ): Prisma__SessionClient<
      $Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, 'findUnique'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(
      args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SessionClient<
      $Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, 'findUniqueOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(
      args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>
    ): Prisma__SessionClient<
      $Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, 'findFirst'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SessionClient<
      $Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, 'findFirstOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     *
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     *
     */
    findMany<T extends SessionFindManyArgs>(
      args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, 'findMany'>>;

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     *
     */
    create<T extends SessionCreateArgs>(
      args: SelectSubset<T, SessionCreateArgs<ExtArgs>>
    ): Prisma__SessionClient<
      $Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, 'create'>,
      never,
      ExtArgs
    >;

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends SessionCreateManyArgs>(
      args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(
      args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, 'createManyAndReturn'>
    >;

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     *
     */
    delete<T extends SessionDeleteArgs>(
      args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>
    ): Prisma__SessionClient<
      $Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, 'delete'>,
      never,
      ExtArgs
    >;

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends SessionUpdateArgs>(
      args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>
    ): Prisma__SessionClient<
      $Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, 'update'>,
      never,
      ExtArgs
    >;

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends SessionDeleteManyArgs>(
      args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends SessionUpdateManyArgs>(
      args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(
      args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>
    ): Prisma__SessionClient<
      $Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, 'upsert'>,
      never,
      ExtArgs
    >;

    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
     **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends SessionAggregateArgs>(
      args: Subset<T, SessionAggregateArgs>
    ): Prisma.PrismaPromise<GetSessionAggregateType<T>>;

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Session model
     */
    readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null,
      Null,
      ExtArgs
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<'Session', 'String'>;
    readonly sessionToken: FieldRef<'Session', 'String'>;
    readonly userId: FieldRef<'Session', 'String'>;
    readonly expires: FieldRef<'Session', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput;
  };

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput;
  };

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Sessions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[];
  };

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Sessions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[];
  };

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Sessions.
     */
    skip?: number;
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[];
  };

  /**
   * Session create
   */
  export type SessionCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>;
  };

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Session update
   */
  export type SessionUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>;
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput;
  };

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>;
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput;
  };

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput;
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>;
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>;
  };

  /**
   * Session delete
   */
  export type SessionDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput;
  };

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput;
  };

  /**
   * Session without action
   */
  export type SessionDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null;
  };

  /**
   * Model VerificationToken
   */

  export type AggregateVerificationToken = {
    _count: VerificationTokenCountAggregateOutputType | null;
    _min: VerificationTokenMinAggregateOutputType | null;
    _max: VerificationTokenMaxAggregateOutputType | null;
  };

  export type VerificationTokenMinAggregateOutputType = {
    identifier: string | null;
    token: string | null;
    expires: Date | null;
  };

  export type VerificationTokenMaxAggregateOutputType = {
    identifier: string | null;
    token: string | null;
    expires: Date | null;
  };

  export type VerificationTokenCountAggregateOutputType = {
    identifier: number;
    token: number;
    expires: number;
    _all: number;
  };

  export type VerificationTokenMinAggregateInputType = {
    identifier?: true;
    token?: true;
    expires?: true;
  };

  export type VerificationTokenMaxAggregateInputType = {
    identifier?: true;
    token?: true;
    expires?: true;
  };

  export type VerificationTokenCountAggregateInputType = {
    identifier?: true;
    token?: true;
    expires?: true;
    _all?: true;
  };

  export type VerificationTokenAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which VerificationToken to aggregate.
     */
    where?: VerificationTokenWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?:
      | VerificationTokenOrderByWithRelationInput
      | VerificationTokenOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: VerificationTokenWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` VerificationTokens.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned VerificationTokens
     **/
    _count?: true | VerificationTokenCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: VerificationTokenMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: VerificationTokenMaxAggregateInputType;
  };

  export type GetVerificationTokenAggregateType<T extends VerificationTokenAggregateArgs> = {
    [P in keyof T & keyof AggregateVerificationToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerificationToken[P]>
      : GetScalarType<T[P], AggregateVerificationToken[P]>;
  };

  export type VerificationTokenGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: VerificationTokenWhereInput;
    orderBy?:
      | VerificationTokenOrderByWithAggregationInput
      | VerificationTokenOrderByWithAggregationInput[];
    by: VerificationTokenScalarFieldEnum[] | VerificationTokenScalarFieldEnum;
    having?: VerificationTokenScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: VerificationTokenCountAggregateInputType | true;
    _min?: VerificationTokenMinAggregateInputType;
    _max?: VerificationTokenMaxAggregateInputType;
  };

  export type VerificationTokenGroupByOutputType = {
    identifier: string;
    token: string;
    expires: Date;
    _count: VerificationTokenCountAggregateOutputType | null;
    _min: VerificationTokenMinAggregateOutputType | null;
    _max: VerificationTokenMaxAggregateOutputType | null;
  };

  type GetVerificationTokenGroupByPayload<T extends VerificationTokenGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<VerificationTokenGroupByOutputType, T['by']> & {
          [P in keyof T & keyof VerificationTokenGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>;
        }
      >
    >;

  export type VerificationTokenSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      identifier?: boolean;
      token?: boolean;
      expires?: boolean;
    },
    ExtArgs['result']['verificationToken']
  >;

  export type VerificationTokenSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      identifier?: boolean;
      token?: boolean;
      expires?: boolean;
    },
    ExtArgs['result']['verificationToken']
  >;

  export type VerificationTokenSelectScalar = {
    identifier?: boolean;
    token?: boolean;
    expires?: boolean;
  };

  export type $VerificationTokenPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'VerificationToken';
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        identifier: string;
        token: string;
        expires: Date;
      },
      ExtArgs['result']['verificationToken']
    >;
    composites: {};
  };

  type VerificationTokenGetPayload<
    S extends boolean | null | undefined | VerificationTokenDefaultArgs,
  > = $Result.GetResult<Prisma.$VerificationTokenPayload, S>;

  type VerificationTokenCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<VerificationTokenFindManyArgs, 'select' | 'include' | 'distinct'> & {
    select?: VerificationTokenCountAggregateInputType | true;
  };

  export interface VerificationTokenDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['VerificationToken'];
      meta: { name: 'VerificationToken' };
    };
    /**
     * Find zero or one VerificationToken that matches the filter.
     * @param {VerificationTokenFindUniqueArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationTokenFindUniqueArgs>(
      args: SelectSubset<T, VerificationTokenFindUniqueArgs<ExtArgs>>
    ): Prisma__VerificationTokenClient<
      $Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, 'findUnique'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find one VerificationToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerificationTokenFindUniqueOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationTokenFindUniqueOrThrowArgs>(
      args: SelectSubset<T, VerificationTokenFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__VerificationTokenClient<
      $Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, 'findUniqueOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find the first VerificationToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationTokenFindFirstArgs>(
      args?: SelectSubset<T, VerificationTokenFindFirstArgs<ExtArgs>>
    ): Prisma__VerificationTokenClient<
      $Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, 'findFirst'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find the first VerificationToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationTokenFindFirstOrThrowArgs>(
      args?: SelectSubset<T, VerificationTokenFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__VerificationTokenClient<
      $Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, 'findFirstOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more VerificationTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany()
     *
     * // Get first 10 VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany({ take: 10 })
     *
     * // Only select the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.findMany({ select: { identifier: true } })
     *
     */
    findMany<T extends VerificationTokenFindManyArgs>(
      args?: SelectSubset<T, VerificationTokenFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, 'findMany'>
    >;

    /**
     * Create a VerificationToken.
     * @param {VerificationTokenCreateArgs} args - Arguments to create a VerificationToken.
     * @example
     * // Create one VerificationToken
     * const VerificationToken = await prisma.verificationToken.create({
     *   data: {
     *     // ... data to create a VerificationToken
     *   }
     * })
     *
     */
    create<T extends VerificationTokenCreateArgs>(
      args: SelectSubset<T, VerificationTokenCreateArgs<ExtArgs>>
    ): Prisma__VerificationTokenClient<
      $Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, 'create'>,
      never,
      ExtArgs
    >;

    /**
     * Create many VerificationTokens.
     * @param {VerificationTokenCreateManyArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends VerificationTokenCreateManyArgs>(
      args?: SelectSubset<T, VerificationTokenCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many VerificationTokens and returns the data saved in the database.
     * @param {VerificationTokenCreateManyAndReturnArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many VerificationTokens and only return the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.createManyAndReturn({
     *   select: { identifier: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends VerificationTokenCreateManyAndReturnArgs>(
      args?: SelectSubset<T, VerificationTokenCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, 'createManyAndReturn'>
    >;

    /**
     * Delete a VerificationToken.
     * @param {VerificationTokenDeleteArgs} args - Arguments to delete one VerificationToken.
     * @example
     * // Delete one VerificationToken
     * const VerificationToken = await prisma.verificationToken.delete({
     *   where: {
     *     // ... filter to delete one VerificationToken
     *   }
     * })
     *
     */
    delete<T extends VerificationTokenDeleteArgs>(
      args: SelectSubset<T, VerificationTokenDeleteArgs<ExtArgs>>
    ): Prisma__VerificationTokenClient<
      $Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, 'delete'>,
      never,
      ExtArgs
    >;

    /**
     * Update one VerificationToken.
     * @param {VerificationTokenUpdateArgs} args - Arguments to update one VerificationToken.
     * @example
     * // Update one VerificationToken
     * const verificationToken = await prisma.verificationToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends VerificationTokenUpdateArgs>(
      args: SelectSubset<T, VerificationTokenUpdateArgs<ExtArgs>>
    ): Prisma__VerificationTokenClient<
      $Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, 'update'>,
      never,
      ExtArgs
    >;

    /**
     * Delete zero or more VerificationTokens.
     * @param {VerificationTokenDeleteManyArgs} args - Arguments to filter VerificationTokens to delete.
     * @example
     * // Delete a few VerificationTokens
     * const { count } = await prisma.verificationToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends VerificationTokenDeleteManyArgs>(
      args?: SelectSubset<T, VerificationTokenDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends VerificationTokenUpdateManyArgs>(
      args: SelectSubset<T, VerificationTokenUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one VerificationToken.
     * @param {VerificationTokenUpsertArgs} args - Arguments to update or create a VerificationToken.
     * @example
     * // Update or create a VerificationToken
     * const verificationToken = await prisma.verificationToken.upsert({
     *   create: {
     *     // ... data to create a VerificationToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerificationToken we want to update
     *   }
     * })
     */
    upsert<T extends VerificationTokenUpsertArgs>(
      args: SelectSubset<T, VerificationTokenUpsertArgs<ExtArgs>>
    ): Prisma__VerificationTokenClient<
      $Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, 'upsert'>,
      never,
      ExtArgs
    >;

    /**
     * Count the number of VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenCountArgs} args - Arguments to filter VerificationTokens to count.
     * @example
     * // Count the number of VerificationTokens
     * const count = await prisma.verificationToken.count({
     *   where: {
     *     // ... the filter for the VerificationTokens we want to count
     *   }
     * })
     **/
    count<T extends VerificationTokenCountArgs>(
      args?: Subset<T, VerificationTokenCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationTokenCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends VerificationTokenAggregateArgs>(
      args: Subset<T, VerificationTokenAggregateArgs>
    ): Prisma.PrismaPromise<GetVerificationTokenAggregateType<T>>;

    /**
     * Group by VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends VerificationTokenGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationTokenGroupByArgs['orderBy'] }
        : { orderBy?: VerificationTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, VerificationTokenGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetVerificationTokenGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the VerificationToken model
     */
    readonly fields: VerificationTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerificationToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationTokenClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the VerificationToken model
   */
  interface VerificationTokenFieldRefs {
    readonly identifier: FieldRef<'VerificationToken', 'String'>;
    readonly token: FieldRef<'VerificationToken', 'String'>;
    readonly expires: FieldRef<'VerificationToken', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * VerificationToken findUnique
   */
  export type VerificationTokenFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null;
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput;
  };

  /**
   * VerificationToken findUniqueOrThrow
   */
  export type VerificationTokenFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null;
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput;
  };

  /**
   * VerificationToken findFirst
   */
  export type VerificationTokenFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null;
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?:
      | VerificationTokenOrderByWithRelationInput
      | VerificationTokenOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` VerificationTokens.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[];
  };

  /**
   * VerificationToken findFirstOrThrow
   */
  export type VerificationTokenFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null;
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?:
      | VerificationTokenOrderByWithRelationInput
      | VerificationTokenOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` VerificationTokens.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[];
  };

  /**
   * VerificationToken findMany
   */
  export type VerificationTokenFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null;
    /**
     * Filter, which VerificationTokens to fetch.
     */
    where?: VerificationTokenWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?:
      | VerificationTokenOrderByWithRelationInput
      | VerificationTokenOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` VerificationTokens.
     */
    skip?: number;
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[];
  };

  /**
   * VerificationToken create
   */
  export type VerificationTokenCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null;
    /**
     * The data needed to create a VerificationToken.
     */
    data: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>;
  };

  /**
   * VerificationToken createMany
   */
  export type VerificationTokenCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * VerificationToken createManyAndReturn
   */
  export type VerificationTokenCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * VerificationToken update
   */
  export type VerificationTokenUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null;
    /**
     * The data needed to update a VerificationToken.
     */
    data: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>;
    /**
     * Choose, which VerificationToken to update.
     */
    where: VerificationTokenWhereUniqueInput;
  };

  /**
   * VerificationToken updateMany
   */
  export type VerificationTokenUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>;
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput;
  };

  /**
   * VerificationToken upsert
   */
  export type VerificationTokenUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null;
    /**
     * The filter to search for the VerificationToken to update in case it exists.
     */
    where: VerificationTokenWhereUniqueInput;
    /**
     * In case the VerificationToken found by the `where` argument doesn't exist, create a new VerificationToken with this data.
     */
    create: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>;
    /**
     * In case the VerificationToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>;
  };

  /**
   * VerificationToken delete
   */
  export type VerificationTokenDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null;
    /**
     * Filter which VerificationToken to delete.
     */
    where: VerificationTokenWhereUniqueInput;
  };

  /**
   * VerificationToken deleteMany
   */
  export type VerificationTokenDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which VerificationTokens to delete
     */
    where?: VerificationTokenWhereInput;
  };

  /**
   * VerificationToken without action
   */
  export type VerificationTokenDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null;
  };

  /**
   * Model ApiKey
   */

  export type AggregateApiKey = {
    _count: ApiKeyCountAggregateOutputType | null;
    _min: ApiKeyMinAggregateOutputType | null;
    _max: ApiKeyMaxAggregateOutputType | null;
  };

  export type ApiKeyMinAggregateOutputType = {
    id: string | null;
    userId: string | null;
    name: string | null;
    hashedKey: string | null;
    lastUsedAt: Date | null;
    expiresAt: Date | null;
    createdAt: Date | null;
    isActive: boolean | null;
  };

  export type ApiKeyMaxAggregateOutputType = {
    id: string | null;
    userId: string | null;
    name: string | null;
    hashedKey: string | null;
    lastUsedAt: Date | null;
    expiresAt: Date | null;
    createdAt: Date | null;
    isActive: boolean | null;
  };

  export type ApiKeyCountAggregateOutputType = {
    id: number;
    userId: number;
    name: number;
    hashedKey: number;
    scopes: number;
    lastUsedAt: number;
    expiresAt: number;
    createdAt: number;
    isActive: number;
    _all: number;
  };

  export type ApiKeyMinAggregateInputType = {
    id?: true;
    userId?: true;
    name?: true;
    hashedKey?: true;
    lastUsedAt?: true;
    expiresAt?: true;
    createdAt?: true;
    isActive?: true;
  };

  export type ApiKeyMaxAggregateInputType = {
    id?: true;
    userId?: true;
    name?: true;
    hashedKey?: true;
    lastUsedAt?: true;
    expiresAt?: true;
    createdAt?: true;
    isActive?: true;
  };

  export type ApiKeyCountAggregateInputType = {
    id?: true;
    userId?: true;
    name?: true;
    hashedKey?: true;
    scopes?: true;
    lastUsedAt?: true;
    expiresAt?: true;
    createdAt?: true;
    isActive?: true;
    _all?: true;
  };

  export type ApiKeyAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which ApiKey to aggregate.
     */
    where?: ApiKeyWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ApiKeys to fetch.
     */
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ApiKeyWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ApiKeys from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ApiKeys.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned ApiKeys
     **/
    _count?: true | ApiKeyCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ApiKeyMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ApiKeyMaxAggregateInputType;
  };

  export type GetApiKeyAggregateType<T extends ApiKeyAggregateArgs> = {
    [P in keyof T & keyof AggregateApiKey]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApiKey[P]>
      : GetScalarType<T[P], AggregateApiKey[P]>;
  };

  export type ApiKeyGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ApiKeyWhereInput;
    orderBy?: ApiKeyOrderByWithAggregationInput | ApiKeyOrderByWithAggregationInput[];
    by: ApiKeyScalarFieldEnum[] | ApiKeyScalarFieldEnum;
    having?: ApiKeyScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ApiKeyCountAggregateInputType | true;
    _min?: ApiKeyMinAggregateInputType;
    _max?: ApiKeyMaxAggregateInputType;
  };

  export type ApiKeyGroupByOutputType = {
    id: string;
    userId: string;
    name: string;
    hashedKey: string;
    scopes: string[];
    lastUsedAt: Date | null;
    expiresAt: Date | null;
    createdAt: Date;
    isActive: boolean;
    _count: ApiKeyCountAggregateOutputType | null;
    _min: ApiKeyMinAggregateOutputType | null;
    _max: ApiKeyMaxAggregateOutputType | null;
  };

  type GetApiKeyGroupByPayload<T extends ApiKeyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApiKeyGroupByOutputType, T['by']> & {
        [P in keyof T & keyof ApiKeyGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], ApiKeyGroupByOutputType[P]>
          : GetScalarType<T[P], ApiKeyGroupByOutputType[P]>;
      }
    >
  >;

  export type ApiKeySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        userId?: boolean;
        name?: boolean;
        hashedKey?: boolean;
        scopes?: boolean;
        lastUsedAt?: boolean;
        expiresAt?: boolean;
        createdAt?: boolean;
        isActive?: boolean;
        user?: boolean | UserDefaultArgs<ExtArgs>;
      },
      ExtArgs['result']['apiKey']
    >;

  export type ApiKeySelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      name?: boolean;
      hashedKey?: boolean;
      scopes?: boolean;
      lastUsedAt?: boolean;
      expiresAt?: boolean;
      createdAt?: boolean;
      isActive?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['apiKey']
  >;

  export type ApiKeySelectScalar = {
    id?: boolean;
    userId?: boolean;
    name?: boolean;
    hashedKey?: boolean;
    scopes?: boolean;
    lastUsedAt?: boolean;
    expiresAt?: boolean;
    createdAt?: boolean;
    isActive?: boolean;
  };

  export type ApiKeyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type ApiKeyIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $ApiKeyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: 'ApiKey';
    objects: {
      user: Prisma.$UserPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        userId: string;
        name: string;
        hashedKey: string;
        scopes: string[];
        lastUsedAt: Date | null;
        expiresAt: Date | null;
        createdAt: Date;
        isActive: boolean;
      },
      ExtArgs['result']['apiKey']
    >;
    composites: {};
  };

  type ApiKeyGetPayload<S extends boolean | null | undefined | ApiKeyDefaultArgs> =
    $Result.GetResult<Prisma.$ApiKeyPayload, S>;

  type ApiKeyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    ApiKeyFindManyArgs,
    'select' | 'include' | 'distinct'
  > & {
    select?: ApiKeyCountAggregateInputType | true;
  };

  export interface ApiKeyDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ApiKey']; meta: { name: 'ApiKey' } };
    /**
     * Find zero or one ApiKey that matches the filter.
     * @param {ApiKeyFindUniqueArgs} args - Arguments to find a ApiKey
     * @example
     * // Get one ApiKey
     * const apiKey = await prisma.apiKey.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApiKeyFindUniqueArgs>(
      args: SelectSubset<T, ApiKeyFindUniqueArgs<ExtArgs>>
    ): Prisma__ApiKeyClient<
      $Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, 'findUnique'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find one ApiKey that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ApiKeyFindUniqueOrThrowArgs} args - Arguments to find a ApiKey
     * @example
     * // Get one ApiKey
     * const apiKey = await prisma.apiKey.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApiKeyFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ApiKeyFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ApiKeyClient<
      $Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, 'findUniqueOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find the first ApiKey that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyFindFirstArgs} args - Arguments to find a ApiKey
     * @example
     * // Get one ApiKey
     * const apiKey = await prisma.apiKey.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApiKeyFindFirstArgs>(
      args?: SelectSubset<T, ApiKeyFindFirstArgs<ExtArgs>>
    ): Prisma__ApiKeyClient<
      $Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, 'findFirst'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find the first ApiKey that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyFindFirstOrThrowArgs} args - Arguments to find a ApiKey
     * @example
     * // Get one ApiKey
     * const apiKey = await prisma.apiKey.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApiKeyFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ApiKeyFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ApiKeyClient<
      $Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, 'findFirstOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more ApiKeys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ApiKeys
     * const apiKeys = await prisma.apiKey.findMany()
     *
     * // Get first 10 ApiKeys
     * const apiKeys = await prisma.apiKey.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const apiKeyWithIdOnly = await prisma.apiKey.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ApiKeyFindManyArgs>(
      args?: SelectSubset<T, ApiKeyFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, 'findMany'>>;

    /**
     * Create a ApiKey.
     * @param {ApiKeyCreateArgs} args - Arguments to create a ApiKey.
     * @example
     * // Create one ApiKey
     * const ApiKey = await prisma.apiKey.create({
     *   data: {
     *     // ... data to create a ApiKey
     *   }
     * })
     *
     */
    create<T extends ApiKeyCreateArgs>(
      args: SelectSubset<T, ApiKeyCreateArgs<ExtArgs>>
    ): Prisma__ApiKeyClient<
      $Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, 'create'>,
      never,
      ExtArgs
    >;

    /**
     * Create many ApiKeys.
     * @param {ApiKeyCreateManyArgs} args - Arguments to create many ApiKeys.
     * @example
     * // Create many ApiKeys
     * const apiKey = await prisma.apiKey.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ApiKeyCreateManyArgs>(
      args?: SelectSubset<T, ApiKeyCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many ApiKeys and returns the data saved in the database.
     * @param {ApiKeyCreateManyAndReturnArgs} args - Arguments to create many ApiKeys.
     * @example
     * // Create many ApiKeys
     * const apiKey = await prisma.apiKey.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many ApiKeys and only return the `id`
     * const apiKeyWithIdOnly = await prisma.apiKey.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends ApiKeyCreateManyAndReturnArgs>(
      args?: SelectSubset<T, ApiKeyCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, 'createManyAndReturn'>
    >;

    /**
     * Delete a ApiKey.
     * @param {ApiKeyDeleteArgs} args - Arguments to delete one ApiKey.
     * @example
     * // Delete one ApiKey
     * const ApiKey = await prisma.apiKey.delete({
     *   where: {
     *     // ... filter to delete one ApiKey
     *   }
     * })
     *
     */
    delete<T extends ApiKeyDeleteArgs>(
      args: SelectSubset<T, ApiKeyDeleteArgs<ExtArgs>>
    ): Prisma__ApiKeyClient<
      $Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, 'delete'>,
      never,
      ExtArgs
    >;

    /**
     * Update one ApiKey.
     * @param {ApiKeyUpdateArgs} args - Arguments to update one ApiKey.
     * @example
     * // Update one ApiKey
     * const apiKey = await prisma.apiKey.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ApiKeyUpdateArgs>(
      args: SelectSubset<T, ApiKeyUpdateArgs<ExtArgs>>
    ): Prisma__ApiKeyClient<
      $Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, 'update'>,
      never,
      ExtArgs
    >;

    /**
     * Delete zero or more ApiKeys.
     * @param {ApiKeyDeleteManyArgs} args - Arguments to filter ApiKeys to delete.
     * @example
     * // Delete a few ApiKeys
     * const { count } = await prisma.apiKey.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ApiKeyDeleteManyArgs>(
      args?: SelectSubset<T, ApiKeyDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more ApiKeys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ApiKeys
     * const apiKey = await prisma.apiKey.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ApiKeyUpdateManyArgs>(
      args: SelectSubset<T, ApiKeyUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one ApiKey.
     * @param {ApiKeyUpsertArgs} args - Arguments to update or create a ApiKey.
     * @example
     * // Update or create a ApiKey
     * const apiKey = await prisma.apiKey.upsert({
     *   create: {
     *     // ... data to create a ApiKey
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ApiKey we want to update
     *   }
     * })
     */
    upsert<T extends ApiKeyUpsertArgs>(
      args: SelectSubset<T, ApiKeyUpsertArgs<ExtArgs>>
    ): Prisma__ApiKeyClient<
      $Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, 'upsert'>,
      never,
      ExtArgs
    >;

    /**
     * Count the number of ApiKeys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyCountArgs} args - Arguments to filter ApiKeys to count.
     * @example
     * // Count the number of ApiKeys
     * const count = await prisma.apiKey.count({
     *   where: {
     *     // ... the filter for the ApiKeys we want to count
     *   }
     * })
     **/
    count<T extends ApiKeyCountArgs>(
      args?: Subset<T, ApiKeyCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApiKeyCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a ApiKey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ApiKeyAggregateArgs>(
      args: Subset<T, ApiKeyAggregateArgs>
    ): Prisma.PrismaPromise<GetApiKeyAggregateType<T>>;

    /**
     * Group by ApiKey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends ApiKeyGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApiKeyGroupByArgs['orderBy'] }
        : { orderBy?: ApiKeyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, ApiKeyGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetApiKeyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the ApiKey model
     */
    readonly fields: ApiKeyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ApiKey.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApiKeyClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null,
      Null,
      ExtArgs
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the ApiKey model
   */
  interface ApiKeyFieldRefs {
    readonly id: FieldRef<'ApiKey', 'String'>;
    readonly userId: FieldRef<'ApiKey', 'String'>;
    readonly name: FieldRef<'ApiKey', 'String'>;
    readonly hashedKey: FieldRef<'ApiKey', 'String'>;
    readonly scopes: FieldRef<'ApiKey', 'String[]'>;
    readonly lastUsedAt: FieldRef<'ApiKey', 'DateTime'>;
    readonly expiresAt: FieldRef<'ApiKey', 'DateTime'>;
    readonly createdAt: FieldRef<'ApiKey', 'DateTime'>;
    readonly isActive: FieldRef<'ApiKey', 'Boolean'>;
  }

  // Custom InputTypes
  /**
   * ApiKey findUnique
   */
  export type ApiKeyFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null;
    /**
     * Filter, which ApiKey to fetch.
     */
    where: ApiKeyWhereUniqueInput;
  };

  /**
   * ApiKey findUniqueOrThrow
   */
  export type ApiKeyFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null;
    /**
     * Filter, which ApiKey to fetch.
     */
    where: ApiKeyWhereUniqueInput;
  };

  /**
   * ApiKey findFirst
   */
  export type ApiKeyFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null;
    /**
     * Filter, which ApiKey to fetch.
     */
    where?: ApiKeyWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ApiKeys to fetch.
     */
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ApiKeys.
     */
    cursor?: ApiKeyWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ApiKeys from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ApiKeys.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ApiKeys.
     */
    distinct?: ApiKeyScalarFieldEnum | ApiKeyScalarFieldEnum[];
  };

  /**
   * ApiKey findFirstOrThrow
   */
  export type ApiKeyFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null;
    /**
     * Filter, which ApiKey to fetch.
     */
    where?: ApiKeyWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ApiKeys to fetch.
     */
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ApiKeys.
     */
    cursor?: ApiKeyWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ApiKeys from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ApiKeys.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ApiKeys.
     */
    distinct?: ApiKeyScalarFieldEnum | ApiKeyScalarFieldEnum[];
  };

  /**
   * ApiKey findMany
   */
  export type ApiKeyFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null;
    /**
     * Filter, which ApiKeys to fetch.
     */
    where?: ApiKeyWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ApiKeys to fetch.
     */
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing ApiKeys.
     */
    cursor?: ApiKeyWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ApiKeys from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ApiKeys.
     */
    skip?: number;
    distinct?: ApiKeyScalarFieldEnum | ApiKeyScalarFieldEnum[];
  };

  /**
   * ApiKey create
   */
  export type ApiKeyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the ApiKey
       */
      select?: ApiKeySelect<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: ApiKeyInclude<ExtArgs> | null;
      /**
       * The data needed to create a ApiKey.
       */
      data: XOR<ApiKeyCreateInput, ApiKeyUncheckedCreateInput>;
    };

  /**
   * ApiKey createMany
   */
  export type ApiKeyCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many ApiKeys.
     */
    data: ApiKeyCreateManyInput | ApiKeyCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * ApiKey createManyAndReturn
   */
  export type ApiKeyCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * The data used to create many ApiKeys.
     */
    data: ApiKeyCreateManyInput | ApiKeyCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * ApiKey update
   */
  export type ApiKeyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the ApiKey
       */
      select?: ApiKeySelect<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: ApiKeyInclude<ExtArgs> | null;
      /**
       * The data needed to update a ApiKey.
       */
      data: XOR<ApiKeyUpdateInput, ApiKeyUncheckedUpdateInput>;
      /**
       * Choose, which ApiKey to update.
       */
      where: ApiKeyWhereUniqueInput;
    };

  /**
   * ApiKey updateMany
   */
  export type ApiKeyUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update ApiKeys.
     */
    data: XOR<ApiKeyUpdateManyMutationInput, ApiKeyUncheckedUpdateManyInput>;
    /**
     * Filter which ApiKeys to update
     */
    where?: ApiKeyWhereInput;
  };

  /**
   * ApiKey upsert
   */
  export type ApiKeyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the ApiKey
       */
      select?: ApiKeySelect<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: ApiKeyInclude<ExtArgs> | null;
      /**
       * The filter to search for the ApiKey to update in case it exists.
       */
      where: ApiKeyWhereUniqueInput;
      /**
       * In case the ApiKey found by the `where` argument doesn't exist, create a new ApiKey with this data.
       */
      create: XOR<ApiKeyCreateInput, ApiKeyUncheckedCreateInput>;
      /**
       * In case the ApiKey was found with the provided `where` argument, update it with this data.
       */
      update: XOR<ApiKeyUpdateInput, ApiKeyUncheckedUpdateInput>;
    };

  /**
   * ApiKey delete
   */
  export type ApiKeyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the ApiKey
       */
      select?: ApiKeySelect<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: ApiKeyInclude<ExtArgs> | null;
      /**
       * Filter which ApiKey to delete.
       */
      where: ApiKeyWhereUniqueInput;
    };

  /**
   * ApiKey deleteMany
   */
  export type ApiKeyDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which ApiKeys to delete
     */
    where?: ApiKeyWhereInput;
  };

  /**
   * ApiKey without action
   */
  export type ApiKeyDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null;
  };

  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null;
    _min: AuditLogMinAggregateOutputType | null;
    _max: AuditLogMaxAggregateOutputType | null;
  };

  export type AuditLogMinAggregateOutputType = {
    id: string | null;
    actorId: string | null;
    action: string | null;
    entityType: string | null;
    entityId: string | null;
    ipAddress: string | null;
    userAgent: string | null;
    createdAt: Date | null;
  };

  export type AuditLogMaxAggregateOutputType = {
    id: string | null;
    actorId: string | null;
    action: string | null;
    entityType: string | null;
    entityId: string | null;
    ipAddress: string | null;
    userAgent: string | null;
    createdAt: Date | null;
  };

  export type AuditLogCountAggregateOutputType = {
    id: number;
    actorId: number;
    action: number;
    entityType: number;
    entityId: number;
    metadata: number;
    ipAddress: number;
    userAgent: number;
    createdAt: number;
    _all: number;
  };

  export type AuditLogMinAggregateInputType = {
    id?: true;
    actorId?: true;
    action?: true;
    entityType?: true;
    entityId?: true;
    ipAddress?: true;
    userAgent?: true;
    createdAt?: true;
  };

  export type AuditLogMaxAggregateInputType = {
    id?: true;
    actorId?: true;
    action?: true;
    entityType?: true;
    entityId?: true;
    ipAddress?: true;
    userAgent?: true;
    createdAt?: true;
  };

  export type AuditLogCountAggregateInputType = {
    id?: true;
    actorId?: true;
    action?: true;
    entityType?: true;
    entityId?: true;
    metadata?: true;
    ipAddress?: true;
    userAgent?: true;
    createdAt?: true;
    _all?: true;
  };

  export type AuditLogAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AuditLogs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned AuditLogs
     **/
    _count?: true | AuditLogCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: AuditLogMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: AuditLogMaxAggregateInputType;
  };

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
    [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>;
  };

  export type AuditLogGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AuditLogWhereInput;
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[];
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum;
    having?: AuditLogScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: AuditLogCountAggregateInputType | true;
    _min?: AuditLogMinAggregateInputType;
    _max?: AuditLogMaxAggregateInputType;
  };

  export type AuditLogGroupByOutputType = {
    id: string;
    actorId: string | null;
    action: string;
    entityType: string;
    entityId: string | null;
    metadata: JsonValue | null;
    ipAddress: string | null;
    userAgent: string | null;
    createdAt: Date;
    _count: AuditLogCountAggregateOutputType | null;
    _min: AuditLogMinAggregateOutputType | null;
    _max: AuditLogMaxAggregateOutputType | null;
  };

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> & {
        [P in keyof T & keyof AuditLogGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
          : GetScalarType<T[P], AuditLogGroupByOutputType[P]>;
      }
    >
  >;

  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        actorId?: boolean;
        action?: boolean;
        entityType?: boolean;
        entityId?: boolean;
        metadata?: boolean;
        ipAddress?: boolean;
        userAgent?: boolean;
        createdAt?: boolean;
        actor?: boolean | AuditLog$actorArgs<ExtArgs>;
      },
      ExtArgs['result']['auditLog']
    >;

  export type AuditLogSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      actorId?: boolean;
      action?: boolean;
      entityType?: boolean;
      entityId?: boolean;
      metadata?: boolean;
      ipAddress?: boolean;
      userAgent?: boolean;
      createdAt?: boolean;
      actor?: boolean | AuditLog$actorArgs<ExtArgs>;
    },
    ExtArgs['result']['auditLog']
  >;

  export type AuditLogSelectScalar = {
    id?: boolean;
    actorId?: boolean;
    action?: boolean;
    entityType?: boolean;
    entityId?: boolean;
    metadata?: boolean;
    ipAddress?: boolean;
    userAgent?: boolean;
    createdAt?: boolean;
  };

  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      actor?: boolean | AuditLog$actorArgs<ExtArgs>;
    };
  export type AuditLogIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    actor?: boolean | AuditLog$actorArgs<ExtArgs>;
  };

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      name: 'AuditLog';
      objects: {
        actor: Prisma.$UserPayload<ExtArgs> | null;
      };
      scalars: $Extensions.GetPayloadResult<
        {
          id: string;
          actorId: string | null;
          action: string;
          entityType: string;
          entityId: string | null;
          metadata: Prisma.JsonValue | null;
          ipAddress: string | null;
          userAgent: string | null;
          createdAt: Date;
        },
        ExtArgs['result']['auditLog']
      >;
      composites: {};
    };

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> =
    $Result.GetResult<Prisma.$AuditLogPayload, S>;

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    AuditLogFindManyArgs,
    'select' | 'include' | 'distinct'
  > & {
    select?: AuditLogCountAggregateInputType | true;
  };

  export interface AuditLogDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'];
      meta: { name: 'AuditLog' };
    };
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(
      args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>
    ): Prisma__AuditLogClient<
      $Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, 'findUnique'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(
      args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AuditLogClient<
      $Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, 'findUniqueOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(
      args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>
    ): Prisma__AuditLogClient<
      $Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, 'findFirst'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AuditLogClient<
      $Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, 'findFirstOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     *
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     *
     */
    findMany<T extends AuditLogFindManyArgs>(
      args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, 'findMany'>>;

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     *
     */
    create<T extends AuditLogCreateArgs>(
      args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>
    ): Prisma__AuditLogClient<
      $Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, 'create'>,
      never,
      ExtArgs
    >;

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends AuditLogCreateManyArgs>(
      args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(
      args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, 'createManyAndReturn'>
    >;

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     *
     */
    delete<T extends AuditLogDeleteArgs>(
      args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>
    ): Prisma__AuditLogClient<
      $Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, 'delete'>,
      never,
      ExtArgs
    >;

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends AuditLogUpdateArgs>(
      args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>
    ): Prisma__AuditLogClient<
      $Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, 'update'>,
      never,
      ExtArgs
    >;

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(
      args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends AuditLogUpdateManyArgs>(
      args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(
      args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>
    ): Prisma__AuditLogClient<
      $Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, 'upsert'>,
      never,
      ExtArgs
    >;

    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
     **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends AuditLogAggregateArgs>(
      args: Subset<T, AuditLogAggregateArgs>
    ): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>;

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the AuditLog model
     */
    readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    actor<T extends AuditLog$actorArgs<ExtArgs> = {}>(
      args?: Subset<T, AuditLog$actorArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null,
      null,
      ExtArgs
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the AuditLog model
   */
  interface AuditLogFieldRefs {
    readonly id: FieldRef<'AuditLog', 'String'>;
    readonly actorId: FieldRef<'AuditLog', 'String'>;
    readonly action: FieldRef<'AuditLog', 'String'>;
    readonly entityType: FieldRef<'AuditLog', 'String'>;
    readonly entityId: FieldRef<'AuditLog', 'String'>;
    readonly metadata: FieldRef<'AuditLog', 'Json'>;
    readonly ipAddress: FieldRef<'AuditLog', 'String'>;
    readonly userAgent: FieldRef<'AuditLog', 'String'>;
    readonly createdAt: FieldRef<'AuditLog', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput;
  };

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput;
  };

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AuditLogs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[];
  };

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AuditLogs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[];
  };

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AuditLogs.
     */
    skip?: number;
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[];
  };

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>;
  };

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>;
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput;
  };

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>;
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput;
  };

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput;
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>;
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>;
  };

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput;
  };

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput;
  };

  /**
   * AuditLog.actor
   */
  export type AuditLog$actorArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    where?: UserWhereInput;
  };

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
  };

  /**
   * Model Hackathon
   */

  export type AggregateHackathon = {
    _count: HackathonCountAggregateOutputType | null;
    _avg: HackathonAvgAggregateOutputType | null;
    _sum: HackathonSumAggregateOutputType | null;
    _min: HackathonMinAggregateOutputType | null;
    _max: HackathonMaxAggregateOutputType | null;
  };

  export type HackathonAvgAggregateOutputType = {
    prizePool: Decimal | null;
    maxTeamSize: number | null;
  };

  export type HackathonSumAggregateOutputType = {
    prizePool: Decimal | null;
    maxTeamSize: number | null;
  };

  export type HackathonMinAggregateOutputType = {
    id: string | null;
    slug: string | null;
    title: string | null;
    description: string | null;
    coverImage: string | null;
    status: $Enums.HackathonStatus | null;
    location: $Enums.HackathonLocation | null;
    registrationOpensAt: Date | null;
    registrationClosesAt: Date | null;
    startsAt: Date | null;
    endsAt: Date | null;
    judgingEndsAt: Date | null;
    prizePool: Decimal | null;
    maxTeamSize: number | null;
    allowSoloTeams: boolean | null;
    rules: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type HackathonMaxAggregateOutputType = {
    id: string | null;
    slug: string | null;
    title: string | null;
    description: string | null;
    coverImage: string | null;
    status: $Enums.HackathonStatus | null;
    location: $Enums.HackathonLocation | null;
    registrationOpensAt: Date | null;
    registrationClosesAt: Date | null;
    startsAt: Date | null;
    endsAt: Date | null;
    judgingEndsAt: Date | null;
    prizePool: Decimal | null;
    maxTeamSize: number | null;
    allowSoloTeams: boolean | null;
    rules: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type HackathonCountAggregateOutputType = {
    id: number;
    slug: number;
    title: number;
    description: number;
    coverImage: number;
    status: number;
    location: number;
    registrationOpensAt: number;
    registrationClosesAt: number;
    startsAt: number;
    endsAt: number;
    judgingEndsAt: number;
    prizePool: number;
    maxTeamSize: number;
    allowSoloTeams: number;
    rules: number;
    schedule: number;
    metadata: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type HackathonAvgAggregateInputType = {
    prizePool?: true;
    maxTeamSize?: true;
  };

  export type HackathonSumAggregateInputType = {
    prizePool?: true;
    maxTeamSize?: true;
  };

  export type HackathonMinAggregateInputType = {
    id?: true;
    slug?: true;
    title?: true;
    description?: true;
    coverImage?: true;
    status?: true;
    location?: true;
    registrationOpensAt?: true;
    registrationClosesAt?: true;
    startsAt?: true;
    endsAt?: true;
    judgingEndsAt?: true;
    prizePool?: true;
    maxTeamSize?: true;
    allowSoloTeams?: true;
    rules?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type HackathonMaxAggregateInputType = {
    id?: true;
    slug?: true;
    title?: true;
    description?: true;
    coverImage?: true;
    status?: true;
    location?: true;
    registrationOpensAt?: true;
    registrationClosesAt?: true;
    startsAt?: true;
    endsAt?: true;
    judgingEndsAt?: true;
    prizePool?: true;
    maxTeamSize?: true;
    allowSoloTeams?: true;
    rules?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type HackathonCountAggregateInputType = {
    id?: true;
    slug?: true;
    title?: true;
    description?: true;
    coverImage?: true;
    status?: true;
    location?: true;
    registrationOpensAt?: true;
    registrationClosesAt?: true;
    startsAt?: true;
    endsAt?: true;
    judgingEndsAt?: true;
    prizePool?: true;
    maxTeamSize?: true;
    allowSoloTeams?: true;
    rules?: true;
    schedule?: true;
    metadata?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type HackathonAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Hackathon to aggregate.
     */
    where?: HackathonWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Hackathons to fetch.
     */
    orderBy?: HackathonOrderByWithRelationInput | HackathonOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: HackathonWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Hackathons from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Hackathons.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Hackathons
     **/
    _count?: true | HackathonCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: HackathonAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: HackathonSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: HackathonMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: HackathonMaxAggregateInputType;
  };

  export type GetHackathonAggregateType<T extends HackathonAggregateArgs> = {
    [P in keyof T & keyof AggregateHackathon]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHackathon[P]>
      : GetScalarType<T[P], AggregateHackathon[P]>;
  };

  export type HackathonGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: HackathonWhereInput;
    orderBy?: HackathonOrderByWithAggregationInput | HackathonOrderByWithAggregationInput[];
    by: HackathonScalarFieldEnum[] | HackathonScalarFieldEnum;
    having?: HackathonScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: HackathonCountAggregateInputType | true;
    _avg?: HackathonAvgAggregateInputType;
    _sum?: HackathonSumAggregateInputType;
    _min?: HackathonMinAggregateInputType;
    _max?: HackathonMaxAggregateInputType;
  };

  export type HackathonGroupByOutputType = {
    id: string;
    slug: string;
    title: string;
    description: string;
    coverImage: string | null;
    status: $Enums.HackathonStatus;
    location: $Enums.HackathonLocation;
    registrationOpensAt: Date | null;
    registrationClosesAt: Date | null;
    startsAt: Date;
    endsAt: Date;
    judgingEndsAt: Date | null;
    prizePool: Decimal | null;
    maxTeamSize: number;
    allowSoloTeams: boolean;
    rules: string | null;
    schedule: JsonValue | null;
    metadata: JsonValue | null;
    createdAt: Date;
    updatedAt: Date;
    _count: HackathonCountAggregateOutputType | null;
    _avg: HackathonAvgAggregateOutputType | null;
    _sum: HackathonSumAggregateOutputType | null;
    _min: HackathonMinAggregateOutputType | null;
    _max: HackathonMaxAggregateOutputType | null;
  };

  type GetHackathonGroupByPayload<T extends HackathonGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HackathonGroupByOutputType, T['by']> & {
        [P in keyof T & keyof HackathonGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], HackathonGroupByOutputType[P]>
          : GetScalarType<T[P], HackathonGroupByOutputType[P]>;
      }
    >
  >;

  export type HackathonSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        slug?: boolean;
        title?: boolean;
        description?: boolean;
        coverImage?: boolean;
        status?: boolean;
        location?: boolean;
        registrationOpensAt?: boolean;
        registrationClosesAt?: boolean;
        startsAt?: boolean;
        endsAt?: boolean;
        judgingEndsAt?: boolean;
        prizePool?: boolean;
        maxTeamSize?: boolean;
        allowSoloTeams?: boolean;
        rules?: boolean;
        schedule?: boolean;
        metadata?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        tracks?: boolean | Hackathon$tracksArgs<ExtArgs>;
        teams?: boolean | Hackathon$teamsArgs<ExtArgs>;
        mentors?: boolean | Hackathon$mentorsArgs<ExtArgs>;
        judges?: boolean | Hackathon$judgesArgs<ExtArgs>;
        criteria?: boolean | Hackathon$criteriaArgs<ExtArgs>;
        submissions?: boolean | Hackathon$submissionsArgs<ExtArgs>;
        announcements?: boolean | Hackathon$announcementsArgs<ExtArgs>;
        _count?: boolean | HackathonCountOutputTypeDefaultArgs<ExtArgs>;
      },
      ExtArgs['result']['hackathon']
    >;

  export type HackathonSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      slug?: boolean;
      title?: boolean;
      description?: boolean;
      coverImage?: boolean;
      status?: boolean;
      location?: boolean;
      registrationOpensAt?: boolean;
      registrationClosesAt?: boolean;
      startsAt?: boolean;
      endsAt?: boolean;
      judgingEndsAt?: boolean;
      prizePool?: boolean;
      maxTeamSize?: boolean;
      allowSoloTeams?: boolean;
      rules?: boolean;
      schedule?: boolean;
      metadata?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
    },
    ExtArgs['result']['hackathon']
  >;

  export type HackathonSelectScalar = {
    id?: boolean;
    slug?: boolean;
    title?: boolean;
    description?: boolean;
    coverImage?: boolean;
    status?: boolean;
    location?: boolean;
    registrationOpensAt?: boolean;
    registrationClosesAt?: boolean;
    startsAt?: boolean;
    endsAt?: boolean;
    judgingEndsAt?: boolean;
    prizePool?: boolean;
    maxTeamSize?: boolean;
    allowSoloTeams?: boolean;
    rules?: boolean;
    schedule?: boolean;
    metadata?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type HackathonInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      tracks?: boolean | Hackathon$tracksArgs<ExtArgs>;
      teams?: boolean | Hackathon$teamsArgs<ExtArgs>;
      mentors?: boolean | Hackathon$mentorsArgs<ExtArgs>;
      judges?: boolean | Hackathon$judgesArgs<ExtArgs>;
      criteria?: boolean | Hackathon$criteriaArgs<ExtArgs>;
      submissions?: boolean | Hackathon$submissionsArgs<ExtArgs>;
      announcements?: boolean | Hackathon$announcementsArgs<ExtArgs>;
      _count?: boolean | HackathonCountOutputTypeDefaultArgs<ExtArgs>;
    };
  export type HackathonIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};

  export type $HackathonPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'Hackathon';
    objects: {
      tracks: Prisma.$TrackPayload<ExtArgs>[];
      teams: Prisma.$TeamPayload<ExtArgs>[];
      mentors: Prisma.$MentorPayload<ExtArgs>[];
      judges: Prisma.$JudgePayload<ExtArgs>[];
      criteria: Prisma.$CriteriaPayload<ExtArgs>[];
      submissions: Prisma.$SubmissionPayload<ExtArgs>[];
      announcements: Prisma.$AnnouncementPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        slug: string;
        title: string;
        description: string;
        coverImage: string | null;
        status: $Enums.HackathonStatus;
        location: $Enums.HackathonLocation;
        registrationOpensAt: Date | null;
        registrationClosesAt: Date | null;
        startsAt: Date;
        endsAt: Date;
        judgingEndsAt: Date | null;
        prizePool: Prisma.Decimal | null;
        maxTeamSize: number;
        allowSoloTeams: boolean;
        rules: string | null;
        schedule: Prisma.JsonValue | null;
        metadata: Prisma.JsonValue | null;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs['result']['hackathon']
    >;
    composites: {};
  };

  type HackathonGetPayload<S extends boolean | null | undefined | HackathonDefaultArgs> =
    $Result.GetResult<Prisma.$HackathonPayload, S>;

  type HackathonCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<HackathonFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HackathonCountAggregateInputType | true;
    };

  export interface HackathonDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Hackathon'];
      meta: { name: 'Hackathon' };
    };
    /**
     * Find zero or one Hackathon that matches the filter.
     * @param {HackathonFindUniqueArgs} args - Arguments to find a Hackathon
     * @example
     * // Get one Hackathon
     * const hackathon = await prisma.hackathon.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HackathonFindUniqueArgs>(
      args: SelectSubset<T, HackathonFindUniqueArgs<ExtArgs>>
    ): Prisma__HackathonClient<
      $Result.GetResult<Prisma.$HackathonPayload<ExtArgs>, T, 'findUnique'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find one Hackathon that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HackathonFindUniqueOrThrowArgs} args - Arguments to find a Hackathon
     * @example
     * // Get one Hackathon
     * const hackathon = await prisma.hackathon.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HackathonFindUniqueOrThrowArgs>(
      args: SelectSubset<T, HackathonFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__HackathonClient<
      $Result.GetResult<Prisma.$HackathonPayload<ExtArgs>, T, 'findUniqueOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find the first Hackathon that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HackathonFindFirstArgs} args - Arguments to find a Hackathon
     * @example
     * // Get one Hackathon
     * const hackathon = await prisma.hackathon.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HackathonFindFirstArgs>(
      args?: SelectSubset<T, HackathonFindFirstArgs<ExtArgs>>
    ): Prisma__HackathonClient<
      $Result.GetResult<Prisma.$HackathonPayload<ExtArgs>, T, 'findFirst'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find the first Hackathon that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HackathonFindFirstOrThrowArgs} args - Arguments to find a Hackathon
     * @example
     * // Get one Hackathon
     * const hackathon = await prisma.hackathon.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HackathonFindFirstOrThrowArgs>(
      args?: SelectSubset<T, HackathonFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__HackathonClient<
      $Result.GetResult<Prisma.$HackathonPayload<ExtArgs>, T, 'findFirstOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more Hackathons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HackathonFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Hackathons
     * const hackathons = await prisma.hackathon.findMany()
     *
     * // Get first 10 Hackathons
     * const hackathons = await prisma.hackathon.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const hackathonWithIdOnly = await prisma.hackathon.findMany({ select: { id: true } })
     *
     */
    findMany<T extends HackathonFindManyArgs>(
      args?: SelectSubset<T, HackathonFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HackathonPayload<ExtArgs>, T, 'findMany'>>;

    /**
     * Create a Hackathon.
     * @param {HackathonCreateArgs} args - Arguments to create a Hackathon.
     * @example
     * // Create one Hackathon
     * const Hackathon = await prisma.hackathon.create({
     *   data: {
     *     // ... data to create a Hackathon
     *   }
     * })
     *
     */
    create<T extends HackathonCreateArgs>(
      args: SelectSubset<T, HackathonCreateArgs<ExtArgs>>
    ): Prisma__HackathonClient<
      $Result.GetResult<Prisma.$HackathonPayload<ExtArgs>, T, 'create'>,
      never,
      ExtArgs
    >;

    /**
     * Create many Hackathons.
     * @param {HackathonCreateManyArgs} args - Arguments to create many Hackathons.
     * @example
     * // Create many Hackathons
     * const hackathon = await prisma.hackathon.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends HackathonCreateManyArgs>(
      args?: SelectSubset<T, HackathonCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Hackathons and returns the data saved in the database.
     * @param {HackathonCreateManyAndReturnArgs} args - Arguments to create many Hackathons.
     * @example
     * // Create many Hackathons
     * const hackathon = await prisma.hackathon.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Hackathons and only return the `id`
     * const hackathonWithIdOnly = await prisma.hackathon.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends HackathonCreateManyAndReturnArgs>(
      args?: SelectSubset<T, HackathonCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$HackathonPayload<ExtArgs>, T, 'createManyAndReturn'>
    >;

    /**
     * Delete a Hackathon.
     * @param {HackathonDeleteArgs} args - Arguments to delete one Hackathon.
     * @example
     * // Delete one Hackathon
     * const Hackathon = await prisma.hackathon.delete({
     *   where: {
     *     // ... filter to delete one Hackathon
     *   }
     * })
     *
     */
    delete<T extends HackathonDeleteArgs>(
      args: SelectSubset<T, HackathonDeleteArgs<ExtArgs>>
    ): Prisma__HackathonClient<
      $Result.GetResult<Prisma.$HackathonPayload<ExtArgs>, T, 'delete'>,
      never,
      ExtArgs
    >;

    /**
     * Update one Hackathon.
     * @param {HackathonUpdateArgs} args - Arguments to update one Hackathon.
     * @example
     * // Update one Hackathon
     * const hackathon = await prisma.hackathon.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends HackathonUpdateArgs>(
      args: SelectSubset<T, HackathonUpdateArgs<ExtArgs>>
    ): Prisma__HackathonClient<
      $Result.GetResult<Prisma.$HackathonPayload<ExtArgs>, T, 'update'>,
      never,
      ExtArgs
    >;

    /**
     * Delete zero or more Hackathons.
     * @param {HackathonDeleteManyArgs} args - Arguments to filter Hackathons to delete.
     * @example
     * // Delete a few Hackathons
     * const { count } = await prisma.hackathon.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends HackathonDeleteManyArgs>(
      args?: SelectSubset<T, HackathonDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Hackathons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HackathonUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Hackathons
     * const hackathon = await prisma.hackathon.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends HackathonUpdateManyArgs>(
      args: SelectSubset<T, HackathonUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Hackathon.
     * @param {HackathonUpsertArgs} args - Arguments to update or create a Hackathon.
     * @example
     * // Update or create a Hackathon
     * const hackathon = await prisma.hackathon.upsert({
     *   create: {
     *     // ... data to create a Hackathon
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Hackathon we want to update
     *   }
     * })
     */
    upsert<T extends HackathonUpsertArgs>(
      args: SelectSubset<T, HackathonUpsertArgs<ExtArgs>>
    ): Prisma__HackathonClient<
      $Result.GetResult<Prisma.$HackathonPayload<ExtArgs>, T, 'upsert'>,
      never,
      ExtArgs
    >;

    /**
     * Count the number of Hackathons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HackathonCountArgs} args - Arguments to filter Hackathons to count.
     * @example
     * // Count the number of Hackathons
     * const count = await prisma.hackathon.count({
     *   where: {
     *     // ... the filter for the Hackathons we want to count
     *   }
     * })
     **/
    count<T extends HackathonCountArgs>(
      args?: Subset<T, HackathonCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HackathonCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Hackathon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HackathonAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends HackathonAggregateArgs>(
      args: Subset<T, HackathonAggregateArgs>
    ): Prisma.PrismaPromise<GetHackathonAggregateType<T>>;

    /**
     * Group by Hackathon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HackathonGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends HackathonGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HackathonGroupByArgs['orderBy'] }
        : { orderBy?: HackathonGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, HackathonGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetHackathonGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Hackathon model
     */
    readonly fields: HackathonFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Hackathon.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HackathonClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    tracks<T extends Hackathon$tracksArgs<ExtArgs> = {}>(
      args?: Subset<T, Hackathon$tracksArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrackPayload<ExtArgs>, T, 'findMany'> | Null>;
    teams<T extends Hackathon$teamsArgs<ExtArgs> = {}>(
      args?: Subset<T, Hackathon$teamsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, 'findMany'> | Null>;
    mentors<T extends Hackathon$mentorsArgs<ExtArgs> = {}>(
      args?: Subset<T, Hackathon$mentorsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$MentorPayload<ExtArgs>, T, 'findMany'> | Null
    >;
    judges<T extends Hackathon$judgesArgs<ExtArgs> = {}>(
      args?: Subset<T, Hackathon$judgesArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JudgePayload<ExtArgs>, T, 'findMany'> | Null>;
    criteria<T extends Hackathon$criteriaArgs<ExtArgs> = {}>(
      args?: Subset<T, Hackathon$criteriaArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$CriteriaPayload<ExtArgs>, T, 'findMany'> | Null
    >;
    submissions<T extends Hackathon$submissionsArgs<ExtArgs> = {}>(
      args?: Subset<T, Hackathon$submissionsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$SubmissionPayload<ExtArgs>, T, 'findMany'> | Null
    >;
    announcements<T extends Hackathon$announcementsArgs<ExtArgs> = {}>(
      args?: Subset<T, Hackathon$announcementsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, 'findMany'> | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Hackathon model
   */
  interface HackathonFieldRefs {
    readonly id: FieldRef<'Hackathon', 'String'>;
    readonly slug: FieldRef<'Hackathon', 'String'>;
    readonly title: FieldRef<'Hackathon', 'String'>;
    readonly description: FieldRef<'Hackathon', 'String'>;
    readonly coverImage: FieldRef<'Hackathon', 'String'>;
    readonly status: FieldRef<'Hackathon', 'HackathonStatus'>;
    readonly location: FieldRef<'Hackathon', 'HackathonLocation'>;
    readonly registrationOpensAt: FieldRef<'Hackathon', 'DateTime'>;
    readonly registrationClosesAt: FieldRef<'Hackathon', 'DateTime'>;
    readonly startsAt: FieldRef<'Hackathon', 'DateTime'>;
    readonly endsAt: FieldRef<'Hackathon', 'DateTime'>;
    readonly judgingEndsAt: FieldRef<'Hackathon', 'DateTime'>;
    readonly prizePool: FieldRef<'Hackathon', 'Decimal'>;
    readonly maxTeamSize: FieldRef<'Hackathon', 'Int'>;
    readonly allowSoloTeams: FieldRef<'Hackathon', 'Boolean'>;
    readonly rules: FieldRef<'Hackathon', 'String'>;
    readonly schedule: FieldRef<'Hackathon', 'Json'>;
    readonly metadata: FieldRef<'Hackathon', 'Json'>;
    readonly createdAt: FieldRef<'Hackathon', 'DateTime'>;
    readonly updatedAt: FieldRef<'Hackathon', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * Hackathon findUnique
   */
  export type HackathonFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Hackathon
     */
    select?: HackathonSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HackathonInclude<ExtArgs> | null;
    /**
     * Filter, which Hackathon to fetch.
     */
    where: HackathonWhereUniqueInput;
  };

  /**
   * Hackathon findUniqueOrThrow
   */
  export type HackathonFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Hackathon
     */
    select?: HackathonSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HackathonInclude<ExtArgs> | null;
    /**
     * Filter, which Hackathon to fetch.
     */
    where: HackathonWhereUniqueInput;
  };

  /**
   * Hackathon findFirst
   */
  export type HackathonFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Hackathon
     */
    select?: HackathonSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HackathonInclude<ExtArgs> | null;
    /**
     * Filter, which Hackathon to fetch.
     */
    where?: HackathonWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Hackathons to fetch.
     */
    orderBy?: HackathonOrderByWithRelationInput | HackathonOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Hackathons.
     */
    cursor?: HackathonWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Hackathons from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Hackathons.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Hackathons.
     */
    distinct?: HackathonScalarFieldEnum | HackathonScalarFieldEnum[];
  };

  /**
   * Hackathon findFirstOrThrow
   */
  export type HackathonFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Hackathon
     */
    select?: HackathonSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HackathonInclude<ExtArgs> | null;
    /**
     * Filter, which Hackathon to fetch.
     */
    where?: HackathonWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Hackathons to fetch.
     */
    orderBy?: HackathonOrderByWithRelationInput | HackathonOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Hackathons.
     */
    cursor?: HackathonWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Hackathons from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Hackathons.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Hackathons.
     */
    distinct?: HackathonScalarFieldEnum | HackathonScalarFieldEnum[];
  };

  /**
   * Hackathon findMany
   */
  export type HackathonFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Hackathon
     */
    select?: HackathonSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HackathonInclude<ExtArgs> | null;
    /**
     * Filter, which Hackathons to fetch.
     */
    where?: HackathonWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Hackathons to fetch.
     */
    orderBy?: HackathonOrderByWithRelationInput | HackathonOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Hackathons.
     */
    cursor?: HackathonWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Hackathons from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Hackathons.
     */
    skip?: number;
    distinct?: HackathonScalarFieldEnum | HackathonScalarFieldEnum[];
  };

  /**
   * Hackathon create
   */
  export type HackathonCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Hackathon
     */
    select?: HackathonSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HackathonInclude<ExtArgs> | null;
    /**
     * The data needed to create a Hackathon.
     */
    data: XOR<HackathonCreateInput, HackathonUncheckedCreateInput>;
  };

  /**
   * Hackathon createMany
   */
  export type HackathonCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Hackathons.
     */
    data: HackathonCreateManyInput | HackathonCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Hackathon createManyAndReturn
   */
  export type HackathonCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Hackathon
     */
    select?: HackathonSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * The data used to create many Hackathons.
     */
    data: HackathonCreateManyInput | HackathonCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Hackathon update
   */
  export type HackathonUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Hackathon
     */
    select?: HackathonSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HackathonInclude<ExtArgs> | null;
    /**
     * The data needed to update a Hackathon.
     */
    data: XOR<HackathonUpdateInput, HackathonUncheckedUpdateInput>;
    /**
     * Choose, which Hackathon to update.
     */
    where: HackathonWhereUniqueInput;
  };

  /**
   * Hackathon updateMany
   */
  export type HackathonUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Hackathons.
     */
    data: XOR<HackathonUpdateManyMutationInput, HackathonUncheckedUpdateManyInput>;
    /**
     * Filter which Hackathons to update
     */
    where?: HackathonWhereInput;
  };

  /**
   * Hackathon upsert
   */
  export type HackathonUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Hackathon
     */
    select?: HackathonSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HackathonInclude<ExtArgs> | null;
    /**
     * The filter to search for the Hackathon to update in case it exists.
     */
    where: HackathonWhereUniqueInput;
    /**
     * In case the Hackathon found by the `where` argument doesn't exist, create a new Hackathon with this data.
     */
    create: XOR<HackathonCreateInput, HackathonUncheckedCreateInput>;
    /**
     * In case the Hackathon was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HackathonUpdateInput, HackathonUncheckedUpdateInput>;
  };

  /**
   * Hackathon delete
   */
  export type HackathonDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Hackathon
     */
    select?: HackathonSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HackathonInclude<ExtArgs> | null;
    /**
     * Filter which Hackathon to delete.
     */
    where: HackathonWhereUniqueInput;
  };

  /**
   * Hackathon deleteMany
   */
  export type HackathonDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Hackathons to delete
     */
    where?: HackathonWhereInput;
  };

  /**
   * Hackathon.tracks
   */
  export type Hackathon$tracksArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Track
     */
    select?: TrackSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrackInclude<ExtArgs> | null;
    where?: TrackWhereInput;
    orderBy?: TrackOrderByWithRelationInput | TrackOrderByWithRelationInput[];
    cursor?: TrackWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: TrackScalarFieldEnum | TrackScalarFieldEnum[];
  };

  /**
   * Hackathon.teams
   */
  export type Hackathon$teamsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null;
    where?: TeamWhereInput;
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[];
    cursor?: TeamWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[];
  };

  /**
   * Hackathon.mentors
   */
  export type Hackathon$mentorsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Mentor
     */
    select?: MentorSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorInclude<ExtArgs> | null;
    where?: MentorWhereInput;
    orderBy?: MentorOrderByWithRelationInput | MentorOrderByWithRelationInput[];
    cursor?: MentorWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: MentorScalarFieldEnum | MentorScalarFieldEnum[];
  };

  /**
   * Hackathon.judges
   */
  export type Hackathon$judgesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Judge
     */
    select?: JudgeSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JudgeInclude<ExtArgs> | null;
    where?: JudgeWhereInput;
    orderBy?: JudgeOrderByWithRelationInput | JudgeOrderByWithRelationInput[];
    cursor?: JudgeWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: JudgeScalarFieldEnum | JudgeScalarFieldEnum[];
  };

  /**
   * Hackathon.criteria
   */
  export type Hackathon$criteriaArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Criteria
     */
    select?: CriteriaSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CriteriaInclude<ExtArgs> | null;
    where?: CriteriaWhereInput;
    orderBy?: CriteriaOrderByWithRelationInput | CriteriaOrderByWithRelationInput[];
    cursor?: CriteriaWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: CriteriaScalarFieldEnum | CriteriaScalarFieldEnum[];
  };

  /**
   * Hackathon.submissions
   */
  export type Hackathon$submissionsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionInclude<ExtArgs> | null;
    where?: SubmissionWhereInput;
    orderBy?: SubmissionOrderByWithRelationInput | SubmissionOrderByWithRelationInput[];
    cursor?: SubmissionWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: SubmissionScalarFieldEnum | SubmissionScalarFieldEnum[];
  };

  /**
   * Hackathon.announcements
   */
  export type Hackathon$announcementsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null;
    where?: AnnouncementWhereInput;
    orderBy?: AnnouncementOrderByWithRelationInput | AnnouncementOrderByWithRelationInput[];
    cursor?: AnnouncementWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: AnnouncementScalarFieldEnum | AnnouncementScalarFieldEnum[];
  };

  /**
   * Hackathon without action
   */
  export type HackathonDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Hackathon
     */
    select?: HackathonSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HackathonInclude<ExtArgs> | null;
  };

  /**
   * Model Track
   */

  export type AggregateTrack = {
    _count: TrackCountAggregateOutputType | null;
    _avg: TrackAvgAggregateOutputType | null;
    _sum: TrackSumAggregateOutputType | null;
    _min: TrackMinAggregateOutputType | null;
    _max: TrackMaxAggregateOutputType | null;
  };

  export type TrackAvgAggregateOutputType = {
    order: number | null;
  };

  export type TrackSumAggregateOutputType = {
    order: number | null;
  };

  export type TrackMinAggregateOutputType = {
    id: string | null;
    hackathonId: string | null;
    title: string | null;
    description: string | null;
    order: number | null;
    createdAt: Date | null;
  };

  export type TrackMaxAggregateOutputType = {
    id: string | null;
    hackathonId: string | null;
    title: string | null;
    description: string | null;
    order: number | null;
    createdAt: Date | null;
  };

  export type TrackCountAggregateOutputType = {
    id: number;
    hackathonId: number;
    title: number;
    description: number;
    order: number;
    createdAt: number;
    _all: number;
  };

  export type TrackAvgAggregateInputType = {
    order?: true;
  };

  export type TrackSumAggregateInputType = {
    order?: true;
  };

  export type TrackMinAggregateInputType = {
    id?: true;
    hackathonId?: true;
    title?: true;
    description?: true;
    order?: true;
    createdAt?: true;
  };

  export type TrackMaxAggregateInputType = {
    id?: true;
    hackathonId?: true;
    title?: true;
    description?: true;
    order?: true;
    createdAt?: true;
  };

  export type TrackCountAggregateInputType = {
    id?: true;
    hackathonId?: true;
    title?: true;
    description?: true;
    order?: true;
    createdAt?: true;
    _all?: true;
  };

  export type TrackAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Track to aggregate.
     */
    where?: TrackWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Tracks to fetch.
     */
    orderBy?: TrackOrderByWithRelationInput | TrackOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: TrackWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Tracks from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Tracks.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Tracks
     **/
    _count?: true | TrackCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: TrackAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: TrackSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: TrackMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: TrackMaxAggregateInputType;
  };

  export type GetTrackAggregateType<T extends TrackAggregateArgs> = {
    [P in keyof T & keyof AggregateTrack]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrack[P]>
      : GetScalarType<T[P], AggregateTrack[P]>;
  };

  export type TrackGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      where?: TrackWhereInput;
      orderBy?: TrackOrderByWithAggregationInput | TrackOrderByWithAggregationInput[];
      by: TrackScalarFieldEnum[] | TrackScalarFieldEnum;
      having?: TrackScalarWhereWithAggregatesInput;
      take?: number;
      skip?: number;
      _count?: TrackCountAggregateInputType | true;
      _avg?: TrackAvgAggregateInputType;
      _sum?: TrackSumAggregateInputType;
      _min?: TrackMinAggregateInputType;
      _max?: TrackMaxAggregateInputType;
    };

  export type TrackGroupByOutputType = {
    id: string;
    hackathonId: string;
    title: string;
    description: string | null;
    order: number;
    createdAt: Date;
    _count: TrackCountAggregateOutputType | null;
    _avg: TrackAvgAggregateOutputType | null;
    _sum: TrackSumAggregateOutputType | null;
    _min: TrackMinAggregateOutputType | null;
    _max: TrackMaxAggregateOutputType | null;
  };

  type GetTrackGroupByPayload<T extends TrackGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrackGroupByOutputType, T['by']> & {
        [P in keyof T & keyof TrackGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], TrackGroupByOutputType[P]>
          : GetScalarType<T[P], TrackGroupByOutputType[P]>;
      }
    >
  >;

  export type TrackSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        hackathonId?: boolean;
        title?: boolean;
        description?: boolean;
        order?: boolean;
        createdAt?: boolean;
        hackathon?: boolean | HackathonDefaultArgs<ExtArgs>;
        submissions?: boolean | Track$submissionsArgs<ExtArgs>;
        _count?: boolean | TrackCountOutputTypeDefaultArgs<ExtArgs>;
      },
      ExtArgs['result']['track']
    >;

  export type TrackSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      hackathonId?: boolean;
      title?: boolean;
      description?: boolean;
      order?: boolean;
      createdAt?: boolean;
      hackathon?: boolean | HackathonDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['track']
  >;

  export type TrackSelectScalar = {
    id?: boolean;
    hackathonId?: boolean;
    title?: boolean;
    description?: boolean;
    order?: boolean;
    createdAt?: boolean;
  };

  export type TrackInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hackathon?: boolean | HackathonDefaultArgs<ExtArgs>;
    submissions?: boolean | Track$submissionsArgs<ExtArgs>;
    _count?: boolean | TrackCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type TrackIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    hackathon?: boolean | HackathonDefaultArgs<ExtArgs>;
  };

  export type $TrackPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: 'Track';
    objects: {
      hackathon: Prisma.$HackathonPayload<ExtArgs>;
      submissions: Prisma.$SubmissionPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        hackathonId: string;
        title: string;
        description: string | null;
        order: number;
        createdAt: Date;
      },
      ExtArgs['result']['track']
    >;
    composites: {};
  };

  type TrackGetPayload<S extends boolean | null | undefined | TrackDefaultArgs> = $Result.GetResult<
    Prisma.$TrackPayload,
    S
  >;

  type TrackCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    TrackFindManyArgs,
    'select' | 'include' | 'distinct'
  > & {
    select?: TrackCountAggregateInputType | true;
  };

  export interface TrackDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Track']; meta: { name: 'Track' } };
    /**
     * Find zero or one Track that matches the filter.
     * @param {TrackFindUniqueArgs} args - Arguments to find a Track
     * @example
     * // Get one Track
     * const track = await prisma.track.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TrackFindUniqueArgs>(
      args: SelectSubset<T, TrackFindUniqueArgs<ExtArgs>>
    ): Prisma__TrackClient<
      $Result.GetResult<Prisma.$TrackPayload<ExtArgs>, T, 'findUnique'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find one Track that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TrackFindUniqueOrThrowArgs} args - Arguments to find a Track
     * @example
     * // Get one Track
     * const track = await prisma.track.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TrackFindUniqueOrThrowArgs>(
      args: SelectSubset<T, TrackFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TrackClient<
      $Result.GetResult<Prisma.$TrackPayload<ExtArgs>, T, 'findUniqueOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find the first Track that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrackFindFirstArgs} args - Arguments to find a Track
     * @example
     * // Get one Track
     * const track = await prisma.track.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TrackFindFirstArgs>(
      args?: SelectSubset<T, TrackFindFirstArgs<ExtArgs>>
    ): Prisma__TrackClient<
      $Result.GetResult<Prisma.$TrackPayload<ExtArgs>, T, 'findFirst'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find the first Track that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrackFindFirstOrThrowArgs} args - Arguments to find a Track
     * @example
     * // Get one Track
     * const track = await prisma.track.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TrackFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TrackFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TrackClient<
      $Result.GetResult<Prisma.$TrackPayload<ExtArgs>, T, 'findFirstOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more Tracks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrackFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tracks
     * const tracks = await prisma.track.findMany()
     *
     * // Get first 10 Tracks
     * const tracks = await prisma.track.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const trackWithIdOnly = await prisma.track.findMany({ select: { id: true } })
     *
     */
    findMany<T extends TrackFindManyArgs>(
      args?: SelectSubset<T, TrackFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrackPayload<ExtArgs>, T, 'findMany'>>;

    /**
     * Create a Track.
     * @param {TrackCreateArgs} args - Arguments to create a Track.
     * @example
     * // Create one Track
     * const Track = await prisma.track.create({
     *   data: {
     *     // ... data to create a Track
     *   }
     * })
     *
     */
    create<T extends TrackCreateArgs>(
      args: SelectSubset<T, TrackCreateArgs<ExtArgs>>
    ): Prisma__TrackClient<
      $Result.GetResult<Prisma.$TrackPayload<ExtArgs>, T, 'create'>,
      never,
      ExtArgs
    >;

    /**
     * Create many Tracks.
     * @param {TrackCreateManyArgs} args - Arguments to create many Tracks.
     * @example
     * // Create many Tracks
     * const track = await prisma.track.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends TrackCreateManyArgs>(
      args?: SelectSubset<T, TrackCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Tracks and returns the data saved in the database.
     * @param {TrackCreateManyAndReturnArgs} args - Arguments to create many Tracks.
     * @example
     * // Create many Tracks
     * const track = await prisma.track.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Tracks and only return the `id`
     * const trackWithIdOnly = await prisma.track.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends TrackCreateManyAndReturnArgs>(
      args?: SelectSubset<T, TrackCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$TrackPayload<ExtArgs>, T, 'createManyAndReturn'>
    >;

    /**
     * Delete a Track.
     * @param {TrackDeleteArgs} args - Arguments to delete one Track.
     * @example
     * // Delete one Track
     * const Track = await prisma.track.delete({
     *   where: {
     *     // ... filter to delete one Track
     *   }
     * })
     *
     */
    delete<T extends TrackDeleteArgs>(
      args: SelectSubset<T, TrackDeleteArgs<ExtArgs>>
    ): Prisma__TrackClient<
      $Result.GetResult<Prisma.$TrackPayload<ExtArgs>, T, 'delete'>,
      never,
      ExtArgs
    >;

    /**
     * Update one Track.
     * @param {TrackUpdateArgs} args - Arguments to update one Track.
     * @example
     * // Update one Track
     * const track = await prisma.track.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends TrackUpdateArgs>(
      args: SelectSubset<T, TrackUpdateArgs<ExtArgs>>
    ): Prisma__TrackClient<
      $Result.GetResult<Prisma.$TrackPayload<ExtArgs>, T, 'update'>,
      never,
      ExtArgs
    >;

    /**
     * Delete zero or more Tracks.
     * @param {TrackDeleteManyArgs} args - Arguments to filter Tracks to delete.
     * @example
     * // Delete a few Tracks
     * const { count } = await prisma.track.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends TrackDeleteManyArgs>(
      args?: SelectSubset<T, TrackDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Tracks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrackUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tracks
     * const track = await prisma.track.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends TrackUpdateManyArgs>(
      args: SelectSubset<T, TrackUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Track.
     * @param {TrackUpsertArgs} args - Arguments to update or create a Track.
     * @example
     * // Update or create a Track
     * const track = await prisma.track.upsert({
     *   create: {
     *     // ... data to create a Track
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Track we want to update
     *   }
     * })
     */
    upsert<T extends TrackUpsertArgs>(
      args: SelectSubset<T, TrackUpsertArgs<ExtArgs>>
    ): Prisma__TrackClient<
      $Result.GetResult<Prisma.$TrackPayload<ExtArgs>, T, 'upsert'>,
      never,
      ExtArgs
    >;

    /**
     * Count the number of Tracks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrackCountArgs} args - Arguments to filter Tracks to count.
     * @example
     * // Count the number of Tracks
     * const count = await prisma.track.count({
     *   where: {
     *     // ... the filter for the Tracks we want to count
     *   }
     * })
     **/
    count<T extends TrackCountArgs>(
      args?: Subset<T, TrackCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrackCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Track.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrackAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends TrackAggregateArgs>(
      args: Subset<T, TrackAggregateArgs>
    ): Prisma.PrismaPromise<GetTrackAggregateType<T>>;

    /**
     * Group by Track.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrackGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends TrackGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrackGroupByArgs['orderBy'] }
        : { orderBy?: TrackGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, TrackGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetTrackGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Track model
     */
    readonly fields: TrackFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Track.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TrackClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    hackathon<T extends HackathonDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, HackathonDefaultArgs<ExtArgs>>
    ): Prisma__HackathonClient<
      $Result.GetResult<Prisma.$HackathonPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null,
      Null,
      ExtArgs
    >;
    submissions<T extends Track$submissionsArgs<ExtArgs> = {}>(
      args?: Subset<T, Track$submissionsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$SubmissionPayload<ExtArgs>, T, 'findMany'> | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Track model
   */
  interface TrackFieldRefs {
    readonly id: FieldRef<'Track', 'String'>;
    readonly hackathonId: FieldRef<'Track', 'String'>;
    readonly title: FieldRef<'Track', 'String'>;
    readonly description: FieldRef<'Track', 'String'>;
    readonly order: FieldRef<'Track', 'Int'>;
    readonly createdAt: FieldRef<'Track', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * Track findUnique
   */
  export type TrackFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Track
     */
    select?: TrackSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrackInclude<ExtArgs> | null;
    /**
     * Filter, which Track to fetch.
     */
    where: TrackWhereUniqueInput;
  };

  /**
   * Track findUniqueOrThrow
   */
  export type TrackFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Track
     */
    select?: TrackSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrackInclude<ExtArgs> | null;
    /**
     * Filter, which Track to fetch.
     */
    where: TrackWhereUniqueInput;
  };

  /**
   * Track findFirst
   */
  export type TrackFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Track
     */
    select?: TrackSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrackInclude<ExtArgs> | null;
    /**
     * Filter, which Track to fetch.
     */
    where?: TrackWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Tracks to fetch.
     */
    orderBy?: TrackOrderByWithRelationInput | TrackOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Tracks.
     */
    cursor?: TrackWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Tracks from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Tracks.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Tracks.
     */
    distinct?: TrackScalarFieldEnum | TrackScalarFieldEnum[];
  };

  /**
   * Track findFirstOrThrow
   */
  export type TrackFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Track
     */
    select?: TrackSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrackInclude<ExtArgs> | null;
    /**
     * Filter, which Track to fetch.
     */
    where?: TrackWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Tracks to fetch.
     */
    orderBy?: TrackOrderByWithRelationInput | TrackOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Tracks.
     */
    cursor?: TrackWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Tracks from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Tracks.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Tracks.
     */
    distinct?: TrackScalarFieldEnum | TrackScalarFieldEnum[];
  };

  /**
   * Track findMany
   */
  export type TrackFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Track
     */
    select?: TrackSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrackInclude<ExtArgs> | null;
    /**
     * Filter, which Tracks to fetch.
     */
    where?: TrackWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Tracks to fetch.
     */
    orderBy?: TrackOrderByWithRelationInput | TrackOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Tracks.
     */
    cursor?: TrackWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Tracks from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Tracks.
     */
    skip?: number;
    distinct?: TrackScalarFieldEnum | TrackScalarFieldEnum[];
  };

  /**
   * Track create
   */
  export type TrackCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the Track
       */
      select?: TrackSelect<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: TrackInclude<ExtArgs> | null;
      /**
       * The data needed to create a Track.
       */
      data: XOR<TrackCreateInput, TrackUncheckedCreateInput>;
    };

  /**
   * Track createMany
   */
  export type TrackCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Tracks.
     */
    data: TrackCreateManyInput | TrackCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Track createManyAndReturn
   */
  export type TrackCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Track
     */
    select?: TrackSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * The data used to create many Tracks.
     */
    data: TrackCreateManyInput | TrackCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrackIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Track update
   */
  export type TrackUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the Track
       */
      select?: TrackSelect<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: TrackInclude<ExtArgs> | null;
      /**
       * The data needed to update a Track.
       */
      data: XOR<TrackUpdateInput, TrackUncheckedUpdateInput>;
      /**
       * Choose, which Track to update.
       */
      where: TrackWhereUniqueInput;
    };

  /**
   * Track updateMany
   */
  export type TrackUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Tracks.
     */
    data: XOR<TrackUpdateManyMutationInput, TrackUncheckedUpdateManyInput>;
    /**
     * Filter which Tracks to update
     */
    where?: TrackWhereInput;
  };

  /**
   * Track upsert
   */
  export type TrackUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the Track
       */
      select?: TrackSelect<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: TrackInclude<ExtArgs> | null;
      /**
       * The filter to search for the Track to update in case it exists.
       */
      where: TrackWhereUniqueInput;
      /**
       * In case the Track found by the `where` argument doesn't exist, create a new Track with this data.
       */
      create: XOR<TrackCreateInput, TrackUncheckedCreateInput>;
      /**
       * In case the Track was found with the provided `where` argument, update it with this data.
       */
      update: XOR<TrackUpdateInput, TrackUncheckedUpdateInput>;
    };

  /**
   * Track delete
   */
  export type TrackDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the Track
       */
      select?: TrackSelect<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: TrackInclude<ExtArgs> | null;
      /**
       * Filter which Track to delete.
       */
      where: TrackWhereUniqueInput;
    };

  /**
   * Track deleteMany
   */
  export type TrackDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Tracks to delete
     */
    where?: TrackWhereInput;
  };

  /**
   * Track.submissions
   */
  export type Track$submissionsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionInclude<ExtArgs> | null;
    where?: SubmissionWhereInput;
    orderBy?: SubmissionOrderByWithRelationInput | SubmissionOrderByWithRelationInput[];
    cursor?: SubmissionWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: SubmissionScalarFieldEnum | SubmissionScalarFieldEnum[];
  };

  /**
   * Track without action
   */
  export type TrackDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the Track
       */
      select?: TrackSelect<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: TrackInclude<ExtArgs> | null;
    };

  /**
   * Model Team
   */

  export type AggregateTeam = {
    _count: TeamCountAggregateOutputType | null;
    _min: TeamMinAggregateOutputType | null;
    _max: TeamMaxAggregateOutputType | null;
  };

  export type TeamMinAggregateOutputType = {
    id: string | null;
    hackathonId: string | null;
    name: string | null;
    bio: string | null;
    logoUrl: string | null;
    repoUrl: string | null;
    demoUrl: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type TeamMaxAggregateOutputType = {
    id: string | null;
    hackathonId: string | null;
    name: string | null;
    bio: string | null;
    logoUrl: string | null;
    repoUrl: string | null;
    demoUrl: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type TeamCountAggregateOutputType = {
    id: number;
    hackathonId: number;
    name: number;
    bio: number;
    logoUrl: number;
    repoUrl: number;
    demoUrl: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type TeamMinAggregateInputType = {
    id?: true;
    hackathonId?: true;
    name?: true;
    bio?: true;
    logoUrl?: true;
    repoUrl?: true;
    demoUrl?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type TeamMaxAggregateInputType = {
    id?: true;
    hackathonId?: true;
    name?: true;
    bio?: true;
    logoUrl?: true;
    repoUrl?: true;
    demoUrl?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type TeamCountAggregateInputType = {
    id?: true;
    hackathonId?: true;
    name?: true;
    bio?: true;
    logoUrl?: true;
    repoUrl?: true;
    demoUrl?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type TeamAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Team to aggregate.
     */
    where?: TeamWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: TeamWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Teams.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Teams
     **/
    _count?: true | TeamCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: TeamMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: TeamMaxAggregateInputType;
  };

  export type GetTeamAggregateType<T extends TeamAggregateArgs> = {
    [P in keyof T & keyof AggregateTeam]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeam[P]>
      : GetScalarType<T[P], AggregateTeam[P]>;
  };

  export type TeamGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      where?: TeamWhereInput;
      orderBy?: TeamOrderByWithAggregationInput | TeamOrderByWithAggregationInput[];
      by: TeamScalarFieldEnum[] | TeamScalarFieldEnum;
      having?: TeamScalarWhereWithAggregatesInput;
      take?: number;
      skip?: number;
      _count?: TeamCountAggregateInputType | true;
      _min?: TeamMinAggregateInputType;
      _max?: TeamMaxAggregateInputType;
    };

  export type TeamGroupByOutputType = {
    id: string;
    hackathonId: string;
    name: string;
    bio: string | null;
    logoUrl: string | null;
    repoUrl: string | null;
    demoUrl: string | null;
    createdAt: Date;
    updatedAt: Date;
    _count: TeamCountAggregateOutputType | null;
    _min: TeamMinAggregateOutputType | null;
    _max: TeamMaxAggregateOutputType | null;
  };

  type GetTeamGroupByPayload<T extends TeamGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeamGroupByOutputType, T['by']> & {
        [P in keyof T & keyof TeamGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], TeamGroupByOutputType[P]>
          : GetScalarType<T[P], TeamGroupByOutputType[P]>;
      }
    >
  >;

  export type TeamSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        hackathonId?: boolean;
        name?: boolean;
        bio?: boolean;
        logoUrl?: boolean;
        repoUrl?: boolean;
        demoUrl?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        hackathon?: boolean | HackathonDefaultArgs<ExtArgs>;
        members?: boolean | Team$membersArgs<ExtArgs>;
        submissions?: boolean | Team$submissionsArgs<ExtArgs>;
        challengeSubmissions?: boolean | Team$challengeSubmissionsArgs<ExtArgs>;
        _count?: boolean | TeamCountOutputTypeDefaultArgs<ExtArgs>;
      },
      ExtArgs['result']['team']
    >;

  export type TeamSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      hackathonId?: boolean;
      name?: boolean;
      bio?: boolean;
      logoUrl?: boolean;
      repoUrl?: boolean;
      demoUrl?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      hackathon?: boolean | HackathonDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['team']
  >;

  export type TeamSelectScalar = {
    id?: boolean;
    hackathonId?: boolean;
    name?: boolean;
    bio?: boolean;
    logoUrl?: boolean;
    repoUrl?: boolean;
    demoUrl?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type TeamInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hackathon?: boolean | HackathonDefaultArgs<ExtArgs>;
    members?: boolean | Team$membersArgs<ExtArgs>;
    submissions?: boolean | Team$submissionsArgs<ExtArgs>;
    challengeSubmissions?: boolean | Team$challengeSubmissionsArgs<ExtArgs>;
    _count?: boolean | TeamCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type TeamIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    hackathon?: boolean | HackathonDefaultArgs<ExtArgs>;
  };

  export type $TeamPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: 'Team';
    objects: {
      hackathon: Prisma.$HackathonPayload<ExtArgs>;
      members: Prisma.$TeamMemberPayload<ExtArgs>[];
      submissions: Prisma.$SubmissionPayload<ExtArgs>[];
      challengeSubmissions: Prisma.$ChallengeSubmissionPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        hackathonId: string;
        name: string;
        bio: string | null;
        logoUrl: string | null;
        repoUrl: string | null;
        demoUrl: string | null;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs['result']['team']
    >;
    composites: {};
  };

  type TeamGetPayload<S extends boolean | null | undefined | TeamDefaultArgs> = $Result.GetResult<
    Prisma.$TeamPayload,
    S
  >;

  type TeamCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    TeamFindManyArgs,
    'select' | 'include' | 'distinct'
  > & {
    select?: TeamCountAggregateInputType | true;
  };

  export interface TeamDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Team']; meta: { name: 'Team' } };
    /**
     * Find zero or one Team that matches the filter.
     * @param {TeamFindUniqueArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeamFindUniqueArgs>(
      args: SelectSubset<T, TeamFindUniqueArgs<ExtArgs>>
    ): Prisma__TeamClient<
      $Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, 'findUnique'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find one Team that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TeamFindUniqueOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeamFindUniqueOrThrowArgs>(
      args: SelectSubset<T, TeamFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TeamClient<
      $Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, 'findUniqueOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find the first Team that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindFirstArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeamFindFirstArgs>(
      args?: SelectSubset<T, TeamFindFirstArgs<ExtArgs>>
    ): Prisma__TeamClient<
      $Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, 'findFirst'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find the first Team that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindFirstOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeamFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TeamFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TeamClient<
      $Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, 'findFirstOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more Teams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Teams
     * const teams = await prisma.team.findMany()
     *
     * // Get first 10 Teams
     * const teams = await prisma.team.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const teamWithIdOnly = await prisma.team.findMany({ select: { id: true } })
     *
     */
    findMany<T extends TeamFindManyArgs>(
      args?: SelectSubset<T, TeamFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, 'findMany'>>;

    /**
     * Create a Team.
     * @param {TeamCreateArgs} args - Arguments to create a Team.
     * @example
     * // Create one Team
     * const Team = await prisma.team.create({
     *   data: {
     *     // ... data to create a Team
     *   }
     * })
     *
     */
    create<T extends TeamCreateArgs>(
      args: SelectSubset<T, TeamCreateArgs<ExtArgs>>
    ): Prisma__TeamClient<
      $Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, 'create'>,
      never,
      ExtArgs
    >;

    /**
     * Create many Teams.
     * @param {TeamCreateManyArgs} args - Arguments to create many Teams.
     * @example
     * // Create many Teams
     * const team = await prisma.team.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends TeamCreateManyArgs>(
      args?: SelectSubset<T, TeamCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Teams and returns the data saved in the database.
     * @param {TeamCreateManyAndReturnArgs} args - Arguments to create many Teams.
     * @example
     * // Create many Teams
     * const team = await prisma.team.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Teams and only return the `id`
     * const teamWithIdOnly = await prisma.team.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends TeamCreateManyAndReturnArgs>(
      args?: SelectSubset<T, TeamCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, 'createManyAndReturn'>
    >;

    /**
     * Delete a Team.
     * @param {TeamDeleteArgs} args - Arguments to delete one Team.
     * @example
     * // Delete one Team
     * const Team = await prisma.team.delete({
     *   where: {
     *     // ... filter to delete one Team
     *   }
     * })
     *
     */
    delete<T extends TeamDeleteArgs>(
      args: SelectSubset<T, TeamDeleteArgs<ExtArgs>>
    ): Prisma__TeamClient<
      $Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, 'delete'>,
      never,
      ExtArgs
    >;

    /**
     * Update one Team.
     * @param {TeamUpdateArgs} args - Arguments to update one Team.
     * @example
     * // Update one Team
     * const team = await prisma.team.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends TeamUpdateArgs>(
      args: SelectSubset<T, TeamUpdateArgs<ExtArgs>>
    ): Prisma__TeamClient<
      $Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, 'update'>,
      never,
      ExtArgs
    >;

    /**
     * Delete zero or more Teams.
     * @param {TeamDeleteManyArgs} args - Arguments to filter Teams to delete.
     * @example
     * // Delete a few Teams
     * const { count } = await prisma.team.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends TeamDeleteManyArgs>(
      args?: SelectSubset<T, TeamDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Teams
     * const team = await prisma.team.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends TeamUpdateManyArgs>(
      args: SelectSubset<T, TeamUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Team.
     * @param {TeamUpsertArgs} args - Arguments to update or create a Team.
     * @example
     * // Update or create a Team
     * const team = await prisma.team.upsert({
     *   create: {
     *     // ... data to create a Team
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Team we want to update
     *   }
     * })
     */
    upsert<T extends TeamUpsertArgs>(
      args: SelectSubset<T, TeamUpsertArgs<ExtArgs>>
    ): Prisma__TeamClient<
      $Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, 'upsert'>,
      never,
      ExtArgs
    >;

    /**
     * Count the number of Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamCountArgs} args - Arguments to filter Teams to count.
     * @example
     * // Count the number of Teams
     * const count = await prisma.team.count({
     *   where: {
     *     // ... the filter for the Teams we want to count
     *   }
     * })
     **/
    count<T extends TeamCountArgs>(
      args?: Subset<T, TeamCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends TeamAggregateArgs>(
      args: Subset<T, TeamAggregateArgs>
    ): Prisma.PrismaPromise<GetTeamAggregateType<T>>;

    /**
     * Group by Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends TeamGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamGroupByArgs['orderBy'] }
        : { orderBy?: TeamGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, TeamGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetTeamGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Team model
     */
    readonly fields: TeamFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Team.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeamClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    hackathon<T extends HackathonDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, HackathonDefaultArgs<ExtArgs>>
    ): Prisma__HackathonClient<
      $Result.GetResult<Prisma.$HackathonPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null,
      Null,
      ExtArgs
    >;
    members<T extends Team$membersArgs<ExtArgs> = {}>(
      args?: Subset<T, Team$membersArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, 'findMany'> | Null
    >;
    submissions<T extends Team$submissionsArgs<ExtArgs> = {}>(
      args?: Subset<T, Team$submissionsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$SubmissionPayload<ExtArgs>, T, 'findMany'> | Null
    >;
    challengeSubmissions<T extends Team$challengeSubmissionsArgs<ExtArgs> = {}>(
      args?: Subset<T, Team$challengeSubmissionsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ChallengeSubmissionPayload<ExtArgs>, T, 'findMany'> | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Team model
   */
  interface TeamFieldRefs {
    readonly id: FieldRef<'Team', 'String'>;
    readonly hackathonId: FieldRef<'Team', 'String'>;
    readonly name: FieldRef<'Team', 'String'>;
    readonly bio: FieldRef<'Team', 'String'>;
    readonly logoUrl: FieldRef<'Team', 'String'>;
    readonly repoUrl: FieldRef<'Team', 'String'>;
    readonly demoUrl: FieldRef<'Team', 'String'>;
    readonly createdAt: FieldRef<'Team', 'DateTime'>;
    readonly updatedAt: FieldRef<'Team', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * Team findUnique
   */
  export type TeamFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null;
    /**
     * Filter, which Team to fetch.
     */
    where: TeamWhereUniqueInput;
  };

  /**
   * Team findUniqueOrThrow
   */
  export type TeamFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null;
    /**
     * Filter, which Team to fetch.
     */
    where: TeamWhereUniqueInput;
  };

  /**
   * Team findFirst
   */
  export type TeamFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null;
    /**
     * Filter, which Team to fetch.
     */
    where?: TeamWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Teams.
     */
    cursor?: TeamWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Teams.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Teams.
     */
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[];
  };

  /**
   * Team findFirstOrThrow
   */
  export type TeamFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null;
    /**
     * Filter, which Team to fetch.
     */
    where?: TeamWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Teams.
     */
    cursor?: TeamWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Teams.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Teams.
     */
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[];
  };

  /**
   * Team findMany
   */
  export type TeamFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the Team
       */
      select?: TeamSelect<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: TeamInclude<ExtArgs> | null;
      /**
       * Filter, which Teams to fetch.
       */
      where?: TeamWhereInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
       *
       * Determine the order of Teams to fetch.
       */
      orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[];
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
       *
       * Sets the position for listing Teams.
       */
      cursor?: TeamWhereUniqueInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Take `±n` Teams from the position of the cursor.
       */
      take?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Skip the first `n` Teams.
       */
      skip?: number;
      distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[];
    };

  /**
   * Team create
   */
  export type TeamCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null;
    /**
     * The data needed to create a Team.
     */
    data: XOR<TeamCreateInput, TeamUncheckedCreateInput>;
  };

  /**
   * Team createMany
   */
  export type TeamCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Teams.
     */
    data: TeamCreateManyInput | TeamCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Team createManyAndReturn
   */
  export type TeamCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * The data used to create many Teams.
     */
    data: TeamCreateManyInput | TeamCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Team update
   */
  export type TeamUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null;
    /**
     * The data needed to update a Team.
     */
    data: XOR<TeamUpdateInput, TeamUncheckedUpdateInput>;
    /**
     * Choose, which Team to update.
     */
    where: TeamWhereUniqueInput;
  };

  /**
   * Team updateMany
   */
  export type TeamUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Teams.
     */
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyInput>;
    /**
     * Filter which Teams to update
     */
    where?: TeamWhereInput;
  };

  /**
   * Team upsert
   */
  export type TeamUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null;
    /**
     * The filter to search for the Team to update in case it exists.
     */
    where: TeamWhereUniqueInput;
    /**
     * In case the Team found by the `where` argument doesn't exist, create a new Team with this data.
     */
    create: XOR<TeamCreateInput, TeamUncheckedCreateInput>;
    /**
     * In case the Team was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeamUpdateInput, TeamUncheckedUpdateInput>;
  };

  /**
   * Team delete
   */
  export type TeamDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null;
    /**
     * Filter which Team to delete.
     */
    where: TeamWhereUniqueInput;
  };

  /**
   * Team deleteMany
   */
  export type TeamDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Teams to delete
     */
    where?: TeamWhereInput;
  };

  /**
   * Team.members
   */
  export type Team$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the TeamMember
       */
      select?: TeamMemberSelect<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: TeamMemberInclude<ExtArgs> | null;
      where?: TeamMemberWhereInput;
      orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[];
      cursor?: TeamMemberWhereUniqueInput;
      take?: number;
      skip?: number;
      distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[];
    };

  /**
   * Team.submissions
   */
  export type Team$submissionsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionInclude<ExtArgs> | null;
    where?: SubmissionWhereInput;
    orderBy?: SubmissionOrderByWithRelationInput | SubmissionOrderByWithRelationInput[];
    cursor?: SubmissionWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: SubmissionScalarFieldEnum | SubmissionScalarFieldEnum[];
  };

  /**
   * Team.challengeSubmissions
   */
  export type Team$challengeSubmissionsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ChallengeSubmission
     */
    select?: ChallengeSubmissionSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeSubmissionInclude<ExtArgs> | null;
    where?: ChallengeSubmissionWhereInput;
    orderBy?:
      | ChallengeSubmissionOrderByWithRelationInput
      | ChallengeSubmissionOrderByWithRelationInput[];
    cursor?: ChallengeSubmissionWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ChallengeSubmissionScalarFieldEnum | ChallengeSubmissionScalarFieldEnum[];
  };

  /**
   * Team without action
   */
  export type TeamDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the Team
       */
      select?: TeamSelect<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: TeamInclude<ExtArgs> | null;
    };

  /**
   * Model TeamMember
   */

  export type AggregateTeamMember = {
    _count: TeamMemberCountAggregateOutputType | null;
    _min: TeamMemberMinAggregateOutputType | null;
    _max: TeamMemberMaxAggregateOutputType | null;
  };

  export type TeamMemberMinAggregateOutputType = {
    teamId: string | null;
    userId: string | null;
    role: $Enums.TeamMemberRole | null;
    joinedAt: Date | null;
  };

  export type TeamMemberMaxAggregateOutputType = {
    teamId: string | null;
    userId: string | null;
    role: $Enums.TeamMemberRole | null;
    joinedAt: Date | null;
  };

  export type TeamMemberCountAggregateOutputType = {
    teamId: number;
    userId: number;
    role: number;
    joinedAt: number;
    _all: number;
  };

  export type TeamMemberMinAggregateInputType = {
    teamId?: true;
    userId?: true;
    role?: true;
    joinedAt?: true;
  };

  export type TeamMemberMaxAggregateInputType = {
    teamId?: true;
    userId?: true;
    role?: true;
    joinedAt?: true;
  };

  export type TeamMemberCountAggregateInputType = {
    teamId?: true;
    userId?: true;
    role?: true;
    joinedAt?: true;
    _all?: true;
  };

  export type TeamMemberAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which TeamMember to aggregate.
     */
    where?: TeamMemberWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: TeamMemberWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` TeamMembers.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned TeamMembers
     **/
    _count?: true | TeamMemberCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: TeamMemberMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: TeamMemberMaxAggregateInputType;
  };

  export type GetTeamMemberAggregateType<T extends TeamMemberAggregateArgs> = {
    [P in keyof T & keyof AggregateTeamMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeamMember[P]>
      : GetScalarType<T[P], AggregateTeamMember[P]>;
  };

  export type TeamMemberGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: TeamMemberWhereInput;
    orderBy?: TeamMemberOrderByWithAggregationInput | TeamMemberOrderByWithAggregationInput[];
    by: TeamMemberScalarFieldEnum[] | TeamMemberScalarFieldEnum;
    having?: TeamMemberScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: TeamMemberCountAggregateInputType | true;
    _min?: TeamMemberMinAggregateInputType;
    _max?: TeamMemberMaxAggregateInputType;
  };

  export type TeamMemberGroupByOutputType = {
    teamId: string;
    userId: string;
    role: $Enums.TeamMemberRole;
    joinedAt: Date;
    _count: TeamMemberCountAggregateOutputType | null;
    _min: TeamMemberMinAggregateOutputType | null;
    _max: TeamMemberMaxAggregateOutputType | null;
  };

  type GetTeamMemberGroupByPayload<T extends TeamMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeamMemberGroupByOutputType, T['by']> & {
        [P in keyof T & keyof TeamMemberGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], TeamMemberGroupByOutputType[P]>
          : GetScalarType<T[P], TeamMemberGroupByOutputType[P]>;
      }
    >
  >;

  export type TeamMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        teamId?: boolean;
        userId?: boolean;
        role?: boolean;
        joinedAt?: boolean;
        team?: boolean | TeamDefaultArgs<ExtArgs>;
        user?: boolean | UserDefaultArgs<ExtArgs>;
      },
      ExtArgs['result']['teamMember']
    >;

  export type TeamMemberSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      teamId?: boolean;
      userId?: boolean;
      role?: boolean;
      joinedAt?: boolean;
      team?: boolean | TeamDefaultArgs<ExtArgs>;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['teamMember']
  >;

  export type TeamMemberSelectScalar = {
    teamId?: boolean;
    userId?: boolean;
    role?: boolean;
    joinedAt?: boolean;
  };

  export type TeamMemberInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    team?: boolean | TeamDefaultArgs<ExtArgs>;
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type TeamMemberIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    team?: boolean | TeamDefaultArgs<ExtArgs>;
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $TeamMemberPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'TeamMember';
    objects: {
      team: Prisma.$TeamPayload<ExtArgs>;
      user: Prisma.$UserPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        teamId: string;
        userId: string;
        role: $Enums.TeamMemberRole;
        joinedAt: Date;
      },
      ExtArgs['result']['teamMember']
    >;
    composites: {};
  };

  type TeamMemberGetPayload<S extends boolean | null | undefined | TeamMemberDefaultArgs> =
    $Result.GetResult<Prisma.$TeamMemberPayload, S>;

  type TeamMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TeamMemberFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TeamMemberCountAggregateInputType | true;
    };

  export interface TeamMemberDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['TeamMember'];
      meta: { name: 'TeamMember' };
    };
    /**
     * Find zero or one TeamMember that matches the filter.
     * @param {TeamMemberFindUniqueArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeamMemberFindUniqueArgs>(
      args: SelectSubset<T, TeamMemberFindUniqueArgs<ExtArgs>>
    ): Prisma__TeamMemberClient<
      $Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, 'findUnique'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find one TeamMember that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TeamMemberFindUniqueOrThrowArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeamMemberFindUniqueOrThrowArgs>(
      args: SelectSubset<T, TeamMemberFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TeamMemberClient<
      $Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, 'findUniqueOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find the first TeamMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberFindFirstArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeamMemberFindFirstArgs>(
      args?: SelectSubset<T, TeamMemberFindFirstArgs<ExtArgs>>
    ): Prisma__TeamMemberClient<
      $Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, 'findFirst'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find the first TeamMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberFindFirstOrThrowArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeamMemberFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TeamMemberFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TeamMemberClient<
      $Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, 'findFirstOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more TeamMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TeamMembers
     * const teamMembers = await prisma.teamMember.findMany()
     *
     * // Get first 10 TeamMembers
     * const teamMembers = await prisma.teamMember.findMany({ take: 10 })
     *
     * // Only select the `teamId`
     * const teamMemberWithTeamIdOnly = await prisma.teamMember.findMany({ select: { teamId: true } })
     *
     */
    findMany<T extends TeamMemberFindManyArgs>(
      args?: SelectSubset<T, TeamMemberFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, 'findMany'>>;

    /**
     * Create a TeamMember.
     * @param {TeamMemberCreateArgs} args - Arguments to create a TeamMember.
     * @example
     * // Create one TeamMember
     * const TeamMember = await prisma.teamMember.create({
     *   data: {
     *     // ... data to create a TeamMember
     *   }
     * })
     *
     */
    create<T extends TeamMemberCreateArgs>(
      args: SelectSubset<T, TeamMemberCreateArgs<ExtArgs>>
    ): Prisma__TeamMemberClient<
      $Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, 'create'>,
      never,
      ExtArgs
    >;

    /**
     * Create many TeamMembers.
     * @param {TeamMemberCreateManyArgs} args - Arguments to create many TeamMembers.
     * @example
     * // Create many TeamMembers
     * const teamMember = await prisma.teamMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends TeamMemberCreateManyArgs>(
      args?: SelectSubset<T, TeamMemberCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many TeamMembers and returns the data saved in the database.
     * @param {TeamMemberCreateManyAndReturnArgs} args - Arguments to create many TeamMembers.
     * @example
     * // Create many TeamMembers
     * const teamMember = await prisma.teamMember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many TeamMembers and only return the `teamId`
     * const teamMemberWithTeamIdOnly = await prisma.teamMember.createManyAndReturn({
     *   select: { teamId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends TeamMemberCreateManyAndReturnArgs>(
      args?: SelectSubset<T, TeamMemberCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, 'createManyAndReturn'>
    >;

    /**
     * Delete a TeamMember.
     * @param {TeamMemberDeleteArgs} args - Arguments to delete one TeamMember.
     * @example
     * // Delete one TeamMember
     * const TeamMember = await prisma.teamMember.delete({
     *   where: {
     *     // ... filter to delete one TeamMember
     *   }
     * })
     *
     */
    delete<T extends TeamMemberDeleteArgs>(
      args: SelectSubset<T, TeamMemberDeleteArgs<ExtArgs>>
    ): Prisma__TeamMemberClient<
      $Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, 'delete'>,
      never,
      ExtArgs
    >;

    /**
     * Update one TeamMember.
     * @param {TeamMemberUpdateArgs} args - Arguments to update one TeamMember.
     * @example
     * // Update one TeamMember
     * const teamMember = await prisma.teamMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends TeamMemberUpdateArgs>(
      args: SelectSubset<T, TeamMemberUpdateArgs<ExtArgs>>
    ): Prisma__TeamMemberClient<
      $Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, 'update'>,
      never,
      ExtArgs
    >;

    /**
     * Delete zero or more TeamMembers.
     * @param {TeamMemberDeleteManyArgs} args - Arguments to filter TeamMembers to delete.
     * @example
     * // Delete a few TeamMembers
     * const { count } = await prisma.teamMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends TeamMemberDeleteManyArgs>(
      args?: SelectSubset<T, TeamMemberDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more TeamMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TeamMembers
     * const teamMember = await prisma.teamMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends TeamMemberUpdateManyArgs>(
      args: SelectSubset<T, TeamMemberUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one TeamMember.
     * @param {TeamMemberUpsertArgs} args - Arguments to update or create a TeamMember.
     * @example
     * // Update or create a TeamMember
     * const teamMember = await prisma.teamMember.upsert({
     *   create: {
     *     // ... data to create a TeamMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TeamMember we want to update
     *   }
     * })
     */
    upsert<T extends TeamMemberUpsertArgs>(
      args: SelectSubset<T, TeamMemberUpsertArgs<ExtArgs>>
    ): Prisma__TeamMemberClient<
      $Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, 'upsert'>,
      never,
      ExtArgs
    >;

    /**
     * Count the number of TeamMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberCountArgs} args - Arguments to filter TeamMembers to count.
     * @example
     * // Count the number of TeamMembers
     * const count = await prisma.teamMember.count({
     *   where: {
     *     // ... the filter for the TeamMembers we want to count
     *   }
     * })
     **/
    count<T extends TeamMemberCountArgs>(
      args?: Subset<T, TeamMemberCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamMemberCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a TeamMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends TeamMemberAggregateArgs>(
      args: Subset<T, TeamMemberAggregateArgs>
    ): Prisma.PrismaPromise<GetTeamMemberAggregateType<T>>;

    /**
     * Group by TeamMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends TeamMemberGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamMemberGroupByArgs['orderBy'] }
        : { orderBy?: TeamMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, TeamMemberGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetTeamMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the TeamMember model
     */
    readonly fields: TeamMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TeamMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeamMemberClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    team<T extends TeamDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, TeamDefaultArgs<ExtArgs>>
    ): Prisma__TeamClient<
      $Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null,
      Null,
      ExtArgs
    >;
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null,
      Null,
      ExtArgs
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the TeamMember model
   */
  interface TeamMemberFieldRefs {
    readonly teamId: FieldRef<'TeamMember', 'String'>;
    readonly userId: FieldRef<'TeamMember', 'String'>;
    readonly role: FieldRef<'TeamMember', 'TeamMemberRole'>;
    readonly joinedAt: FieldRef<'TeamMember', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * TeamMember findUnique
   */
  export type TeamMemberFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null;
    /**
     * Filter, which TeamMember to fetch.
     */
    where: TeamMemberWhereUniqueInput;
  };

  /**
   * TeamMember findUniqueOrThrow
   */
  export type TeamMemberFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null;
    /**
     * Filter, which TeamMember to fetch.
     */
    where: TeamMemberWhereUniqueInput;
  };

  /**
   * TeamMember findFirst
   */
  export type TeamMemberFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null;
    /**
     * Filter, which TeamMember to fetch.
     */
    where?: TeamMemberWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for TeamMembers.
     */
    cursor?: TeamMemberWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` TeamMembers.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of TeamMembers.
     */
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[];
  };

  /**
   * TeamMember findFirstOrThrow
   */
  export type TeamMemberFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null;
    /**
     * Filter, which TeamMember to fetch.
     */
    where?: TeamMemberWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for TeamMembers.
     */
    cursor?: TeamMemberWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` TeamMembers.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of TeamMembers.
     */
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[];
  };

  /**
   * TeamMember findMany
   */
  export type TeamMemberFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null;
    /**
     * Filter, which TeamMembers to fetch.
     */
    where?: TeamMemberWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing TeamMembers.
     */
    cursor?: TeamMemberWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` TeamMembers.
     */
    skip?: number;
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[];
  };

  /**
   * TeamMember create
   */
  export type TeamMemberCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null;
    /**
     * The data needed to create a TeamMember.
     */
    data: XOR<TeamMemberCreateInput, TeamMemberUncheckedCreateInput>;
  };

  /**
   * TeamMember createMany
   */
  export type TeamMemberCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many TeamMembers.
     */
    data: TeamMemberCreateManyInput | TeamMemberCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * TeamMember createManyAndReturn
   */
  export type TeamMemberCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * The data used to create many TeamMembers.
     */
    data: TeamMemberCreateManyInput | TeamMemberCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * TeamMember update
   */
  export type TeamMemberUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null;
    /**
     * The data needed to update a TeamMember.
     */
    data: XOR<TeamMemberUpdateInput, TeamMemberUncheckedUpdateInput>;
    /**
     * Choose, which TeamMember to update.
     */
    where: TeamMemberWhereUniqueInput;
  };

  /**
   * TeamMember updateMany
   */
  export type TeamMemberUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update TeamMembers.
     */
    data: XOR<TeamMemberUpdateManyMutationInput, TeamMemberUncheckedUpdateManyInput>;
    /**
     * Filter which TeamMembers to update
     */
    where?: TeamMemberWhereInput;
  };

  /**
   * TeamMember upsert
   */
  export type TeamMemberUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null;
    /**
     * The filter to search for the TeamMember to update in case it exists.
     */
    where: TeamMemberWhereUniqueInput;
    /**
     * In case the TeamMember found by the `where` argument doesn't exist, create a new TeamMember with this data.
     */
    create: XOR<TeamMemberCreateInput, TeamMemberUncheckedCreateInput>;
    /**
     * In case the TeamMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeamMemberUpdateInput, TeamMemberUncheckedUpdateInput>;
  };

  /**
   * TeamMember delete
   */
  export type TeamMemberDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null;
    /**
     * Filter which TeamMember to delete.
     */
    where: TeamMemberWhereUniqueInput;
  };

  /**
   * TeamMember deleteMany
   */
  export type TeamMemberDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which TeamMembers to delete
     */
    where?: TeamMemberWhereInput;
  };

  /**
   * TeamMember without action
   */
  export type TeamMemberDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null;
  };

  /**
   * Model Mentor
   */

  export type AggregateMentor = {
    _count: MentorCountAggregateOutputType | null;
    _min: MentorMinAggregateOutputType | null;
    _max: MentorMaxAggregateOutputType | null;
  };

  export type MentorMinAggregateOutputType = {
    id: string | null;
    userId: string | null;
    hackathonId: string | null;
    bio: string | null;
    calendlyUrl: string | null;
    createdAt: Date | null;
  };

  export type MentorMaxAggregateOutputType = {
    id: string | null;
    userId: string | null;
    hackathonId: string | null;
    bio: string | null;
    calendlyUrl: string | null;
    createdAt: Date | null;
  };

  export type MentorCountAggregateOutputType = {
    id: number;
    userId: number;
    hackathonId: number;
    bio: number;
    calendlyUrl: number;
    expertise: number;
    createdAt: number;
    _all: number;
  };

  export type MentorMinAggregateInputType = {
    id?: true;
    userId?: true;
    hackathonId?: true;
    bio?: true;
    calendlyUrl?: true;
    createdAt?: true;
  };

  export type MentorMaxAggregateInputType = {
    id?: true;
    userId?: true;
    hackathonId?: true;
    bio?: true;
    calendlyUrl?: true;
    createdAt?: true;
  };

  export type MentorCountAggregateInputType = {
    id?: true;
    userId?: true;
    hackathonId?: true;
    bio?: true;
    calendlyUrl?: true;
    expertise?: true;
    createdAt?: true;
    _all?: true;
  };

  export type MentorAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Mentor to aggregate.
     */
    where?: MentorWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Mentors to fetch.
     */
    orderBy?: MentorOrderByWithRelationInput | MentorOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: MentorWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Mentors from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Mentors.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Mentors
     **/
    _count?: true | MentorCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: MentorMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: MentorMaxAggregateInputType;
  };

  export type GetMentorAggregateType<T extends MentorAggregateArgs> = {
    [P in keyof T & keyof AggregateMentor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMentor[P]>
      : GetScalarType<T[P], AggregateMentor[P]>;
  };

  export type MentorGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: MentorWhereInput;
    orderBy?: MentorOrderByWithAggregationInput | MentorOrderByWithAggregationInput[];
    by: MentorScalarFieldEnum[] | MentorScalarFieldEnum;
    having?: MentorScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: MentorCountAggregateInputType | true;
    _min?: MentorMinAggregateInputType;
    _max?: MentorMaxAggregateInputType;
  };

  export type MentorGroupByOutputType = {
    id: string;
    userId: string;
    hackathonId: string;
    bio: string | null;
    calendlyUrl: string | null;
    expertise: string[];
    createdAt: Date;
    _count: MentorCountAggregateOutputType | null;
    _min: MentorMinAggregateOutputType | null;
    _max: MentorMaxAggregateOutputType | null;
  };

  type GetMentorGroupByPayload<T extends MentorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MentorGroupByOutputType, T['by']> & {
        [P in keyof T & keyof MentorGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], MentorGroupByOutputType[P]>
          : GetScalarType<T[P], MentorGroupByOutputType[P]>;
      }
    >
  >;

  export type MentorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        userId?: boolean;
        hackathonId?: boolean;
        bio?: boolean;
        calendlyUrl?: boolean;
        expertise?: boolean;
        createdAt?: boolean;
        user?: boolean | UserDefaultArgs<ExtArgs>;
        hackathon?: boolean | HackathonDefaultArgs<ExtArgs>;
        sessions?: boolean | Mentor$sessionsArgs<ExtArgs>;
        _count?: boolean | MentorCountOutputTypeDefaultArgs<ExtArgs>;
      },
      ExtArgs['result']['mentor']
    >;

  export type MentorSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      hackathonId?: boolean;
      bio?: boolean;
      calendlyUrl?: boolean;
      expertise?: boolean;
      createdAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
      hackathon?: boolean | HackathonDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['mentor']
  >;

  export type MentorSelectScalar = {
    id?: boolean;
    userId?: boolean;
    hackathonId?: boolean;
    bio?: boolean;
    calendlyUrl?: boolean;
    expertise?: boolean;
    createdAt?: boolean;
  };

  export type MentorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
    hackathon?: boolean | HackathonDefaultArgs<ExtArgs>;
    sessions?: boolean | Mentor$sessionsArgs<ExtArgs>;
    _count?: boolean | MentorCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type MentorIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
    hackathon?: boolean | HackathonDefaultArgs<ExtArgs>;
  };

  export type $MentorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: 'Mentor';
    objects: {
      user: Prisma.$UserPayload<ExtArgs>;
      hackathon: Prisma.$HackathonPayload<ExtArgs>;
      sessions: Prisma.$MentorSessionPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        userId: string;
        hackathonId: string;
        bio: string | null;
        calendlyUrl: string | null;
        expertise: string[];
        createdAt: Date;
      },
      ExtArgs['result']['mentor']
    >;
    composites: {};
  };

  type MentorGetPayload<S extends boolean | null | undefined | MentorDefaultArgs> =
    $Result.GetResult<Prisma.$MentorPayload, S>;

  type MentorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    MentorFindManyArgs,
    'select' | 'include' | 'distinct'
  > & {
    select?: MentorCountAggregateInputType | true;
  };

  export interface MentorDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Mentor']; meta: { name: 'Mentor' } };
    /**
     * Find zero or one Mentor that matches the filter.
     * @param {MentorFindUniqueArgs} args - Arguments to find a Mentor
     * @example
     * // Get one Mentor
     * const mentor = await prisma.mentor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MentorFindUniqueArgs>(
      args: SelectSubset<T, MentorFindUniqueArgs<ExtArgs>>
    ): Prisma__MentorClient<
      $Result.GetResult<Prisma.$MentorPayload<ExtArgs>, T, 'findUnique'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find one Mentor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MentorFindUniqueOrThrowArgs} args - Arguments to find a Mentor
     * @example
     * // Get one Mentor
     * const mentor = await prisma.mentor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MentorFindUniqueOrThrowArgs>(
      args: SelectSubset<T, MentorFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MentorClient<
      $Result.GetResult<Prisma.$MentorPayload<ExtArgs>, T, 'findUniqueOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find the first Mentor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorFindFirstArgs} args - Arguments to find a Mentor
     * @example
     * // Get one Mentor
     * const mentor = await prisma.mentor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MentorFindFirstArgs>(
      args?: SelectSubset<T, MentorFindFirstArgs<ExtArgs>>
    ): Prisma__MentorClient<
      $Result.GetResult<Prisma.$MentorPayload<ExtArgs>, T, 'findFirst'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find the first Mentor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorFindFirstOrThrowArgs} args - Arguments to find a Mentor
     * @example
     * // Get one Mentor
     * const mentor = await prisma.mentor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MentorFindFirstOrThrowArgs>(
      args?: SelectSubset<T, MentorFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MentorClient<
      $Result.GetResult<Prisma.$MentorPayload<ExtArgs>, T, 'findFirstOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more Mentors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Mentors
     * const mentors = await prisma.mentor.findMany()
     *
     * // Get first 10 Mentors
     * const mentors = await prisma.mentor.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const mentorWithIdOnly = await prisma.mentor.findMany({ select: { id: true } })
     *
     */
    findMany<T extends MentorFindManyArgs>(
      args?: SelectSubset<T, MentorFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MentorPayload<ExtArgs>, T, 'findMany'>>;

    /**
     * Create a Mentor.
     * @param {MentorCreateArgs} args - Arguments to create a Mentor.
     * @example
     * // Create one Mentor
     * const Mentor = await prisma.mentor.create({
     *   data: {
     *     // ... data to create a Mentor
     *   }
     * })
     *
     */
    create<T extends MentorCreateArgs>(
      args: SelectSubset<T, MentorCreateArgs<ExtArgs>>
    ): Prisma__MentorClient<
      $Result.GetResult<Prisma.$MentorPayload<ExtArgs>, T, 'create'>,
      never,
      ExtArgs
    >;

    /**
     * Create many Mentors.
     * @param {MentorCreateManyArgs} args - Arguments to create many Mentors.
     * @example
     * // Create many Mentors
     * const mentor = await prisma.mentor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends MentorCreateManyArgs>(
      args?: SelectSubset<T, MentorCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Mentors and returns the data saved in the database.
     * @param {MentorCreateManyAndReturnArgs} args - Arguments to create many Mentors.
     * @example
     * // Create many Mentors
     * const mentor = await prisma.mentor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Mentors and only return the `id`
     * const mentorWithIdOnly = await prisma.mentor.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends MentorCreateManyAndReturnArgs>(
      args?: SelectSubset<T, MentorCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$MentorPayload<ExtArgs>, T, 'createManyAndReturn'>
    >;

    /**
     * Delete a Mentor.
     * @param {MentorDeleteArgs} args - Arguments to delete one Mentor.
     * @example
     * // Delete one Mentor
     * const Mentor = await prisma.mentor.delete({
     *   where: {
     *     // ... filter to delete one Mentor
     *   }
     * })
     *
     */
    delete<T extends MentorDeleteArgs>(
      args: SelectSubset<T, MentorDeleteArgs<ExtArgs>>
    ): Prisma__MentorClient<
      $Result.GetResult<Prisma.$MentorPayload<ExtArgs>, T, 'delete'>,
      never,
      ExtArgs
    >;

    /**
     * Update one Mentor.
     * @param {MentorUpdateArgs} args - Arguments to update one Mentor.
     * @example
     * // Update one Mentor
     * const mentor = await prisma.mentor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends MentorUpdateArgs>(
      args: SelectSubset<T, MentorUpdateArgs<ExtArgs>>
    ): Prisma__MentorClient<
      $Result.GetResult<Prisma.$MentorPayload<ExtArgs>, T, 'update'>,
      never,
      ExtArgs
    >;

    /**
     * Delete zero or more Mentors.
     * @param {MentorDeleteManyArgs} args - Arguments to filter Mentors to delete.
     * @example
     * // Delete a few Mentors
     * const { count } = await prisma.mentor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends MentorDeleteManyArgs>(
      args?: SelectSubset<T, MentorDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Mentors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Mentors
     * const mentor = await prisma.mentor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends MentorUpdateManyArgs>(
      args: SelectSubset<T, MentorUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Mentor.
     * @param {MentorUpsertArgs} args - Arguments to update or create a Mentor.
     * @example
     * // Update or create a Mentor
     * const mentor = await prisma.mentor.upsert({
     *   create: {
     *     // ... data to create a Mentor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Mentor we want to update
     *   }
     * })
     */
    upsert<T extends MentorUpsertArgs>(
      args: SelectSubset<T, MentorUpsertArgs<ExtArgs>>
    ): Prisma__MentorClient<
      $Result.GetResult<Prisma.$MentorPayload<ExtArgs>, T, 'upsert'>,
      never,
      ExtArgs
    >;

    /**
     * Count the number of Mentors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorCountArgs} args - Arguments to filter Mentors to count.
     * @example
     * // Count the number of Mentors
     * const count = await prisma.mentor.count({
     *   where: {
     *     // ... the filter for the Mentors we want to count
     *   }
     * })
     **/
    count<T extends MentorCountArgs>(
      args?: Subset<T, MentorCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MentorCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Mentor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends MentorAggregateArgs>(
      args: Subset<T, MentorAggregateArgs>
    ): Prisma.PrismaPromise<GetMentorAggregateType<T>>;

    /**
     * Group by Mentor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends MentorGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MentorGroupByArgs['orderBy'] }
        : { orderBy?: MentorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, MentorGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetMentorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Mentor model
     */
    readonly fields: MentorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Mentor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MentorClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null,
      Null,
      ExtArgs
    >;
    hackathon<T extends HackathonDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, HackathonDefaultArgs<ExtArgs>>
    ): Prisma__HackathonClient<
      $Result.GetResult<Prisma.$HackathonPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null,
      Null,
      ExtArgs
    >;
    sessions<T extends Mentor$sessionsArgs<ExtArgs> = {}>(
      args?: Subset<T, Mentor$sessionsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$MentorSessionPayload<ExtArgs>, T, 'findMany'> | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Mentor model
   */
  interface MentorFieldRefs {
    readonly id: FieldRef<'Mentor', 'String'>;
    readonly userId: FieldRef<'Mentor', 'String'>;
    readonly hackathonId: FieldRef<'Mentor', 'String'>;
    readonly bio: FieldRef<'Mentor', 'String'>;
    readonly calendlyUrl: FieldRef<'Mentor', 'String'>;
    readonly expertise: FieldRef<'Mentor', 'String[]'>;
    readonly createdAt: FieldRef<'Mentor', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * Mentor findUnique
   */
  export type MentorFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Mentor
     */
    select?: MentorSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorInclude<ExtArgs> | null;
    /**
     * Filter, which Mentor to fetch.
     */
    where: MentorWhereUniqueInput;
  };

  /**
   * Mentor findUniqueOrThrow
   */
  export type MentorFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Mentor
     */
    select?: MentorSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorInclude<ExtArgs> | null;
    /**
     * Filter, which Mentor to fetch.
     */
    where: MentorWhereUniqueInput;
  };

  /**
   * Mentor findFirst
   */
  export type MentorFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Mentor
     */
    select?: MentorSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorInclude<ExtArgs> | null;
    /**
     * Filter, which Mentor to fetch.
     */
    where?: MentorWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Mentors to fetch.
     */
    orderBy?: MentorOrderByWithRelationInput | MentorOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Mentors.
     */
    cursor?: MentorWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Mentors from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Mentors.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Mentors.
     */
    distinct?: MentorScalarFieldEnum | MentorScalarFieldEnum[];
  };

  /**
   * Mentor findFirstOrThrow
   */
  export type MentorFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Mentor
     */
    select?: MentorSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorInclude<ExtArgs> | null;
    /**
     * Filter, which Mentor to fetch.
     */
    where?: MentorWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Mentors to fetch.
     */
    orderBy?: MentorOrderByWithRelationInput | MentorOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Mentors.
     */
    cursor?: MentorWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Mentors from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Mentors.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Mentors.
     */
    distinct?: MentorScalarFieldEnum | MentorScalarFieldEnum[];
  };

  /**
   * Mentor findMany
   */
  export type MentorFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Mentor
     */
    select?: MentorSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorInclude<ExtArgs> | null;
    /**
     * Filter, which Mentors to fetch.
     */
    where?: MentorWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Mentors to fetch.
     */
    orderBy?: MentorOrderByWithRelationInput | MentorOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Mentors.
     */
    cursor?: MentorWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Mentors from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Mentors.
     */
    skip?: number;
    distinct?: MentorScalarFieldEnum | MentorScalarFieldEnum[];
  };

  /**
   * Mentor create
   */
  export type MentorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the Mentor
       */
      select?: MentorSelect<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: MentorInclude<ExtArgs> | null;
      /**
       * The data needed to create a Mentor.
       */
      data: XOR<MentorCreateInput, MentorUncheckedCreateInput>;
    };

  /**
   * Mentor createMany
   */
  export type MentorCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Mentors.
     */
    data: MentorCreateManyInput | MentorCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Mentor createManyAndReturn
   */
  export type MentorCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Mentor
     */
    select?: MentorSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * The data used to create many Mentors.
     */
    data: MentorCreateManyInput | MentorCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Mentor update
   */
  export type MentorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the Mentor
       */
      select?: MentorSelect<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: MentorInclude<ExtArgs> | null;
      /**
       * The data needed to update a Mentor.
       */
      data: XOR<MentorUpdateInput, MentorUncheckedUpdateInput>;
      /**
       * Choose, which Mentor to update.
       */
      where: MentorWhereUniqueInput;
    };

  /**
   * Mentor updateMany
   */
  export type MentorUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Mentors.
     */
    data: XOR<MentorUpdateManyMutationInput, MentorUncheckedUpdateManyInput>;
    /**
     * Filter which Mentors to update
     */
    where?: MentorWhereInput;
  };

  /**
   * Mentor upsert
   */
  export type MentorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the Mentor
       */
      select?: MentorSelect<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: MentorInclude<ExtArgs> | null;
      /**
       * The filter to search for the Mentor to update in case it exists.
       */
      where: MentorWhereUniqueInput;
      /**
       * In case the Mentor found by the `where` argument doesn't exist, create a new Mentor with this data.
       */
      create: XOR<MentorCreateInput, MentorUncheckedCreateInput>;
      /**
       * In case the Mentor was found with the provided `where` argument, update it with this data.
       */
      update: XOR<MentorUpdateInput, MentorUncheckedUpdateInput>;
    };

  /**
   * Mentor delete
   */
  export type MentorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the Mentor
       */
      select?: MentorSelect<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: MentorInclude<ExtArgs> | null;
      /**
       * Filter which Mentor to delete.
       */
      where: MentorWhereUniqueInput;
    };

  /**
   * Mentor deleteMany
   */
  export type MentorDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Mentors to delete
     */
    where?: MentorWhereInput;
  };

  /**
   * Mentor.sessions
   */
  export type Mentor$sessionsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MentorSession
     */
    select?: MentorSessionSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorSessionInclude<ExtArgs> | null;
    where?: MentorSessionWhereInput;
    orderBy?: MentorSessionOrderByWithRelationInput | MentorSessionOrderByWithRelationInput[];
    cursor?: MentorSessionWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: MentorSessionScalarFieldEnum | MentorSessionScalarFieldEnum[];
  };

  /**
   * Mentor without action
   */
  export type MentorDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Mentor
     */
    select?: MentorSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorInclude<ExtArgs> | null;
  };

  /**
   * Model MentorSession
   */

  export type AggregateMentorSession = {
    _count: MentorSessionCountAggregateOutputType | null;
    _avg: MentorSessionAvgAggregateOutputType | null;
    _sum: MentorSessionSumAggregateOutputType | null;
    _min: MentorSessionMinAggregateOutputType | null;
    _max: MentorSessionMaxAggregateOutputType | null;
  };

  export type MentorSessionAvgAggregateOutputType = {
    capacity: number | null;
    booked: number | null;
  };

  export type MentorSessionSumAggregateOutputType = {
    capacity: number | null;
    booked: number | null;
  };

  export type MentorSessionMinAggregateOutputType = {
    id: string | null;
    mentorId: string | null;
    title: string | null;
    startsAt: Date | null;
    endsAt: Date | null;
    capacity: number | null;
    booked: number | null;
    meetingUrl: string | null;
    createdAt: Date | null;
  };

  export type MentorSessionMaxAggregateOutputType = {
    id: string | null;
    mentorId: string | null;
    title: string | null;
    startsAt: Date | null;
    endsAt: Date | null;
    capacity: number | null;
    booked: number | null;
    meetingUrl: string | null;
    createdAt: Date | null;
  };

  export type MentorSessionCountAggregateOutputType = {
    id: number;
    mentorId: number;
    title: number;
    startsAt: number;
    endsAt: number;
    capacity: number;
    booked: number;
    meetingUrl: number;
    createdAt: number;
    _all: number;
  };

  export type MentorSessionAvgAggregateInputType = {
    capacity?: true;
    booked?: true;
  };

  export type MentorSessionSumAggregateInputType = {
    capacity?: true;
    booked?: true;
  };

  export type MentorSessionMinAggregateInputType = {
    id?: true;
    mentorId?: true;
    title?: true;
    startsAt?: true;
    endsAt?: true;
    capacity?: true;
    booked?: true;
    meetingUrl?: true;
    createdAt?: true;
  };

  export type MentorSessionMaxAggregateInputType = {
    id?: true;
    mentorId?: true;
    title?: true;
    startsAt?: true;
    endsAt?: true;
    capacity?: true;
    booked?: true;
    meetingUrl?: true;
    createdAt?: true;
  };

  export type MentorSessionCountAggregateInputType = {
    id?: true;
    mentorId?: true;
    title?: true;
    startsAt?: true;
    endsAt?: true;
    capacity?: true;
    booked?: true;
    meetingUrl?: true;
    createdAt?: true;
    _all?: true;
  };

  export type MentorSessionAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which MentorSession to aggregate.
     */
    where?: MentorSessionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of MentorSessions to fetch.
     */
    orderBy?: MentorSessionOrderByWithRelationInput | MentorSessionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: MentorSessionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` MentorSessions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` MentorSessions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned MentorSessions
     **/
    _count?: true | MentorSessionCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: MentorSessionAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: MentorSessionSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: MentorSessionMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: MentorSessionMaxAggregateInputType;
  };

  export type GetMentorSessionAggregateType<T extends MentorSessionAggregateArgs> = {
    [P in keyof T & keyof AggregateMentorSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMentorSession[P]>
      : GetScalarType<T[P], AggregateMentorSession[P]>;
  };

  export type MentorSessionGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: MentorSessionWhereInput;
    orderBy?: MentorSessionOrderByWithAggregationInput | MentorSessionOrderByWithAggregationInput[];
    by: MentorSessionScalarFieldEnum[] | MentorSessionScalarFieldEnum;
    having?: MentorSessionScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: MentorSessionCountAggregateInputType | true;
    _avg?: MentorSessionAvgAggregateInputType;
    _sum?: MentorSessionSumAggregateInputType;
    _min?: MentorSessionMinAggregateInputType;
    _max?: MentorSessionMaxAggregateInputType;
  };

  export type MentorSessionGroupByOutputType = {
    id: string;
    mentorId: string;
    title: string | null;
    startsAt: Date;
    endsAt: Date;
    capacity: number;
    booked: number;
    meetingUrl: string | null;
    createdAt: Date;
    _count: MentorSessionCountAggregateOutputType | null;
    _avg: MentorSessionAvgAggregateOutputType | null;
    _sum: MentorSessionSumAggregateOutputType | null;
    _min: MentorSessionMinAggregateOutputType | null;
    _max: MentorSessionMaxAggregateOutputType | null;
  };

  type GetMentorSessionGroupByPayload<T extends MentorSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MentorSessionGroupByOutputType, T['by']> & {
        [P in keyof T & keyof MentorSessionGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], MentorSessionGroupByOutputType[P]>
          : GetScalarType<T[P], MentorSessionGroupByOutputType[P]>;
      }
    >
  >;

  export type MentorSessionSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      mentorId?: boolean;
      title?: boolean;
      startsAt?: boolean;
      endsAt?: boolean;
      capacity?: boolean;
      booked?: boolean;
      meetingUrl?: boolean;
      createdAt?: boolean;
      mentor?: boolean | MentorDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['mentorSession']
  >;

  export type MentorSessionSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      mentorId?: boolean;
      title?: boolean;
      startsAt?: boolean;
      endsAt?: boolean;
      capacity?: boolean;
      booked?: boolean;
      meetingUrl?: boolean;
      createdAt?: boolean;
      mentor?: boolean | MentorDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['mentorSession']
  >;

  export type MentorSessionSelectScalar = {
    id?: boolean;
    mentorId?: boolean;
    title?: boolean;
    startsAt?: boolean;
    endsAt?: boolean;
    capacity?: boolean;
    booked?: boolean;
    meetingUrl?: boolean;
    createdAt?: boolean;
  };

  export type MentorSessionInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    mentor?: boolean | MentorDefaultArgs<ExtArgs>;
  };
  export type MentorSessionIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    mentor?: boolean | MentorDefaultArgs<ExtArgs>;
  };

  export type $MentorSessionPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'MentorSession';
    objects: {
      mentor: Prisma.$MentorPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        mentorId: string;
        title: string | null;
        startsAt: Date;
        endsAt: Date;
        capacity: number;
        booked: number;
        meetingUrl: string | null;
        createdAt: Date;
      },
      ExtArgs['result']['mentorSession']
    >;
    composites: {};
  };

  type MentorSessionGetPayload<S extends boolean | null | undefined | MentorSessionDefaultArgs> =
    $Result.GetResult<Prisma.$MentorSessionPayload, S>;

  type MentorSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MentorSessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MentorSessionCountAggregateInputType | true;
    };

  export interface MentorSessionDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['MentorSession'];
      meta: { name: 'MentorSession' };
    };
    /**
     * Find zero or one MentorSession that matches the filter.
     * @param {MentorSessionFindUniqueArgs} args - Arguments to find a MentorSession
     * @example
     * // Get one MentorSession
     * const mentorSession = await prisma.mentorSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MentorSessionFindUniqueArgs>(
      args: SelectSubset<T, MentorSessionFindUniqueArgs<ExtArgs>>
    ): Prisma__MentorSessionClient<
      $Result.GetResult<Prisma.$MentorSessionPayload<ExtArgs>, T, 'findUnique'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find one MentorSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MentorSessionFindUniqueOrThrowArgs} args - Arguments to find a MentorSession
     * @example
     * // Get one MentorSession
     * const mentorSession = await prisma.mentorSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MentorSessionFindUniqueOrThrowArgs>(
      args: SelectSubset<T, MentorSessionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MentorSessionClient<
      $Result.GetResult<Prisma.$MentorSessionPayload<ExtArgs>, T, 'findUniqueOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find the first MentorSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorSessionFindFirstArgs} args - Arguments to find a MentorSession
     * @example
     * // Get one MentorSession
     * const mentorSession = await prisma.mentorSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MentorSessionFindFirstArgs>(
      args?: SelectSubset<T, MentorSessionFindFirstArgs<ExtArgs>>
    ): Prisma__MentorSessionClient<
      $Result.GetResult<Prisma.$MentorSessionPayload<ExtArgs>, T, 'findFirst'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find the first MentorSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorSessionFindFirstOrThrowArgs} args - Arguments to find a MentorSession
     * @example
     * // Get one MentorSession
     * const mentorSession = await prisma.mentorSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MentorSessionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, MentorSessionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MentorSessionClient<
      $Result.GetResult<Prisma.$MentorSessionPayload<ExtArgs>, T, 'findFirstOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more MentorSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MentorSessions
     * const mentorSessions = await prisma.mentorSession.findMany()
     *
     * // Get first 10 MentorSessions
     * const mentorSessions = await prisma.mentorSession.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const mentorSessionWithIdOnly = await prisma.mentorSession.findMany({ select: { id: true } })
     *
     */
    findMany<T extends MentorSessionFindManyArgs>(
      args?: SelectSubset<T, MentorSessionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$MentorSessionPayload<ExtArgs>, T, 'findMany'>
    >;

    /**
     * Create a MentorSession.
     * @param {MentorSessionCreateArgs} args - Arguments to create a MentorSession.
     * @example
     * // Create one MentorSession
     * const MentorSession = await prisma.mentorSession.create({
     *   data: {
     *     // ... data to create a MentorSession
     *   }
     * })
     *
     */
    create<T extends MentorSessionCreateArgs>(
      args: SelectSubset<T, MentorSessionCreateArgs<ExtArgs>>
    ): Prisma__MentorSessionClient<
      $Result.GetResult<Prisma.$MentorSessionPayload<ExtArgs>, T, 'create'>,
      never,
      ExtArgs
    >;

    /**
     * Create many MentorSessions.
     * @param {MentorSessionCreateManyArgs} args - Arguments to create many MentorSessions.
     * @example
     * // Create many MentorSessions
     * const mentorSession = await prisma.mentorSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends MentorSessionCreateManyArgs>(
      args?: SelectSubset<T, MentorSessionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many MentorSessions and returns the data saved in the database.
     * @param {MentorSessionCreateManyAndReturnArgs} args - Arguments to create many MentorSessions.
     * @example
     * // Create many MentorSessions
     * const mentorSession = await prisma.mentorSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many MentorSessions and only return the `id`
     * const mentorSessionWithIdOnly = await prisma.mentorSession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends MentorSessionCreateManyAndReturnArgs>(
      args?: SelectSubset<T, MentorSessionCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$MentorSessionPayload<ExtArgs>, T, 'createManyAndReturn'>
    >;

    /**
     * Delete a MentorSession.
     * @param {MentorSessionDeleteArgs} args - Arguments to delete one MentorSession.
     * @example
     * // Delete one MentorSession
     * const MentorSession = await prisma.mentorSession.delete({
     *   where: {
     *     // ... filter to delete one MentorSession
     *   }
     * })
     *
     */
    delete<T extends MentorSessionDeleteArgs>(
      args: SelectSubset<T, MentorSessionDeleteArgs<ExtArgs>>
    ): Prisma__MentorSessionClient<
      $Result.GetResult<Prisma.$MentorSessionPayload<ExtArgs>, T, 'delete'>,
      never,
      ExtArgs
    >;

    /**
     * Update one MentorSession.
     * @param {MentorSessionUpdateArgs} args - Arguments to update one MentorSession.
     * @example
     * // Update one MentorSession
     * const mentorSession = await prisma.mentorSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends MentorSessionUpdateArgs>(
      args: SelectSubset<T, MentorSessionUpdateArgs<ExtArgs>>
    ): Prisma__MentorSessionClient<
      $Result.GetResult<Prisma.$MentorSessionPayload<ExtArgs>, T, 'update'>,
      never,
      ExtArgs
    >;

    /**
     * Delete zero or more MentorSessions.
     * @param {MentorSessionDeleteManyArgs} args - Arguments to filter MentorSessions to delete.
     * @example
     * // Delete a few MentorSessions
     * const { count } = await prisma.mentorSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends MentorSessionDeleteManyArgs>(
      args?: SelectSubset<T, MentorSessionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more MentorSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MentorSessions
     * const mentorSession = await prisma.mentorSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends MentorSessionUpdateManyArgs>(
      args: SelectSubset<T, MentorSessionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one MentorSession.
     * @param {MentorSessionUpsertArgs} args - Arguments to update or create a MentorSession.
     * @example
     * // Update or create a MentorSession
     * const mentorSession = await prisma.mentorSession.upsert({
     *   create: {
     *     // ... data to create a MentorSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MentorSession we want to update
     *   }
     * })
     */
    upsert<T extends MentorSessionUpsertArgs>(
      args: SelectSubset<T, MentorSessionUpsertArgs<ExtArgs>>
    ): Prisma__MentorSessionClient<
      $Result.GetResult<Prisma.$MentorSessionPayload<ExtArgs>, T, 'upsert'>,
      never,
      ExtArgs
    >;

    /**
     * Count the number of MentorSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorSessionCountArgs} args - Arguments to filter MentorSessions to count.
     * @example
     * // Count the number of MentorSessions
     * const count = await prisma.mentorSession.count({
     *   where: {
     *     // ... the filter for the MentorSessions we want to count
     *   }
     * })
     **/
    count<T extends MentorSessionCountArgs>(
      args?: Subset<T, MentorSessionCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MentorSessionCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a MentorSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends MentorSessionAggregateArgs>(
      args: Subset<T, MentorSessionAggregateArgs>
    ): Prisma.PrismaPromise<GetMentorSessionAggregateType<T>>;

    /**
     * Group by MentorSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends MentorSessionGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MentorSessionGroupByArgs['orderBy'] }
        : { orderBy?: MentorSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, MentorSessionGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetMentorSessionGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the MentorSession model
     */
    readonly fields: MentorSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MentorSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MentorSessionClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    mentor<T extends MentorDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, MentorDefaultArgs<ExtArgs>>
    ): Prisma__MentorClient<
      $Result.GetResult<Prisma.$MentorPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null,
      Null,
      ExtArgs
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the MentorSession model
   */
  interface MentorSessionFieldRefs {
    readonly id: FieldRef<'MentorSession', 'String'>;
    readonly mentorId: FieldRef<'MentorSession', 'String'>;
    readonly title: FieldRef<'MentorSession', 'String'>;
    readonly startsAt: FieldRef<'MentorSession', 'DateTime'>;
    readonly endsAt: FieldRef<'MentorSession', 'DateTime'>;
    readonly capacity: FieldRef<'MentorSession', 'Int'>;
    readonly booked: FieldRef<'MentorSession', 'Int'>;
    readonly meetingUrl: FieldRef<'MentorSession', 'String'>;
    readonly createdAt: FieldRef<'MentorSession', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * MentorSession findUnique
   */
  export type MentorSessionFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MentorSession
     */
    select?: MentorSessionSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorSessionInclude<ExtArgs> | null;
    /**
     * Filter, which MentorSession to fetch.
     */
    where: MentorSessionWhereUniqueInput;
  };

  /**
   * MentorSession findUniqueOrThrow
   */
  export type MentorSessionFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MentorSession
     */
    select?: MentorSessionSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorSessionInclude<ExtArgs> | null;
    /**
     * Filter, which MentorSession to fetch.
     */
    where: MentorSessionWhereUniqueInput;
  };

  /**
   * MentorSession findFirst
   */
  export type MentorSessionFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MentorSession
     */
    select?: MentorSessionSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorSessionInclude<ExtArgs> | null;
    /**
     * Filter, which MentorSession to fetch.
     */
    where?: MentorSessionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of MentorSessions to fetch.
     */
    orderBy?: MentorSessionOrderByWithRelationInput | MentorSessionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for MentorSessions.
     */
    cursor?: MentorSessionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` MentorSessions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` MentorSessions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of MentorSessions.
     */
    distinct?: MentorSessionScalarFieldEnum | MentorSessionScalarFieldEnum[];
  };

  /**
   * MentorSession findFirstOrThrow
   */
  export type MentorSessionFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MentorSession
     */
    select?: MentorSessionSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorSessionInclude<ExtArgs> | null;
    /**
     * Filter, which MentorSession to fetch.
     */
    where?: MentorSessionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of MentorSessions to fetch.
     */
    orderBy?: MentorSessionOrderByWithRelationInput | MentorSessionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for MentorSessions.
     */
    cursor?: MentorSessionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` MentorSessions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` MentorSessions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of MentorSessions.
     */
    distinct?: MentorSessionScalarFieldEnum | MentorSessionScalarFieldEnum[];
  };

  /**
   * MentorSession findMany
   */
  export type MentorSessionFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MentorSession
     */
    select?: MentorSessionSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorSessionInclude<ExtArgs> | null;
    /**
     * Filter, which MentorSessions to fetch.
     */
    where?: MentorSessionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of MentorSessions to fetch.
     */
    orderBy?: MentorSessionOrderByWithRelationInput | MentorSessionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing MentorSessions.
     */
    cursor?: MentorSessionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` MentorSessions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` MentorSessions.
     */
    skip?: number;
    distinct?: MentorSessionScalarFieldEnum | MentorSessionScalarFieldEnum[];
  };

  /**
   * MentorSession create
   */
  export type MentorSessionCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MentorSession
     */
    select?: MentorSessionSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorSessionInclude<ExtArgs> | null;
    /**
     * The data needed to create a MentorSession.
     */
    data: XOR<MentorSessionCreateInput, MentorSessionUncheckedCreateInput>;
  };

  /**
   * MentorSession createMany
   */
  export type MentorSessionCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many MentorSessions.
     */
    data: MentorSessionCreateManyInput | MentorSessionCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * MentorSession createManyAndReturn
   */
  export type MentorSessionCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MentorSession
     */
    select?: MentorSessionSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * The data used to create many MentorSessions.
     */
    data: MentorSessionCreateManyInput | MentorSessionCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorSessionIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * MentorSession update
   */
  export type MentorSessionUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MentorSession
     */
    select?: MentorSessionSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorSessionInclude<ExtArgs> | null;
    /**
     * The data needed to update a MentorSession.
     */
    data: XOR<MentorSessionUpdateInput, MentorSessionUncheckedUpdateInput>;
    /**
     * Choose, which MentorSession to update.
     */
    where: MentorSessionWhereUniqueInput;
  };

  /**
   * MentorSession updateMany
   */
  export type MentorSessionUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update MentorSessions.
     */
    data: XOR<MentorSessionUpdateManyMutationInput, MentorSessionUncheckedUpdateManyInput>;
    /**
     * Filter which MentorSessions to update
     */
    where?: MentorSessionWhereInput;
  };

  /**
   * MentorSession upsert
   */
  export type MentorSessionUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MentorSession
     */
    select?: MentorSessionSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorSessionInclude<ExtArgs> | null;
    /**
     * The filter to search for the MentorSession to update in case it exists.
     */
    where: MentorSessionWhereUniqueInput;
    /**
     * In case the MentorSession found by the `where` argument doesn't exist, create a new MentorSession with this data.
     */
    create: XOR<MentorSessionCreateInput, MentorSessionUncheckedCreateInput>;
    /**
     * In case the MentorSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MentorSessionUpdateInput, MentorSessionUncheckedUpdateInput>;
  };

  /**
   * MentorSession delete
   */
  export type MentorSessionDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MentorSession
     */
    select?: MentorSessionSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorSessionInclude<ExtArgs> | null;
    /**
     * Filter which MentorSession to delete.
     */
    where: MentorSessionWhereUniqueInput;
  };

  /**
   * MentorSession deleteMany
   */
  export type MentorSessionDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which MentorSessions to delete
     */
    where?: MentorSessionWhereInput;
  };

  /**
   * MentorSession without action
   */
  export type MentorSessionDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the MentorSession
     */
    select?: MentorSessionSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorSessionInclude<ExtArgs> | null;
  };

  /**
   * Model Judge
   */

  export type AggregateJudge = {
    _count: JudgeCountAggregateOutputType | null;
    _min: JudgeMinAggregateOutputType | null;
    _max: JudgeMaxAggregateOutputType | null;
  };

  export type JudgeMinAggregateOutputType = {
    id: string | null;
    userId: string | null;
    hackathonId: string | null;
    bio: string | null;
    createdAt: Date | null;
  };

  export type JudgeMaxAggregateOutputType = {
    id: string | null;
    userId: string | null;
    hackathonId: string | null;
    bio: string | null;
    createdAt: Date | null;
  };

  export type JudgeCountAggregateOutputType = {
    id: number;
    userId: number;
    hackathonId: number;
    bio: number;
    createdAt: number;
    _all: number;
  };

  export type JudgeMinAggregateInputType = {
    id?: true;
    userId?: true;
    hackathonId?: true;
    bio?: true;
    createdAt?: true;
  };

  export type JudgeMaxAggregateInputType = {
    id?: true;
    userId?: true;
    hackathonId?: true;
    bio?: true;
    createdAt?: true;
  };

  export type JudgeCountAggregateInputType = {
    id?: true;
    userId?: true;
    hackathonId?: true;
    bio?: true;
    createdAt?: true;
    _all?: true;
  };

  export type JudgeAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Judge to aggregate.
     */
    where?: JudgeWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Judges to fetch.
     */
    orderBy?: JudgeOrderByWithRelationInput | JudgeOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: JudgeWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Judges from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Judges.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Judges
     **/
    _count?: true | JudgeCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: JudgeMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: JudgeMaxAggregateInputType;
  };

  export type GetJudgeAggregateType<T extends JudgeAggregateArgs> = {
    [P in keyof T & keyof AggregateJudge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJudge[P]>
      : GetScalarType<T[P], AggregateJudge[P]>;
  };

  export type JudgeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      where?: JudgeWhereInput;
      orderBy?: JudgeOrderByWithAggregationInput | JudgeOrderByWithAggregationInput[];
      by: JudgeScalarFieldEnum[] | JudgeScalarFieldEnum;
      having?: JudgeScalarWhereWithAggregatesInput;
      take?: number;
      skip?: number;
      _count?: JudgeCountAggregateInputType | true;
      _min?: JudgeMinAggregateInputType;
      _max?: JudgeMaxAggregateInputType;
    };

  export type JudgeGroupByOutputType = {
    id: string;
    userId: string;
    hackathonId: string;
    bio: string | null;
    createdAt: Date;
    _count: JudgeCountAggregateOutputType | null;
    _min: JudgeMinAggregateOutputType | null;
    _max: JudgeMaxAggregateOutputType | null;
  };

  type GetJudgeGroupByPayload<T extends JudgeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JudgeGroupByOutputType, T['by']> & {
        [P in keyof T & keyof JudgeGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], JudgeGroupByOutputType[P]>
          : GetScalarType<T[P], JudgeGroupByOutputType[P]>;
      }
    >
  >;

  export type JudgeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        userId?: boolean;
        hackathonId?: boolean;
        bio?: boolean;
        createdAt?: boolean;
        user?: boolean | UserDefaultArgs<ExtArgs>;
        hackathon?: boolean | HackathonDefaultArgs<ExtArgs>;
        scores?: boolean | Judge$scoresArgs<ExtArgs>;
        _count?: boolean | JudgeCountOutputTypeDefaultArgs<ExtArgs>;
      },
      ExtArgs['result']['judge']
    >;

  export type JudgeSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      hackathonId?: boolean;
      bio?: boolean;
      createdAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
      hackathon?: boolean | HackathonDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['judge']
  >;

  export type JudgeSelectScalar = {
    id?: boolean;
    userId?: boolean;
    hackathonId?: boolean;
    bio?: boolean;
    createdAt?: boolean;
  };

  export type JudgeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
    hackathon?: boolean | HackathonDefaultArgs<ExtArgs>;
    scores?: boolean | Judge$scoresArgs<ExtArgs>;
    _count?: boolean | JudgeCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type JudgeIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
    hackathon?: boolean | HackathonDefaultArgs<ExtArgs>;
  };

  export type $JudgePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: 'Judge';
    objects: {
      user: Prisma.$UserPayload<ExtArgs>;
      hackathon: Prisma.$HackathonPayload<ExtArgs>;
      scores: Prisma.$ScorePayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        userId: string;
        hackathonId: string;
        bio: string | null;
        createdAt: Date;
      },
      ExtArgs['result']['judge']
    >;
    composites: {};
  };

  type JudgeGetPayload<S extends boolean | null | undefined | JudgeDefaultArgs> = $Result.GetResult<
    Prisma.$JudgePayload,
    S
  >;

  type JudgeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    JudgeFindManyArgs,
    'select' | 'include' | 'distinct'
  > & {
    select?: JudgeCountAggregateInputType | true;
  };

  export interface JudgeDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Judge']; meta: { name: 'Judge' } };
    /**
     * Find zero or one Judge that matches the filter.
     * @param {JudgeFindUniqueArgs} args - Arguments to find a Judge
     * @example
     * // Get one Judge
     * const judge = await prisma.judge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JudgeFindUniqueArgs>(
      args: SelectSubset<T, JudgeFindUniqueArgs<ExtArgs>>
    ): Prisma__JudgeClient<
      $Result.GetResult<Prisma.$JudgePayload<ExtArgs>, T, 'findUnique'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find one Judge that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JudgeFindUniqueOrThrowArgs} args - Arguments to find a Judge
     * @example
     * // Get one Judge
     * const judge = await prisma.judge.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JudgeFindUniqueOrThrowArgs>(
      args: SelectSubset<T, JudgeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__JudgeClient<
      $Result.GetResult<Prisma.$JudgePayload<ExtArgs>, T, 'findUniqueOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find the first Judge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JudgeFindFirstArgs} args - Arguments to find a Judge
     * @example
     * // Get one Judge
     * const judge = await prisma.judge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JudgeFindFirstArgs>(
      args?: SelectSubset<T, JudgeFindFirstArgs<ExtArgs>>
    ): Prisma__JudgeClient<
      $Result.GetResult<Prisma.$JudgePayload<ExtArgs>, T, 'findFirst'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find the first Judge that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JudgeFindFirstOrThrowArgs} args - Arguments to find a Judge
     * @example
     * // Get one Judge
     * const judge = await prisma.judge.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JudgeFindFirstOrThrowArgs>(
      args?: SelectSubset<T, JudgeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__JudgeClient<
      $Result.GetResult<Prisma.$JudgePayload<ExtArgs>, T, 'findFirstOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more Judges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JudgeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Judges
     * const judges = await prisma.judge.findMany()
     *
     * // Get first 10 Judges
     * const judges = await prisma.judge.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const judgeWithIdOnly = await prisma.judge.findMany({ select: { id: true } })
     *
     */
    findMany<T extends JudgeFindManyArgs>(
      args?: SelectSubset<T, JudgeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JudgePayload<ExtArgs>, T, 'findMany'>>;

    /**
     * Create a Judge.
     * @param {JudgeCreateArgs} args - Arguments to create a Judge.
     * @example
     * // Create one Judge
     * const Judge = await prisma.judge.create({
     *   data: {
     *     // ... data to create a Judge
     *   }
     * })
     *
     */
    create<T extends JudgeCreateArgs>(
      args: SelectSubset<T, JudgeCreateArgs<ExtArgs>>
    ): Prisma__JudgeClient<
      $Result.GetResult<Prisma.$JudgePayload<ExtArgs>, T, 'create'>,
      never,
      ExtArgs
    >;

    /**
     * Create many Judges.
     * @param {JudgeCreateManyArgs} args - Arguments to create many Judges.
     * @example
     * // Create many Judges
     * const judge = await prisma.judge.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends JudgeCreateManyArgs>(
      args?: SelectSubset<T, JudgeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Judges and returns the data saved in the database.
     * @param {JudgeCreateManyAndReturnArgs} args - Arguments to create many Judges.
     * @example
     * // Create many Judges
     * const judge = await prisma.judge.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Judges and only return the `id`
     * const judgeWithIdOnly = await prisma.judge.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends JudgeCreateManyAndReturnArgs>(
      args?: SelectSubset<T, JudgeCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$JudgePayload<ExtArgs>, T, 'createManyAndReturn'>
    >;

    /**
     * Delete a Judge.
     * @param {JudgeDeleteArgs} args - Arguments to delete one Judge.
     * @example
     * // Delete one Judge
     * const Judge = await prisma.judge.delete({
     *   where: {
     *     // ... filter to delete one Judge
     *   }
     * })
     *
     */
    delete<T extends JudgeDeleteArgs>(
      args: SelectSubset<T, JudgeDeleteArgs<ExtArgs>>
    ): Prisma__JudgeClient<
      $Result.GetResult<Prisma.$JudgePayload<ExtArgs>, T, 'delete'>,
      never,
      ExtArgs
    >;

    /**
     * Update one Judge.
     * @param {JudgeUpdateArgs} args - Arguments to update one Judge.
     * @example
     * // Update one Judge
     * const judge = await prisma.judge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends JudgeUpdateArgs>(
      args: SelectSubset<T, JudgeUpdateArgs<ExtArgs>>
    ): Prisma__JudgeClient<
      $Result.GetResult<Prisma.$JudgePayload<ExtArgs>, T, 'update'>,
      never,
      ExtArgs
    >;

    /**
     * Delete zero or more Judges.
     * @param {JudgeDeleteManyArgs} args - Arguments to filter Judges to delete.
     * @example
     * // Delete a few Judges
     * const { count } = await prisma.judge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends JudgeDeleteManyArgs>(
      args?: SelectSubset<T, JudgeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Judges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JudgeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Judges
     * const judge = await prisma.judge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends JudgeUpdateManyArgs>(
      args: SelectSubset<T, JudgeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Judge.
     * @param {JudgeUpsertArgs} args - Arguments to update or create a Judge.
     * @example
     * // Update or create a Judge
     * const judge = await prisma.judge.upsert({
     *   create: {
     *     // ... data to create a Judge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Judge we want to update
     *   }
     * })
     */
    upsert<T extends JudgeUpsertArgs>(
      args: SelectSubset<T, JudgeUpsertArgs<ExtArgs>>
    ): Prisma__JudgeClient<
      $Result.GetResult<Prisma.$JudgePayload<ExtArgs>, T, 'upsert'>,
      never,
      ExtArgs
    >;

    /**
     * Count the number of Judges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JudgeCountArgs} args - Arguments to filter Judges to count.
     * @example
     * // Count the number of Judges
     * const count = await prisma.judge.count({
     *   where: {
     *     // ... the filter for the Judges we want to count
     *   }
     * })
     **/
    count<T extends JudgeCountArgs>(
      args?: Subset<T, JudgeCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JudgeCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Judge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JudgeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends JudgeAggregateArgs>(
      args: Subset<T, JudgeAggregateArgs>
    ): Prisma.PrismaPromise<GetJudgeAggregateType<T>>;

    /**
     * Group by Judge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JudgeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends JudgeGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JudgeGroupByArgs['orderBy'] }
        : { orderBy?: JudgeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, JudgeGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetJudgeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Judge model
     */
    readonly fields: JudgeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Judge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JudgeClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null,
      Null,
      ExtArgs
    >;
    hackathon<T extends HackathonDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, HackathonDefaultArgs<ExtArgs>>
    ): Prisma__HackathonClient<
      $Result.GetResult<Prisma.$HackathonPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null,
      Null,
      ExtArgs
    >;
    scores<T extends Judge$scoresArgs<ExtArgs> = {}>(
      args?: Subset<T, Judge$scoresArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScorePayload<ExtArgs>, T, 'findMany'> | Null>;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Judge model
   */
  interface JudgeFieldRefs {
    readonly id: FieldRef<'Judge', 'String'>;
    readonly userId: FieldRef<'Judge', 'String'>;
    readonly hackathonId: FieldRef<'Judge', 'String'>;
    readonly bio: FieldRef<'Judge', 'String'>;
    readonly createdAt: FieldRef<'Judge', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * Judge findUnique
   */
  export type JudgeFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Judge
     */
    select?: JudgeSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JudgeInclude<ExtArgs> | null;
    /**
     * Filter, which Judge to fetch.
     */
    where: JudgeWhereUniqueInput;
  };

  /**
   * Judge findUniqueOrThrow
   */
  export type JudgeFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Judge
     */
    select?: JudgeSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JudgeInclude<ExtArgs> | null;
    /**
     * Filter, which Judge to fetch.
     */
    where: JudgeWhereUniqueInput;
  };

  /**
   * Judge findFirst
   */
  export type JudgeFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Judge
     */
    select?: JudgeSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JudgeInclude<ExtArgs> | null;
    /**
     * Filter, which Judge to fetch.
     */
    where?: JudgeWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Judges to fetch.
     */
    orderBy?: JudgeOrderByWithRelationInput | JudgeOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Judges.
     */
    cursor?: JudgeWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Judges from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Judges.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Judges.
     */
    distinct?: JudgeScalarFieldEnum | JudgeScalarFieldEnum[];
  };

  /**
   * Judge findFirstOrThrow
   */
  export type JudgeFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Judge
     */
    select?: JudgeSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JudgeInclude<ExtArgs> | null;
    /**
     * Filter, which Judge to fetch.
     */
    where?: JudgeWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Judges to fetch.
     */
    orderBy?: JudgeOrderByWithRelationInput | JudgeOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Judges.
     */
    cursor?: JudgeWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Judges from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Judges.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Judges.
     */
    distinct?: JudgeScalarFieldEnum | JudgeScalarFieldEnum[];
  };

  /**
   * Judge findMany
   */
  export type JudgeFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Judge
     */
    select?: JudgeSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JudgeInclude<ExtArgs> | null;
    /**
     * Filter, which Judges to fetch.
     */
    where?: JudgeWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Judges to fetch.
     */
    orderBy?: JudgeOrderByWithRelationInput | JudgeOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Judges.
     */
    cursor?: JudgeWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Judges from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Judges.
     */
    skip?: number;
    distinct?: JudgeScalarFieldEnum | JudgeScalarFieldEnum[];
  };

  /**
   * Judge create
   */
  export type JudgeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the Judge
       */
      select?: JudgeSelect<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: JudgeInclude<ExtArgs> | null;
      /**
       * The data needed to create a Judge.
       */
      data: XOR<JudgeCreateInput, JudgeUncheckedCreateInput>;
    };

  /**
   * Judge createMany
   */
  export type JudgeCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Judges.
     */
    data: JudgeCreateManyInput | JudgeCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Judge createManyAndReturn
   */
  export type JudgeCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Judge
     */
    select?: JudgeSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * The data used to create many Judges.
     */
    data: JudgeCreateManyInput | JudgeCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JudgeIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Judge update
   */
  export type JudgeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the Judge
       */
      select?: JudgeSelect<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: JudgeInclude<ExtArgs> | null;
      /**
       * The data needed to update a Judge.
       */
      data: XOR<JudgeUpdateInput, JudgeUncheckedUpdateInput>;
      /**
       * Choose, which Judge to update.
       */
      where: JudgeWhereUniqueInput;
    };

  /**
   * Judge updateMany
   */
  export type JudgeUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Judges.
     */
    data: XOR<JudgeUpdateManyMutationInput, JudgeUncheckedUpdateManyInput>;
    /**
     * Filter which Judges to update
     */
    where?: JudgeWhereInput;
  };

  /**
   * Judge upsert
   */
  export type JudgeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the Judge
       */
      select?: JudgeSelect<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: JudgeInclude<ExtArgs> | null;
      /**
       * The filter to search for the Judge to update in case it exists.
       */
      where: JudgeWhereUniqueInput;
      /**
       * In case the Judge found by the `where` argument doesn't exist, create a new Judge with this data.
       */
      create: XOR<JudgeCreateInput, JudgeUncheckedCreateInput>;
      /**
       * In case the Judge was found with the provided `where` argument, update it with this data.
       */
      update: XOR<JudgeUpdateInput, JudgeUncheckedUpdateInput>;
    };

  /**
   * Judge delete
   */
  export type JudgeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the Judge
       */
      select?: JudgeSelect<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: JudgeInclude<ExtArgs> | null;
      /**
       * Filter which Judge to delete.
       */
      where: JudgeWhereUniqueInput;
    };

  /**
   * Judge deleteMany
   */
  export type JudgeDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Judges to delete
     */
    where?: JudgeWhereInput;
  };

  /**
   * Judge.scores
   */
  export type Judge$scoresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the Score
       */
      select?: ScoreSelect<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: ScoreInclude<ExtArgs> | null;
      where?: ScoreWhereInput;
      orderBy?: ScoreOrderByWithRelationInput | ScoreOrderByWithRelationInput[];
      cursor?: ScoreWhereUniqueInput;
      take?: number;
      skip?: number;
      distinct?: ScoreScalarFieldEnum | ScoreScalarFieldEnum[];
    };

  /**
   * Judge without action
   */
  export type JudgeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the Judge
       */
      select?: JudgeSelect<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: JudgeInclude<ExtArgs> | null;
    };

  /**
   * Model Criteria
   */

  export type AggregateCriteria = {
    _count: CriteriaCountAggregateOutputType | null;
    _avg: CriteriaAvgAggregateOutputType | null;
    _sum: CriteriaSumAggregateOutputType | null;
    _min: CriteriaMinAggregateOutputType | null;
    _max: CriteriaMaxAggregateOutputType | null;
  };

  export type CriteriaAvgAggregateOutputType = {
    maxScore: number | null;
    weight: Decimal | null;
    order: number | null;
  };

  export type CriteriaSumAggregateOutputType = {
    maxScore: number | null;
    weight: Decimal | null;
    order: number | null;
  };

  export type CriteriaMinAggregateOutputType = {
    id: string | null;
    hackathonId: string | null;
    name: string | null;
    description: string | null;
    maxScore: number | null;
    weight: Decimal | null;
    order: number | null;
  };

  export type CriteriaMaxAggregateOutputType = {
    id: string | null;
    hackathonId: string | null;
    name: string | null;
    description: string | null;
    maxScore: number | null;
    weight: Decimal | null;
    order: number | null;
  };

  export type CriteriaCountAggregateOutputType = {
    id: number;
    hackathonId: number;
    name: number;
    description: number;
    maxScore: number;
    weight: number;
    order: number;
    _all: number;
  };

  export type CriteriaAvgAggregateInputType = {
    maxScore?: true;
    weight?: true;
    order?: true;
  };

  export type CriteriaSumAggregateInputType = {
    maxScore?: true;
    weight?: true;
    order?: true;
  };

  export type CriteriaMinAggregateInputType = {
    id?: true;
    hackathonId?: true;
    name?: true;
    description?: true;
    maxScore?: true;
    weight?: true;
    order?: true;
  };

  export type CriteriaMaxAggregateInputType = {
    id?: true;
    hackathonId?: true;
    name?: true;
    description?: true;
    maxScore?: true;
    weight?: true;
    order?: true;
  };

  export type CriteriaCountAggregateInputType = {
    id?: true;
    hackathonId?: true;
    name?: true;
    description?: true;
    maxScore?: true;
    weight?: true;
    order?: true;
    _all?: true;
  };

  export type CriteriaAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Criteria to aggregate.
     */
    where?: CriteriaWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Criteria to fetch.
     */
    orderBy?: CriteriaOrderByWithRelationInput | CriteriaOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: CriteriaWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Criteria from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Criteria.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Criteria
     **/
    _count?: true | CriteriaCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: CriteriaAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: CriteriaSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: CriteriaMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: CriteriaMaxAggregateInputType;
  };

  export type GetCriteriaAggregateType<T extends CriteriaAggregateArgs> = {
    [P in keyof T & keyof AggregateCriteria]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCriteria[P]>
      : GetScalarType<T[P], AggregateCriteria[P]>;
  };

  export type CriteriaGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: CriteriaWhereInput;
    orderBy?: CriteriaOrderByWithAggregationInput | CriteriaOrderByWithAggregationInput[];
    by: CriteriaScalarFieldEnum[] | CriteriaScalarFieldEnum;
    having?: CriteriaScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: CriteriaCountAggregateInputType | true;
    _avg?: CriteriaAvgAggregateInputType;
    _sum?: CriteriaSumAggregateInputType;
    _min?: CriteriaMinAggregateInputType;
    _max?: CriteriaMaxAggregateInputType;
  };

  export type CriteriaGroupByOutputType = {
    id: string;
    hackathonId: string;
    name: string;
    description: string | null;
    maxScore: number;
    weight: Decimal;
    order: number;
    _count: CriteriaCountAggregateOutputType | null;
    _avg: CriteriaAvgAggregateOutputType | null;
    _sum: CriteriaSumAggregateOutputType | null;
    _min: CriteriaMinAggregateOutputType | null;
    _max: CriteriaMaxAggregateOutputType | null;
  };

  type GetCriteriaGroupByPayload<T extends CriteriaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CriteriaGroupByOutputType, T['by']> & {
        [P in keyof T & keyof CriteriaGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], CriteriaGroupByOutputType[P]>
          : GetScalarType<T[P], CriteriaGroupByOutputType[P]>;
      }
    >
  >;

  export type CriteriaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        hackathonId?: boolean;
        name?: boolean;
        description?: boolean;
        maxScore?: boolean;
        weight?: boolean;
        order?: boolean;
        hackathon?: boolean | HackathonDefaultArgs<ExtArgs>;
        scores?: boolean | Criteria$scoresArgs<ExtArgs>;
        _count?: boolean | CriteriaCountOutputTypeDefaultArgs<ExtArgs>;
      },
      ExtArgs['result']['criteria']
    >;

  export type CriteriaSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      hackathonId?: boolean;
      name?: boolean;
      description?: boolean;
      maxScore?: boolean;
      weight?: boolean;
      order?: boolean;
      hackathon?: boolean | HackathonDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['criteria']
  >;

  export type CriteriaSelectScalar = {
    id?: boolean;
    hackathonId?: boolean;
    name?: boolean;
    description?: boolean;
    maxScore?: boolean;
    weight?: boolean;
    order?: boolean;
  };

  export type CriteriaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      hackathon?: boolean | HackathonDefaultArgs<ExtArgs>;
      scores?: boolean | Criteria$scoresArgs<ExtArgs>;
      _count?: boolean | CriteriaCountOutputTypeDefaultArgs<ExtArgs>;
    };
  export type CriteriaIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    hackathon?: boolean | HackathonDefaultArgs<ExtArgs>;
  };

  export type $CriteriaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      name: 'Criteria';
      objects: {
        hackathon: Prisma.$HackathonPayload<ExtArgs>;
        scores: Prisma.$ScorePayload<ExtArgs>[];
      };
      scalars: $Extensions.GetPayloadResult<
        {
          id: string;
          hackathonId: string;
          name: string;
          description: string | null;
          maxScore: number;
          weight: Prisma.Decimal;
          order: number;
        },
        ExtArgs['result']['criteria']
      >;
      composites: {};
    };

  type CriteriaGetPayload<S extends boolean | null | undefined | CriteriaDefaultArgs> =
    $Result.GetResult<Prisma.$CriteriaPayload, S>;

  type CriteriaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    CriteriaFindManyArgs,
    'select' | 'include' | 'distinct'
  > & {
    select?: CriteriaCountAggregateInputType | true;
  };

  export interface CriteriaDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Criteria'];
      meta: { name: 'Criteria' };
    };
    /**
     * Find zero or one Criteria that matches the filter.
     * @param {CriteriaFindUniqueArgs} args - Arguments to find a Criteria
     * @example
     * // Get one Criteria
     * const criteria = await prisma.criteria.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CriteriaFindUniqueArgs>(
      args: SelectSubset<T, CriteriaFindUniqueArgs<ExtArgs>>
    ): Prisma__CriteriaClient<
      $Result.GetResult<Prisma.$CriteriaPayload<ExtArgs>, T, 'findUnique'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find one Criteria that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CriteriaFindUniqueOrThrowArgs} args - Arguments to find a Criteria
     * @example
     * // Get one Criteria
     * const criteria = await prisma.criteria.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CriteriaFindUniqueOrThrowArgs>(
      args: SelectSubset<T, CriteriaFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CriteriaClient<
      $Result.GetResult<Prisma.$CriteriaPayload<ExtArgs>, T, 'findUniqueOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find the first Criteria that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CriteriaFindFirstArgs} args - Arguments to find a Criteria
     * @example
     * // Get one Criteria
     * const criteria = await prisma.criteria.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CriteriaFindFirstArgs>(
      args?: SelectSubset<T, CriteriaFindFirstArgs<ExtArgs>>
    ): Prisma__CriteriaClient<
      $Result.GetResult<Prisma.$CriteriaPayload<ExtArgs>, T, 'findFirst'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find the first Criteria that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CriteriaFindFirstOrThrowArgs} args - Arguments to find a Criteria
     * @example
     * // Get one Criteria
     * const criteria = await prisma.criteria.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CriteriaFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CriteriaFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CriteriaClient<
      $Result.GetResult<Prisma.$CriteriaPayload<ExtArgs>, T, 'findFirstOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more Criteria that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CriteriaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Criteria
     * const criteria = await prisma.criteria.findMany()
     *
     * // Get first 10 Criteria
     * const criteria = await prisma.criteria.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const criteriaWithIdOnly = await prisma.criteria.findMany({ select: { id: true } })
     *
     */
    findMany<T extends CriteriaFindManyArgs>(
      args?: SelectSubset<T, CriteriaFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CriteriaPayload<ExtArgs>, T, 'findMany'>>;

    /**
     * Create a Criteria.
     * @param {CriteriaCreateArgs} args - Arguments to create a Criteria.
     * @example
     * // Create one Criteria
     * const Criteria = await prisma.criteria.create({
     *   data: {
     *     // ... data to create a Criteria
     *   }
     * })
     *
     */
    create<T extends CriteriaCreateArgs>(
      args: SelectSubset<T, CriteriaCreateArgs<ExtArgs>>
    ): Prisma__CriteriaClient<
      $Result.GetResult<Prisma.$CriteriaPayload<ExtArgs>, T, 'create'>,
      never,
      ExtArgs
    >;

    /**
     * Create many Criteria.
     * @param {CriteriaCreateManyArgs} args - Arguments to create many Criteria.
     * @example
     * // Create many Criteria
     * const criteria = await prisma.criteria.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends CriteriaCreateManyArgs>(
      args?: SelectSubset<T, CriteriaCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Criteria and returns the data saved in the database.
     * @param {CriteriaCreateManyAndReturnArgs} args - Arguments to create many Criteria.
     * @example
     * // Create many Criteria
     * const criteria = await prisma.criteria.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Criteria and only return the `id`
     * const criteriaWithIdOnly = await prisma.criteria.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends CriteriaCreateManyAndReturnArgs>(
      args?: SelectSubset<T, CriteriaCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$CriteriaPayload<ExtArgs>, T, 'createManyAndReturn'>
    >;

    /**
     * Delete a Criteria.
     * @param {CriteriaDeleteArgs} args - Arguments to delete one Criteria.
     * @example
     * // Delete one Criteria
     * const Criteria = await prisma.criteria.delete({
     *   where: {
     *     // ... filter to delete one Criteria
     *   }
     * })
     *
     */
    delete<T extends CriteriaDeleteArgs>(
      args: SelectSubset<T, CriteriaDeleteArgs<ExtArgs>>
    ): Prisma__CriteriaClient<
      $Result.GetResult<Prisma.$CriteriaPayload<ExtArgs>, T, 'delete'>,
      never,
      ExtArgs
    >;

    /**
     * Update one Criteria.
     * @param {CriteriaUpdateArgs} args - Arguments to update one Criteria.
     * @example
     * // Update one Criteria
     * const criteria = await prisma.criteria.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends CriteriaUpdateArgs>(
      args: SelectSubset<T, CriteriaUpdateArgs<ExtArgs>>
    ): Prisma__CriteriaClient<
      $Result.GetResult<Prisma.$CriteriaPayload<ExtArgs>, T, 'update'>,
      never,
      ExtArgs
    >;

    /**
     * Delete zero or more Criteria.
     * @param {CriteriaDeleteManyArgs} args - Arguments to filter Criteria to delete.
     * @example
     * // Delete a few Criteria
     * const { count } = await prisma.criteria.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends CriteriaDeleteManyArgs>(
      args?: SelectSubset<T, CriteriaDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Criteria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CriteriaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Criteria
     * const criteria = await prisma.criteria.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends CriteriaUpdateManyArgs>(
      args: SelectSubset<T, CriteriaUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Criteria.
     * @param {CriteriaUpsertArgs} args - Arguments to update or create a Criteria.
     * @example
     * // Update or create a Criteria
     * const criteria = await prisma.criteria.upsert({
     *   create: {
     *     // ... data to create a Criteria
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Criteria we want to update
     *   }
     * })
     */
    upsert<T extends CriteriaUpsertArgs>(
      args: SelectSubset<T, CriteriaUpsertArgs<ExtArgs>>
    ): Prisma__CriteriaClient<
      $Result.GetResult<Prisma.$CriteriaPayload<ExtArgs>, T, 'upsert'>,
      never,
      ExtArgs
    >;

    /**
     * Count the number of Criteria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CriteriaCountArgs} args - Arguments to filter Criteria to count.
     * @example
     * // Count the number of Criteria
     * const count = await prisma.criteria.count({
     *   where: {
     *     // ... the filter for the Criteria we want to count
     *   }
     * })
     **/
    count<T extends CriteriaCountArgs>(
      args?: Subset<T, CriteriaCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CriteriaCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Criteria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CriteriaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends CriteriaAggregateArgs>(
      args: Subset<T, CriteriaAggregateArgs>
    ): Prisma.PrismaPromise<GetCriteriaAggregateType<T>>;

    /**
     * Group by Criteria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CriteriaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends CriteriaGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CriteriaGroupByArgs['orderBy'] }
        : { orderBy?: CriteriaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, CriteriaGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetCriteriaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Criteria model
     */
    readonly fields: CriteriaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Criteria.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CriteriaClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    hackathon<T extends HackathonDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, HackathonDefaultArgs<ExtArgs>>
    ): Prisma__HackathonClient<
      $Result.GetResult<Prisma.$HackathonPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null,
      Null,
      ExtArgs
    >;
    scores<T extends Criteria$scoresArgs<ExtArgs> = {}>(
      args?: Subset<T, Criteria$scoresArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScorePayload<ExtArgs>, T, 'findMany'> | Null>;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Criteria model
   */
  interface CriteriaFieldRefs {
    readonly id: FieldRef<'Criteria', 'String'>;
    readonly hackathonId: FieldRef<'Criteria', 'String'>;
    readonly name: FieldRef<'Criteria', 'String'>;
    readonly description: FieldRef<'Criteria', 'String'>;
    readonly maxScore: FieldRef<'Criteria', 'Int'>;
    readonly weight: FieldRef<'Criteria', 'Decimal'>;
    readonly order: FieldRef<'Criteria', 'Int'>;
  }

  // Custom InputTypes
  /**
   * Criteria findUnique
   */
  export type CriteriaFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Criteria
     */
    select?: CriteriaSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CriteriaInclude<ExtArgs> | null;
    /**
     * Filter, which Criteria to fetch.
     */
    where: CriteriaWhereUniqueInput;
  };

  /**
   * Criteria findUniqueOrThrow
   */
  export type CriteriaFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Criteria
     */
    select?: CriteriaSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CriteriaInclude<ExtArgs> | null;
    /**
     * Filter, which Criteria to fetch.
     */
    where: CriteriaWhereUniqueInput;
  };

  /**
   * Criteria findFirst
   */
  export type CriteriaFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Criteria
     */
    select?: CriteriaSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CriteriaInclude<ExtArgs> | null;
    /**
     * Filter, which Criteria to fetch.
     */
    where?: CriteriaWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Criteria to fetch.
     */
    orderBy?: CriteriaOrderByWithRelationInput | CriteriaOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Criteria.
     */
    cursor?: CriteriaWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Criteria from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Criteria.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Criteria.
     */
    distinct?: CriteriaScalarFieldEnum | CriteriaScalarFieldEnum[];
  };

  /**
   * Criteria findFirstOrThrow
   */
  export type CriteriaFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Criteria
     */
    select?: CriteriaSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CriteriaInclude<ExtArgs> | null;
    /**
     * Filter, which Criteria to fetch.
     */
    where?: CriteriaWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Criteria to fetch.
     */
    orderBy?: CriteriaOrderByWithRelationInput | CriteriaOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Criteria.
     */
    cursor?: CriteriaWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Criteria from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Criteria.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Criteria.
     */
    distinct?: CriteriaScalarFieldEnum | CriteriaScalarFieldEnum[];
  };

  /**
   * Criteria findMany
   */
  export type CriteriaFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Criteria
     */
    select?: CriteriaSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CriteriaInclude<ExtArgs> | null;
    /**
     * Filter, which Criteria to fetch.
     */
    where?: CriteriaWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Criteria to fetch.
     */
    orderBy?: CriteriaOrderByWithRelationInput | CriteriaOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Criteria.
     */
    cursor?: CriteriaWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Criteria from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Criteria.
     */
    skip?: number;
    distinct?: CriteriaScalarFieldEnum | CriteriaScalarFieldEnum[];
  };

  /**
   * Criteria create
   */
  export type CriteriaCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Criteria
     */
    select?: CriteriaSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CriteriaInclude<ExtArgs> | null;
    /**
     * The data needed to create a Criteria.
     */
    data: XOR<CriteriaCreateInput, CriteriaUncheckedCreateInput>;
  };

  /**
   * Criteria createMany
   */
  export type CriteriaCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Criteria.
     */
    data: CriteriaCreateManyInput | CriteriaCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Criteria createManyAndReturn
   */
  export type CriteriaCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Criteria
     */
    select?: CriteriaSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * The data used to create many Criteria.
     */
    data: CriteriaCreateManyInput | CriteriaCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CriteriaIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Criteria update
   */
  export type CriteriaUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Criteria
     */
    select?: CriteriaSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CriteriaInclude<ExtArgs> | null;
    /**
     * The data needed to update a Criteria.
     */
    data: XOR<CriteriaUpdateInput, CriteriaUncheckedUpdateInput>;
    /**
     * Choose, which Criteria to update.
     */
    where: CriteriaWhereUniqueInput;
  };

  /**
   * Criteria updateMany
   */
  export type CriteriaUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Criteria.
     */
    data: XOR<CriteriaUpdateManyMutationInput, CriteriaUncheckedUpdateManyInput>;
    /**
     * Filter which Criteria to update
     */
    where?: CriteriaWhereInput;
  };

  /**
   * Criteria upsert
   */
  export type CriteriaUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Criteria
     */
    select?: CriteriaSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CriteriaInclude<ExtArgs> | null;
    /**
     * The filter to search for the Criteria to update in case it exists.
     */
    where: CriteriaWhereUniqueInput;
    /**
     * In case the Criteria found by the `where` argument doesn't exist, create a new Criteria with this data.
     */
    create: XOR<CriteriaCreateInput, CriteriaUncheckedCreateInput>;
    /**
     * In case the Criteria was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CriteriaUpdateInput, CriteriaUncheckedUpdateInput>;
  };

  /**
   * Criteria delete
   */
  export type CriteriaDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Criteria
     */
    select?: CriteriaSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CriteriaInclude<ExtArgs> | null;
    /**
     * Filter which Criteria to delete.
     */
    where: CriteriaWhereUniqueInput;
  };

  /**
   * Criteria deleteMany
   */
  export type CriteriaDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Criteria to delete
     */
    where?: CriteriaWhereInput;
  };

  /**
   * Criteria.scores
   */
  export type Criteria$scoresArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Score
     */
    select?: ScoreSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoreInclude<ExtArgs> | null;
    where?: ScoreWhereInput;
    orderBy?: ScoreOrderByWithRelationInput | ScoreOrderByWithRelationInput[];
    cursor?: ScoreWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ScoreScalarFieldEnum | ScoreScalarFieldEnum[];
  };

  /**
   * Criteria without action
   */
  export type CriteriaDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Criteria
     */
    select?: CriteriaSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CriteriaInclude<ExtArgs> | null;
  };

  /**
   * Model Submission
   */

  export type AggregateSubmission = {
    _count: SubmissionCountAggregateOutputType | null;
    _avg: SubmissionAvgAggregateOutputType | null;
    _sum: SubmissionSumAggregateOutputType | null;
    _min: SubmissionMinAggregateOutputType | null;
    _max: SubmissionMaxAggregateOutputType | null;
  };

  export type SubmissionAvgAggregateOutputType = {
    scoreAggregate: Decimal | null;
    rank: number | null;
  };

  export type SubmissionSumAggregateOutputType = {
    scoreAggregate: Decimal | null;
    rank: number | null;
  };

  export type SubmissionMinAggregateOutputType = {
    id: string | null;
    hackathonId: string | null;
    teamId: string | null;
    trackId: string | null;
    title: string | null;
    abstract: string | null;
    repoUrl: string | null;
    demoUrl: string | null;
    videoUrl: string | null;
    submittedAt: Date | null;
    finalizedAt: Date | null;
    status: $Enums.SubmissionStatus | null;
    scoreAggregate: Decimal | null;
    rank: number | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type SubmissionMaxAggregateOutputType = {
    id: string | null;
    hackathonId: string | null;
    teamId: string | null;
    trackId: string | null;
    title: string | null;
    abstract: string | null;
    repoUrl: string | null;
    demoUrl: string | null;
    videoUrl: string | null;
    submittedAt: Date | null;
    finalizedAt: Date | null;
    status: $Enums.SubmissionStatus | null;
    scoreAggregate: Decimal | null;
    rank: number | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type SubmissionCountAggregateOutputType = {
    id: number;
    hackathonId: number;
    teamId: number;
    trackId: number;
    title: number;
    abstract: number;
    repoUrl: number;
    demoUrl: number;
    videoUrl: number;
    files: number;
    submittedAt: number;
    finalizedAt: number;
    status: number;
    scoreAggregate: number;
    rank: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type SubmissionAvgAggregateInputType = {
    scoreAggregate?: true;
    rank?: true;
  };

  export type SubmissionSumAggregateInputType = {
    scoreAggregate?: true;
    rank?: true;
  };

  export type SubmissionMinAggregateInputType = {
    id?: true;
    hackathonId?: true;
    teamId?: true;
    trackId?: true;
    title?: true;
    abstract?: true;
    repoUrl?: true;
    demoUrl?: true;
    videoUrl?: true;
    submittedAt?: true;
    finalizedAt?: true;
    status?: true;
    scoreAggregate?: true;
    rank?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type SubmissionMaxAggregateInputType = {
    id?: true;
    hackathonId?: true;
    teamId?: true;
    trackId?: true;
    title?: true;
    abstract?: true;
    repoUrl?: true;
    demoUrl?: true;
    videoUrl?: true;
    submittedAt?: true;
    finalizedAt?: true;
    status?: true;
    scoreAggregate?: true;
    rank?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type SubmissionCountAggregateInputType = {
    id?: true;
    hackathonId?: true;
    teamId?: true;
    trackId?: true;
    title?: true;
    abstract?: true;
    repoUrl?: true;
    demoUrl?: true;
    videoUrl?: true;
    files?: true;
    submittedAt?: true;
    finalizedAt?: true;
    status?: true;
    scoreAggregate?: true;
    rank?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type SubmissionAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Submission to aggregate.
     */
    where?: SubmissionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Submissions to fetch.
     */
    orderBy?: SubmissionOrderByWithRelationInput | SubmissionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: SubmissionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Submissions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Submissions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Submissions
     **/
    _count?: true | SubmissionCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: SubmissionAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: SubmissionSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: SubmissionMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: SubmissionMaxAggregateInputType;
  };

  export type GetSubmissionAggregateType<T extends SubmissionAggregateArgs> = {
    [P in keyof T & keyof AggregateSubmission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubmission[P]>
      : GetScalarType<T[P], AggregateSubmission[P]>;
  };

  export type SubmissionGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: SubmissionWhereInput;
    orderBy?: SubmissionOrderByWithAggregationInput | SubmissionOrderByWithAggregationInput[];
    by: SubmissionScalarFieldEnum[] | SubmissionScalarFieldEnum;
    having?: SubmissionScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: SubmissionCountAggregateInputType | true;
    _avg?: SubmissionAvgAggregateInputType;
    _sum?: SubmissionSumAggregateInputType;
    _min?: SubmissionMinAggregateInputType;
    _max?: SubmissionMaxAggregateInputType;
  };

  export type SubmissionGroupByOutputType = {
    id: string;
    hackathonId: string;
    teamId: string;
    trackId: string | null;
    title: string;
    abstract: string;
    repoUrl: string | null;
    demoUrl: string | null;
    videoUrl: string | null;
    files: string[];
    submittedAt: Date | null;
    finalizedAt: Date | null;
    status: $Enums.SubmissionStatus;
    scoreAggregate: Decimal | null;
    rank: number | null;
    createdAt: Date;
    updatedAt: Date;
    _count: SubmissionCountAggregateOutputType | null;
    _avg: SubmissionAvgAggregateOutputType | null;
    _sum: SubmissionSumAggregateOutputType | null;
    _min: SubmissionMinAggregateOutputType | null;
    _max: SubmissionMaxAggregateOutputType | null;
  };

  type GetSubmissionGroupByPayload<T extends SubmissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubmissionGroupByOutputType, T['by']> & {
        [P in keyof T & keyof SubmissionGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], SubmissionGroupByOutputType[P]>
          : GetScalarType<T[P], SubmissionGroupByOutputType[P]>;
      }
    >
  >;

  export type SubmissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        hackathonId?: boolean;
        teamId?: boolean;
        trackId?: boolean;
        title?: boolean;
        abstract?: boolean;
        repoUrl?: boolean;
        demoUrl?: boolean;
        videoUrl?: boolean;
        files?: boolean;
        submittedAt?: boolean;
        finalizedAt?: boolean;
        status?: boolean;
        scoreAggregate?: boolean;
        rank?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        hackathon?: boolean | HackathonDefaultArgs<ExtArgs>;
        team?: boolean | TeamDefaultArgs<ExtArgs>;
        track?: boolean | Submission$trackArgs<ExtArgs>;
        scores?: boolean | Submission$scoresArgs<ExtArgs>;
        _count?: boolean | SubmissionCountOutputTypeDefaultArgs<ExtArgs>;
      },
      ExtArgs['result']['submission']
    >;

  export type SubmissionSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      hackathonId?: boolean;
      teamId?: boolean;
      trackId?: boolean;
      title?: boolean;
      abstract?: boolean;
      repoUrl?: boolean;
      demoUrl?: boolean;
      videoUrl?: boolean;
      files?: boolean;
      submittedAt?: boolean;
      finalizedAt?: boolean;
      status?: boolean;
      scoreAggregate?: boolean;
      rank?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      hackathon?: boolean | HackathonDefaultArgs<ExtArgs>;
      team?: boolean | TeamDefaultArgs<ExtArgs>;
      track?: boolean | Submission$trackArgs<ExtArgs>;
    },
    ExtArgs['result']['submission']
  >;

  export type SubmissionSelectScalar = {
    id?: boolean;
    hackathonId?: boolean;
    teamId?: boolean;
    trackId?: boolean;
    title?: boolean;
    abstract?: boolean;
    repoUrl?: boolean;
    demoUrl?: boolean;
    videoUrl?: boolean;
    files?: boolean;
    submittedAt?: boolean;
    finalizedAt?: boolean;
    status?: boolean;
    scoreAggregate?: boolean;
    rank?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type SubmissionInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    hackathon?: boolean | HackathonDefaultArgs<ExtArgs>;
    team?: boolean | TeamDefaultArgs<ExtArgs>;
    track?: boolean | Submission$trackArgs<ExtArgs>;
    scores?: boolean | Submission$scoresArgs<ExtArgs>;
    _count?: boolean | SubmissionCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type SubmissionIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    hackathon?: boolean | HackathonDefaultArgs<ExtArgs>;
    team?: boolean | TeamDefaultArgs<ExtArgs>;
    track?: boolean | Submission$trackArgs<ExtArgs>;
  };

  export type $SubmissionPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'Submission';
    objects: {
      hackathon: Prisma.$HackathonPayload<ExtArgs>;
      team: Prisma.$TeamPayload<ExtArgs>;
      track: Prisma.$TrackPayload<ExtArgs> | null;
      scores: Prisma.$ScorePayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        hackathonId: string;
        teamId: string;
        trackId: string | null;
        title: string;
        abstract: string;
        repoUrl: string | null;
        demoUrl: string | null;
        videoUrl: string | null;
        files: string[];
        submittedAt: Date | null;
        finalizedAt: Date | null;
        status: $Enums.SubmissionStatus;
        scoreAggregate: Prisma.Decimal | null;
        rank: number | null;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs['result']['submission']
    >;
    composites: {};
  };

  type SubmissionGetPayload<S extends boolean | null | undefined | SubmissionDefaultArgs> =
    $Result.GetResult<Prisma.$SubmissionPayload, S>;

  type SubmissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubmissionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SubmissionCountAggregateInputType | true;
    };

  export interface SubmissionDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Submission'];
      meta: { name: 'Submission' };
    };
    /**
     * Find zero or one Submission that matches the filter.
     * @param {SubmissionFindUniqueArgs} args - Arguments to find a Submission
     * @example
     * // Get one Submission
     * const submission = await prisma.submission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubmissionFindUniqueArgs>(
      args: SelectSubset<T, SubmissionFindUniqueArgs<ExtArgs>>
    ): Prisma__SubmissionClient<
      $Result.GetResult<Prisma.$SubmissionPayload<ExtArgs>, T, 'findUnique'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find one Submission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubmissionFindUniqueOrThrowArgs} args - Arguments to find a Submission
     * @example
     * // Get one Submission
     * const submission = await prisma.submission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubmissionFindUniqueOrThrowArgs>(
      args: SelectSubset<T, SubmissionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SubmissionClient<
      $Result.GetResult<Prisma.$SubmissionPayload<ExtArgs>, T, 'findUniqueOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find the first Submission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionFindFirstArgs} args - Arguments to find a Submission
     * @example
     * // Get one Submission
     * const submission = await prisma.submission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubmissionFindFirstArgs>(
      args?: SelectSubset<T, SubmissionFindFirstArgs<ExtArgs>>
    ): Prisma__SubmissionClient<
      $Result.GetResult<Prisma.$SubmissionPayload<ExtArgs>, T, 'findFirst'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find the first Submission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionFindFirstOrThrowArgs} args - Arguments to find a Submission
     * @example
     * // Get one Submission
     * const submission = await prisma.submission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubmissionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SubmissionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SubmissionClient<
      $Result.GetResult<Prisma.$SubmissionPayload<ExtArgs>, T, 'findFirstOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more Submissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Submissions
     * const submissions = await prisma.submission.findMany()
     *
     * // Get first 10 Submissions
     * const submissions = await prisma.submission.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const submissionWithIdOnly = await prisma.submission.findMany({ select: { id: true } })
     *
     */
    findMany<T extends SubmissionFindManyArgs>(
      args?: SelectSubset<T, SubmissionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubmissionPayload<ExtArgs>, T, 'findMany'>>;

    /**
     * Create a Submission.
     * @param {SubmissionCreateArgs} args - Arguments to create a Submission.
     * @example
     * // Create one Submission
     * const Submission = await prisma.submission.create({
     *   data: {
     *     // ... data to create a Submission
     *   }
     * })
     *
     */
    create<T extends SubmissionCreateArgs>(
      args: SelectSubset<T, SubmissionCreateArgs<ExtArgs>>
    ): Prisma__SubmissionClient<
      $Result.GetResult<Prisma.$SubmissionPayload<ExtArgs>, T, 'create'>,
      never,
      ExtArgs
    >;

    /**
     * Create many Submissions.
     * @param {SubmissionCreateManyArgs} args - Arguments to create many Submissions.
     * @example
     * // Create many Submissions
     * const submission = await prisma.submission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends SubmissionCreateManyArgs>(
      args?: SelectSubset<T, SubmissionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Submissions and returns the data saved in the database.
     * @param {SubmissionCreateManyAndReturnArgs} args - Arguments to create many Submissions.
     * @example
     * // Create many Submissions
     * const submission = await prisma.submission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Submissions and only return the `id`
     * const submissionWithIdOnly = await prisma.submission.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends SubmissionCreateManyAndReturnArgs>(
      args?: SelectSubset<T, SubmissionCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$SubmissionPayload<ExtArgs>, T, 'createManyAndReturn'>
    >;

    /**
     * Delete a Submission.
     * @param {SubmissionDeleteArgs} args - Arguments to delete one Submission.
     * @example
     * // Delete one Submission
     * const Submission = await prisma.submission.delete({
     *   where: {
     *     // ... filter to delete one Submission
     *   }
     * })
     *
     */
    delete<T extends SubmissionDeleteArgs>(
      args: SelectSubset<T, SubmissionDeleteArgs<ExtArgs>>
    ): Prisma__SubmissionClient<
      $Result.GetResult<Prisma.$SubmissionPayload<ExtArgs>, T, 'delete'>,
      never,
      ExtArgs
    >;

    /**
     * Update one Submission.
     * @param {SubmissionUpdateArgs} args - Arguments to update one Submission.
     * @example
     * // Update one Submission
     * const submission = await prisma.submission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends SubmissionUpdateArgs>(
      args: SelectSubset<T, SubmissionUpdateArgs<ExtArgs>>
    ): Prisma__SubmissionClient<
      $Result.GetResult<Prisma.$SubmissionPayload<ExtArgs>, T, 'update'>,
      never,
      ExtArgs
    >;

    /**
     * Delete zero or more Submissions.
     * @param {SubmissionDeleteManyArgs} args - Arguments to filter Submissions to delete.
     * @example
     * // Delete a few Submissions
     * const { count } = await prisma.submission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends SubmissionDeleteManyArgs>(
      args?: SelectSubset<T, SubmissionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Submissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Submissions
     * const submission = await prisma.submission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends SubmissionUpdateManyArgs>(
      args: SelectSubset<T, SubmissionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Submission.
     * @param {SubmissionUpsertArgs} args - Arguments to update or create a Submission.
     * @example
     * // Update or create a Submission
     * const submission = await prisma.submission.upsert({
     *   create: {
     *     // ... data to create a Submission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Submission we want to update
     *   }
     * })
     */
    upsert<T extends SubmissionUpsertArgs>(
      args: SelectSubset<T, SubmissionUpsertArgs<ExtArgs>>
    ): Prisma__SubmissionClient<
      $Result.GetResult<Prisma.$SubmissionPayload<ExtArgs>, T, 'upsert'>,
      never,
      ExtArgs
    >;

    /**
     * Count the number of Submissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionCountArgs} args - Arguments to filter Submissions to count.
     * @example
     * // Count the number of Submissions
     * const count = await prisma.submission.count({
     *   where: {
     *     // ... the filter for the Submissions we want to count
     *   }
     * })
     **/
    count<T extends SubmissionCountArgs>(
      args?: Subset<T, SubmissionCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubmissionCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Submission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends SubmissionAggregateArgs>(
      args: Subset<T, SubmissionAggregateArgs>
    ): Prisma.PrismaPromise<GetSubmissionAggregateType<T>>;

    /**
     * Group by Submission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends SubmissionGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubmissionGroupByArgs['orderBy'] }
        : { orderBy?: SubmissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, SubmissionGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetSubmissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Submission model
     */
    readonly fields: SubmissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Submission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubmissionClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    hackathon<T extends HackathonDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, HackathonDefaultArgs<ExtArgs>>
    ): Prisma__HackathonClient<
      $Result.GetResult<Prisma.$HackathonPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null,
      Null,
      ExtArgs
    >;
    team<T extends TeamDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, TeamDefaultArgs<ExtArgs>>
    ): Prisma__TeamClient<
      $Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null,
      Null,
      ExtArgs
    >;
    track<T extends Submission$trackArgs<ExtArgs> = {}>(
      args?: Subset<T, Submission$trackArgs<ExtArgs>>
    ): Prisma__TrackClient<
      $Result.GetResult<Prisma.$TrackPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null,
      null,
      ExtArgs
    >;
    scores<T extends Submission$scoresArgs<ExtArgs> = {}>(
      args?: Subset<T, Submission$scoresArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScorePayload<ExtArgs>, T, 'findMany'> | Null>;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Submission model
   */
  interface SubmissionFieldRefs {
    readonly id: FieldRef<'Submission', 'String'>;
    readonly hackathonId: FieldRef<'Submission', 'String'>;
    readonly teamId: FieldRef<'Submission', 'String'>;
    readonly trackId: FieldRef<'Submission', 'String'>;
    readonly title: FieldRef<'Submission', 'String'>;
    readonly abstract: FieldRef<'Submission', 'String'>;
    readonly repoUrl: FieldRef<'Submission', 'String'>;
    readonly demoUrl: FieldRef<'Submission', 'String'>;
    readonly videoUrl: FieldRef<'Submission', 'String'>;
    readonly files: FieldRef<'Submission', 'String[]'>;
    readonly submittedAt: FieldRef<'Submission', 'DateTime'>;
    readonly finalizedAt: FieldRef<'Submission', 'DateTime'>;
    readonly status: FieldRef<'Submission', 'SubmissionStatus'>;
    readonly scoreAggregate: FieldRef<'Submission', 'Decimal'>;
    readonly rank: FieldRef<'Submission', 'Int'>;
    readonly createdAt: FieldRef<'Submission', 'DateTime'>;
    readonly updatedAt: FieldRef<'Submission', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * Submission findUnique
   */
  export type SubmissionFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionInclude<ExtArgs> | null;
    /**
     * Filter, which Submission to fetch.
     */
    where: SubmissionWhereUniqueInput;
  };

  /**
   * Submission findUniqueOrThrow
   */
  export type SubmissionFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionInclude<ExtArgs> | null;
    /**
     * Filter, which Submission to fetch.
     */
    where: SubmissionWhereUniqueInput;
  };

  /**
   * Submission findFirst
   */
  export type SubmissionFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionInclude<ExtArgs> | null;
    /**
     * Filter, which Submission to fetch.
     */
    where?: SubmissionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Submissions to fetch.
     */
    orderBy?: SubmissionOrderByWithRelationInput | SubmissionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Submissions.
     */
    cursor?: SubmissionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Submissions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Submissions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Submissions.
     */
    distinct?: SubmissionScalarFieldEnum | SubmissionScalarFieldEnum[];
  };

  /**
   * Submission findFirstOrThrow
   */
  export type SubmissionFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionInclude<ExtArgs> | null;
    /**
     * Filter, which Submission to fetch.
     */
    where?: SubmissionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Submissions to fetch.
     */
    orderBy?: SubmissionOrderByWithRelationInput | SubmissionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Submissions.
     */
    cursor?: SubmissionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Submissions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Submissions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Submissions.
     */
    distinct?: SubmissionScalarFieldEnum | SubmissionScalarFieldEnum[];
  };

  /**
   * Submission findMany
   */
  export type SubmissionFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionInclude<ExtArgs> | null;
    /**
     * Filter, which Submissions to fetch.
     */
    where?: SubmissionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Submissions to fetch.
     */
    orderBy?: SubmissionOrderByWithRelationInput | SubmissionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Submissions.
     */
    cursor?: SubmissionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Submissions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Submissions.
     */
    skip?: number;
    distinct?: SubmissionScalarFieldEnum | SubmissionScalarFieldEnum[];
  };

  /**
   * Submission create
   */
  export type SubmissionCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionInclude<ExtArgs> | null;
    /**
     * The data needed to create a Submission.
     */
    data: XOR<SubmissionCreateInput, SubmissionUncheckedCreateInput>;
  };

  /**
   * Submission createMany
   */
  export type SubmissionCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Submissions.
     */
    data: SubmissionCreateManyInput | SubmissionCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Submission createManyAndReturn
   */
  export type SubmissionCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * The data used to create many Submissions.
     */
    data: SubmissionCreateManyInput | SubmissionCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Submission update
   */
  export type SubmissionUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionInclude<ExtArgs> | null;
    /**
     * The data needed to update a Submission.
     */
    data: XOR<SubmissionUpdateInput, SubmissionUncheckedUpdateInput>;
    /**
     * Choose, which Submission to update.
     */
    where: SubmissionWhereUniqueInput;
  };

  /**
   * Submission updateMany
   */
  export type SubmissionUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Submissions.
     */
    data: XOR<SubmissionUpdateManyMutationInput, SubmissionUncheckedUpdateManyInput>;
    /**
     * Filter which Submissions to update
     */
    where?: SubmissionWhereInput;
  };

  /**
   * Submission upsert
   */
  export type SubmissionUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionInclude<ExtArgs> | null;
    /**
     * The filter to search for the Submission to update in case it exists.
     */
    where: SubmissionWhereUniqueInput;
    /**
     * In case the Submission found by the `where` argument doesn't exist, create a new Submission with this data.
     */
    create: XOR<SubmissionCreateInput, SubmissionUncheckedCreateInput>;
    /**
     * In case the Submission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubmissionUpdateInput, SubmissionUncheckedUpdateInput>;
  };

  /**
   * Submission delete
   */
  export type SubmissionDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionInclude<ExtArgs> | null;
    /**
     * Filter which Submission to delete.
     */
    where: SubmissionWhereUniqueInput;
  };

  /**
   * Submission deleteMany
   */
  export type SubmissionDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Submissions to delete
     */
    where?: SubmissionWhereInput;
  };

  /**
   * Submission.track
   */
  export type Submission$trackArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Track
     */
    select?: TrackSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrackInclude<ExtArgs> | null;
    where?: TrackWhereInput;
  };

  /**
   * Submission.scores
   */
  export type Submission$scoresArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Score
     */
    select?: ScoreSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoreInclude<ExtArgs> | null;
    where?: ScoreWhereInput;
    orderBy?: ScoreOrderByWithRelationInput | ScoreOrderByWithRelationInput[];
    cursor?: ScoreWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ScoreScalarFieldEnum | ScoreScalarFieldEnum[];
  };

  /**
   * Submission without action
   */
  export type SubmissionDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionInclude<ExtArgs> | null;
  };

  /**
   * Model Score
   */

  export type AggregateScore = {
    _count: ScoreCountAggregateOutputType | null;
    _avg: ScoreAvgAggregateOutputType | null;
    _sum: ScoreSumAggregateOutputType | null;
    _min: ScoreMinAggregateOutputType | null;
    _max: ScoreMaxAggregateOutputType | null;
  };

  export type ScoreAvgAggregateOutputType = {
    score: number | null;
  };

  export type ScoreSumAggregateOutputType = {
    score: number | null;
  };

  export type ScoreMinAggregateOutputType = {
    id: string | null;
    submissionId: string | null;
    judgeId: string | null;
    criterionId: string | null;
    score: number | null;
    feedback: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type ScoreMaxAggregateOutputType = {
    id: string | null;
    submissionId: string | null;
    judgeId: string | null;
    criterionId: string | null;
    score: number | null;
    feedback: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type ScoreCountAggregateOutputType = {
    id: number;
    submissionId: number;
    judgeId: number;
    criterionId: number;
    score: number;
    feedback: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type ScoreAvgAggregateInputType = {
    score?: true;
  };

  export type ScoreSumAggregateInputType = {
    score?: true;
  };

  export type ScoreMinAggregateInputType = {
    id?: true;
    submissionId?: true;
    judgeId?: true;
    criterionId?: true;
    score?: true;
    feedback?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type ScoreMaxAggregateInputType = {
    id?: true;
    submissionId?: true;
    judgeId?: true;
    criterionId?: true;
    score?: true;
    feedback?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type ScoreCountAggregateInputType = {
    id?: true;
    submissionId?: true;
    judgeId?: true;
    criterionId?: true;
    score?: true;
    feedback?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type ScoreAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Score to aggregate.
     */
    where?: ScoreWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Scores to fetch.
     */
    orderBy?: ScoreOrderByWithRelationInput | ScoreOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ScoreWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Scores from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Scores.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Scores
     **/
    _count?: true | ScoreCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: ScoreAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: ScoreSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ScoreMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ScoreMaxAggregateInputType;
  };

  export type GetScoreAggregateType<T extends ScoreAggregateArgs> = {
    [P in keyof T & keyof AggregateScore]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateScore[P]>
      : GetScalarType<T[P], AggregateScore[P]>;
  };

  export type ScoreGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      where?: ScoreWhereInput;
      orderBy?: ScoreOrderByWithAggregationInput | ScoreOrderByWithAggregationInput[];
      by: ScoreScalarFieldEnum[] | ScoreScalarFieldEnum;
      having?: ScoreScalarWhereWithAggregatesInput;
      take?: number;
      skip?: number;
      _count?: ScoreCountAggregateInputType | true;
      _avg?: ScoreAvgAggregateInputType;
      _sum?: ScoreSumAggregateInputType;
      _min?: ScoreMinAggregateInputType;
      _max?: ScoreMaxAggregateInputType;
    };

  export type ScoreGroupByOutputType = {
    id: string;
    submissionId: string;
    judgeId: string;
    criterionId: string;
    score: number;
    feedback: string | null;
    createdAt: Date;
    updatedAt: Date;
    _count: ScoreCountAggregateOutputType | null;
    _avg: ScoreAvgAggregateOutputType | null;
    _sum: ScoreSumAggregateOutputType | null;
    _min: ScoreMinAggregateOutputType | null;
    _max: ScoreMaxAggregateOutputType | null;
  };

  type GetScoreGroupByPayload<T extends ScoreGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ScoreGroupByOutputType, T['by']> & {
        [P in keyof T & keyof ScoreGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], ScoreGroupByOutputType[P]>
          : GetScalarType<T[P], ScoreGroupByOutputType[P]>;
      }
    >
  >;

  export type ScoreSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        submissionId?: boolean;
        judgeId?: boolean;
        criterionId?: boolean;
        score?: boolean;
        feedback?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        submission?: boolean | SubmissionDefaultArgs<ExtArgs>;
        judge?: boolean | JudgeDefaultArgs<ExtArgs>;
        criterion?: boolean | CriteriaDefaultArgs<ExtArgs>;
      },
      ExtArgs['result']['score']
    >;

  export type ScoreSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      submissionId?: boolean;
      judgeId?: boolean;
      criterionId?: boolean;
      score?: boolean;
      feedback?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      submission?: boolean | SubmissionDefaultArgs<ExtArgs>;
      judge?: boolean | JudgeDefaultArgs<ExtArgs>;
      criterion?: boolean | CriteriaDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['score']
  >;

  export type ScoreSelectScalar = {
    id?: boolean;
    submissionId?: boolean;
    judgeId?: boolean;
    criterionId?: boolean;
    score?: boolean;
    feedback?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type ScoreInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    submission?: boolean | SubmissionDefaultArgs<ExtArgs>;
    judge?: boolean | JudgeDefaultArgs<ExtArgs>;
    criterion?: boolean | CriteriaDefaultArgs<ExtArgs>;
  };
  export type ScoreIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    submission?: boolean | SubmissionDefaultArgs<ExtArgs>;
    judge?: boolean | JudgeDefaultArgs<ExtArgs>;
    criterion?: boolean | CriteriaDefaultArgs<ExtArgs>;
  };

  export type $ScorePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: 'Score';
    objects: {
      submission: Prisma.$SubmissionPayload<ExtArgs>;
      judge: Prisma.$JudgePayload<ExtArgs>;
      criterion: Prisma.$CriteriaPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        submissionId: string;
        judgeId: string;
        criterionId: string;
        score: number;
        feedback: string | null;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs['result']['score']
    >;
    composites: {};
  };

  type ScoreGetPayload<S extends boolean | null | undefined | ScoreDefaultArgs> = $Result.GetResult<
    Prisma.$ScorePayload,
    S
  >;

  type ScoreCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    ScoreFindManyArgs,
    'select' | 'include' | 'distinct'
  > & {
    select?: ScoreCountAggregateInputType | true;
  };

  export interface ScoreDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Score']; meta: { name: 'Score' } };
    /**
     * Find zero or one Score that matches the filter.
     * @param {ScoreFindUniqueArgs} args - Arguments to find a Score
     * @example
     * // Get one Score
     * const score = await prisma.score.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ScoreFindUniqueArgs>(
      args: SelectSubset<T, ScoreFindUniqueArgs<ExtArgs>>
    ): Prisma__ScoreClient<
      $Result.GetResult<Prisma.$ScorePayload<ExtArgs>, T, 'findUnique'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find one Score that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ScoreFindUniqueOrThrowArgs} args - Arguments to find a Score
     * @example
     * // Get one Score
     * const score = await prisma.score.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ScoreFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ScoreFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ScoreClient<
      $Result.GetResult<Prisma.$ScorePayload<ExtArgs>, T, 'findUniqueOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find the first Score that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScoreFindFirstArgs} args - Arguments to find a Score
     * @example
     * // Get one Score
     * const score = await prisma.score.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ScoreFindFirstArgs>(
      args?: SelectSubset<T, ScoreFindFirstArgs<ExtArgs>>
    ): Prisma__ScoreClient<
      $Result.GetResult<Prisma.$ScorePayload<ExtArgs>, T, 'findFirst'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find the first Score that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScoreFindFirstOrThrowArgs} args - Arguments to find a Score
     * @example
     * // Get one Score
     * const score = await prisma.score.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ScoreFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ScoreFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ScoreClient<
      $Result.GetResult<Prisma.$ScorePayload<ExtArgs>, T, 'findFirstOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more Scores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScoreFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Scores
     * const scores = await prisma.score.findMany()
     *
     * // Get first 10 Scores
     * const scores = await prisma.score.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const scoreWithIdOnly = await prisma.score.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ScoreFindManyArgs>(
      args?: SelectSubset<T, ScoreFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScorePayload<ExtArgs>, T, 'findMany'>>;

    /**
     * Create a Score.
     * @param {ScoreCreateArgs} args - Arguments to create a Score.
     * @example
     * // Create one Score
     * const Score = await prisma.score.create({
     *   data: {
     *     // ... data to create a Score
     *   }
     * })
     *
     */
    create<T extends ScoreCreateArgs>(
      args: SelectSubset<T, ScoreCreateArgs<ExtArgs>>
    ): Prisma__ScoreClient<
      $Result.GetResult<Prisma.$ScorePayload<ExtArgs>, T, 'create'>,
      never,
      ExtArgs
    >;

    /**
     * Create many Scores.
     * @param {ScoreCreateManyArgs} args - Arguments to create many Scores.
     * @example
     * // Create many Scores
     * const score = await prisma.score.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ScoreCreateManyArgs>(
      args?: SelectSubset<T, ScoreCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Scores and returns the data saved in the database.
     * @param {ScoreCreateManyAndReturnArgs} args - Arguments to create many Scores.
     * @example
     * // Create many Scores
     * const score = await prisma.score.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Scores and only return the `id`
     * const scoreWithIdOnly = await prisma.score.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends ScoreCreateManyAndReturnArgs>(
      args?: SelectSubset<T, ScoreCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ScorePayload<ExtArgs>, T, 'createManyAndReturn'>
    >;

    /**
     * Delete a Score.
     * @param {ScoreDeleteArgs} args - Arguments to delete one Score.
     * @example
     * // Delete one Score
     * const Score = await prisma.score.delete({
     *   where: {
     *     // ... filter to delete one Score
     *   }
     * })
     *
     */
    delete<T extends ScoreDeleteArgs>(
      args: SelectSubset<T, ScoreDeleteArgs<ExtArgs>>
    ): Prisma__ScoreClient<
      $Result.GetResult<Prisma.$ScorePayload<ExtArgs>, T, 'delete'>,
      never,
      ExtArgs
    >;

    /**
     * Update one Score.
     * @param {ScoreUpdateArgs} args - Arguments to update one Score.
     * @example
     * // Update one Score
     * const score = await prisma.score.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ScoreUpdateArgs>(
      args: SelectSubset<T, ScoreUpdateArgs<ExtArgs>>
    ): Prisma__ScoreClient<
      $Result.GetResult<Prisma.$ScorePayload<ExtArgs>, T, 'update'>,
      never,
      ExtArgs
    >;

    /**
     * Delete zero or more Scores.
     * @param {ScoreDeleteManyArgs} args - Arguments to filter Scores to delete.
     * @example
     * // Delete a few Scores
     * const { count } = await prisma.score.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ScoreDeleteManyArgs>(
      args?: SelectSubset<T, ScoreDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Scores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScoreUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Scores
     * const score = await prisma.score.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ScoreUpdateManyArgs>(
      args: SelectSubset<T, ScoreUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Score.
     * @param {ScoreUpsertArgs} args - Arguments to update or create a Score.
     * @example
     * // Update or create a Score
     * const score = await prisma.score.upsert({
     *   create: {
     *     // ... data to create a Score
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Score we want to update
     *   }
     * })
     */
    upsert<T extends ScoreUpsertArgs>(
      args: SelectSubset<T, ScoreUpsertArgs<ExtArgs>>
    ): Prisma__ScoreClient<
      $Result.GetResult<Prisma.$ScorePayload<ExtArgs>, T, 'upsert'>,
      never,
      ExtArgs
    >;

    /**
     * Count the number of Scores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScoreCountArgs} args - Arguments to filter Scores to count.
     * @example
     * // Count the number of Scores
     * const count = await prisma.score.count({
     *   where: {
     *     // ... the filter for the Scores we want to count
     *   }
     * })
     **/
    count<T extends ScoreCountArgs>(
      args?: Subset<T, ScoreCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScoreCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Score.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScoreAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ScoreAggregateArgs>(
      args: Subset<T, ScoreAggregateArgs>
    ): Prisma.PrismaPromise<GetScoreAggregateType<T>>;

    /**
     * Group by Score.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScoreGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends ScoreGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ScoreGroupByArgs['orderBy'] }
        : { orderBy?: ScoreGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, ScoreGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetScoreGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Score model
     */
    readonly fields: ScoreFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Score.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ScoreClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    submission<T extends SubmissionDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, SubmissionDefaultArgs<ExtArgs>>
    ): Prisma__SubmissionClient<
      $Result.GetResult<Prisma.$SubmissionPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null,
      Null,
      ExtArgs
    >;
    judge<T extends JudgeDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, JudgeDefaultArgs<ExtArgs>>
    ): Prisma__JudgeClient<
      $Result.GetResult<Prisma.$JudgePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null,
      Null,
      ExtArgs
    >;
    criterion<T extends CriteriaDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, CriteriaDefaultArgs<ExtArgs>>
    ): Prisma__CriteriaClient<
      $Result.GetResult<Prisma.$CriteriaPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null,
      Null,
      ExtArgs
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Score model
   */
  interface ScoreFieldRefs {
    readonly id: FieldRef<'Score', 'String'>;
    readonly submissionId: FieldRef<'Score', 'String'>;
    readonly judgeId: FieldRef<'Score', 'String'>;
    readonly criterionId: FieldRef<'Score', 'String'>;
    readonly score: FieldRef<'Score', 'Int'>;
    readonly feedback: FieldRef<'Score', 'String'>;
    readonly createdAt: FieldRef<'Score', 'DateTime'>;
    readonly updatedAt: FieldRef<'Score', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * Score findUnique
   */
  export type ScoreFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Score
     */
    select?: ScoreSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoreInclude<ExtArgs> | null;
    /**
     * Filter, which Score to fetch.
     */
    where: ScoreWhereUniqueInput;
  };

  /**
   * Score findUniqueOrThrow
   */
  export type ScoreFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Score
     */
    select?: ScoreSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoreInclude<ExtArgs> | null;
    /**
     * Filter, which Score to fetch.
     */
    where: ScoreWhereUniqueInput;
  };

  /**
   * Score findFirst
   */
  export type ScoreFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Score
     */
    select?: ScoreSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoreInclude<ExtArgs> | null;
    /**
     * Filter, which Score to fetch.
     */
    where?: ScoreWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Scores to fetch.
     */
    orderBy?: ScoreOrderByWithRelationInput | ScoreOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Scores.
     */
    cursor?: ScoreWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Scores from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Scores.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Scores.
     */
    distinct?: ScoreScalarFieldEnum | ScoreScalarFieldEnum[];
  };

  /**
   * Score findFirstOrThrow
   */
  export type ScoreFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Score
     */
    select?: ScoreSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoreInclude<ExtArgs> | null;
    /**
     * Filter, which Score to fetch.
     */
    where?: ScoreWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Scores to fetch.
     */
    orderBy?: ScoreOrderByWithRelationInput | ScoreOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Scores.
     */
    cursor?: ScoreWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Scores from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Scores.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Scores.
     */
    distinct?: ScoreScalarFieldEnum | ScoreScalarFieldEnum[];
  };

  /**
   * Score findMany
   */
  export type ScoreFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Score
     */
    select?: ScoreSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoreInclude<ExtArgs> | null;
    /**
     * Filter, which Scores to fetch.
     */
    where?: ScoreWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Scores to fetch.
     */
    orderBy?: ScoreOrderByWithRelationInput | ScoreOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Scores.
     */
    cursor?: ScoreWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Scores from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Scores.
     */
    skip?: number;
    distinct?: ScoreScalarFieldEnum | ScoreScalarFieldEnum[];
  };

  /**
   * Score create
   */
  export type ScoreCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the Score
       */
      select?: ScoreSelect<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: ScoreInclude<ExtArgs> | null;
      /**
       * The data needed to create a Score.
       */
      data: XOR<ScoreCreateInput, ScoreUncheckedCreateInput>;
    };

  /**
   * Score createMany
   */
  export type ScoreCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Scores.
     */
    data: ScoreCreateManyInput | ScoreCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Score createManyAndReturn
   */
  export type ScoreCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Score
     */
    select?: ScoreSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * The data used to create many Scores.
     */
    data: ScoreCreateManyInput | ScoreCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoreIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Score update
   */
  export type ScoreUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the Score
       */
      select?: ScoreSelect<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: ScoreInclude<ExtArgs> | null;
      /**
       * The data needed to update a Score.
       */
      data: XOR<ScoreUpdateInput, ScoreUncheckedUpdateInput>;
      /**
       * Choose, which Score to update.
       */
      where: ScoreWhereUniqueInput;
    };

  /**
   * Score updateMany
   */
  export type ScoreUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Scores.
     */
    data: XOR<ScoreUpdateManyMutationInput, ScoreUncheckedUpdateManyInput>;
    /**
     * Filter which Scores to update
     */
    where?: ScoreWhereInput;
  };

  /**
   * Score upsert
   */
  export type ScoreUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the Score
       */
      select?: ScoreSelect<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: ScoreInclude<ExtArgs> | null;
      /**
       * The filter to search for the Score to update in case it exists.
       */
      where: ScoreWhereUniqueInput;
      /**
       * In case the Score found by the `where` argument doesn't exist, create a new Score with this data.
       */
      create: XOR<ScoreCreateInput, ScoreUncheckedCreateInput>;
      /**
       * In case the Score was found with the provided `where` argument, update it with this data.
       */
      update: XOR<ScoreUpdateInput, ScoreUncheckedUpdateInput>;
    };

  /**
   * Score delete
   */
  export type ScoreDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the Score
       */
      select?: ScoreSelect<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: ScoreInclude<ExtArgs> | null;
      /**
       * Filter which Score to delete.
       */
      where: ScoreWhereUniqueInput;
    };

  /**
   * Score deleteMany
   */
  export type ScoreDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Scores to delete
     */
    where?: ScoreWhereInput;
  };

  /**
   * Score without action
   */
  export type ScoreDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the Score
       */
      select?: ScoreSelect<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: ScoreInclude<ExtArgs> | null;
    };

  /**
   * Model Challenge
   */

  export type AggregateChallenge = {
    _count: ChallengeCountAggregateOutputType | null;
    _min: ChallengeMinAggregateOutputType | null;
    _max: ChallengeMaxAggregateOutputType | null;
  };

  export type ChallengeMinAggregateOutputType = {
    id: string | null;
    slug: string | null;
    title: string | null;
    problemStatement: string | null;
    ownerId: string | null;
    ownerOrg: string | null;
    rewardType: $Enums.RewardType | null;
    rewardValue: string | null;
    status: $Enums.ChallengeStatus | null;
    visibility: $Enums.ChallengeVisibility | null;
    deadlineAt: Date | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type ChallengeMaxAggregateOutputType = {
    id: string | null;
    slug: string | null;
    title: string | null;
    problemStatement: string | null;
    ownerId: string | null;
    ownerOrg: string | null;
    rewardType: $Enums.RewardType | null;
    rewardValue: string | null;
    status: $Enums.ChallengeStatus | null;
    visibility: $Enums.ChallengeVisibility | null;
    deadlineAt: Date | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type ChallengeCountAggregateOutputType = {
    id: number;
    slug: number;
    title: number;
    problemStatement: number;
    ownerId: number;
    ownerOrg: number;
    rewardType: number;
    rewardValue: number;
    categories: number;
    skills: number;
    attachments: number;
    status: number;
    visibility: number;
    deadlineAt: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type ChallengeMinAggregateInputType = {
    id?: true;
    slug?: true;
    title?: true;
    problemStatement?: true;
    ownerId?: true;
    ownerOrg?: true;
    rewardType?: true;
    rewardValue?: true;
    status?: true;
    visibility?: true;
    deadlineAt?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type ChallengeMaxAggregateInputType = {
    id?: true;
    slug?: true;
    title?: true;
    problemStatement?: true;
    ownerId?: true;
    ownerOrg?: true;
    rewardType?: true;
    rewardValue?: true;
    status?: true;
    visibility?: true;
    deadlineAt?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type ChallengeCountAggregateInputType = {
    id?: true;
    slug?: true;
    title?: true;
    problemStatement?: true;
    ownerId?: true;
    ownerOrg?: true;
    rewardType?: true;
    rewardValue?: true;
    categories?: true;
    skills?: true;
    attachments?: true;
    status?: true;
    visibility?: true;
    deadlineAt?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type ChallengeAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Challenge to aggregate.
     */
    where?: ChallengeWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Challenges to fetch.
     */
    orderBy?: ChallengeOrderByWithRelationInput | ChallengeOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ChallengeWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Challenges from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Challenges.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Challenges
     **/
    _count?: true | ChallengeCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ChallengeMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ChallengeMaxAggregateInputType;
  };

  export type GetChallengeAggregateType<T extends ChallengeAggregateArgs> = {
    [P in keyof T & keyof AggregateChallenge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChallenge[P]>
      : GetScalarType<T[P], AggregateChallenge[P]>;
  };

  export type ChallengeGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ChallengeWhereInput;
    orderBy?: ChallengeOrderByWithAggregationInput | ChallengeOrderByWithAggregationInput[];
    by: ChallengeScalarFieldEnum[] | ChallengeScalarFieldEnum;
    having?: ChallengeScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ChallengeCountAggregateInputType | true;
    _min?: ChallengeMinAggregateInputType;
    _max?: ChallengeMaxAggregateInputType;
  };

  export type ChallengeGroupByOutputType = {
    id: string;
    slug: string;
    title: string;
    problemStatement: string;
    ownerId: string;
    ownerOrg: string | null;
    rewardType: $Enums.RewardType | null;
    rewardValue: string | null;
    categories: string[];
    skills: string[];
    attachments: string[];
    status: $Enums.ChallengeStatus;
    visibility: $Enums.ChallengeVisibility;
    deadlineAt: Date | null;
    createdAt: Date;
    updatedAt: Date;
    _count: ChallengeCountAggregateOutputType | null;
    _min: ChallengeMinAggregateOutputType | null;
    _max: ChallengeMaxAggregateOutputType | null;
  };

  type GetChallengeGroupByPayload<T extends ChallengeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChallengeGroupByOutputType, T['by']> & {
        [P in keyof T & keyof ChallengeGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], ChallengeGroupByOutputType[P]>
          : GetScalarType<T[P], ChallengeGroupByOutputType[P]>;
      }
    >
  >;

  export type ChallengeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        slug?: boolean;
        title?: boolean;
        problemStatement?: boolean;
        ownerId?: boolean;
        ownerOrg?: boolean;
        rewardType?: boolean;
        rewardValue?: boolean;
        categories?: boolean;
        skills?: boolean;
        attachments?: boolean;
        status?: boolean;
        visibility?: boolean;
        deadlineAt?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        owner?: boolean | UserDefaultArgs<ExtArgs>;
        submissions?: boolean | Challenge$submissionsArgs<ExtArgs>;
        _count?: boolean | ChallengeCountOutputTypeDefaultArgs<ExtArgs>;
      },
      ExtArgs['result']['challenge']
    >;

  export type ChallengeSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      slug?: boolean;
      title?: boolean;
      problemStatement?: boolean;
      ownerId?: boolean;
      ownerOrg?: boolean;
      rewardType?: boolean;
      rewardValue?: boolean;
      categories?: boolean;
      skills?: boolean;
      attachments?: boolean;
      status?: boolean;
      visibility?: boolean;
      deadlineAt?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      owner?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['challenge']
  >;

  export type ChallengeSelectScalar = {
    id?: boolean;
    slug?: boolean;
    title?: boolean;
    problemStatement?: boolean;
    ownerId?: boolean;
    ownerOrg?: boolean;
    rewardType?: boolean;
    rewardValue?: boolean;
    categories?: boolean;
    skills?: boolean;
    attachments?: boolean;
    status?: boolean;
    visibility?: boolean;
    deadlineAt?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type ChallengeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      owner?: boolean | UserDefaultArgs<ExtArgs>;
      submissions?: boolean | Challenge$submissionsArgs<ExtArgs>;
      _count?: boolean | ChallengeCountOutputTypeDefaultArgs<ExtArgs>;
    };
  export type ChallengeIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    owner?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $ChallengePayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'Challenge';
    objects: {
      owner: Prisma.$UserPayload<ExtArgs>;
      submissions: Prisma.$ChallengeSubmissionPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        slug: string;
        title: string;
        problemStatement: string;
        ownerId: string;
        ownerOrg: string | null;
        rewardType: $Enums.RewardType | null;
        rewardValue: string | null;
        categories: string[];
        skills: string[];
        attachments: string[];
        status: $Enums.ChallengeStatus;
        visibility: $Enums.ChallengeVisibility;
        deadlineAt: Date | null;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs['result']['challenge']
    >;
    composites: {};
  };

  type ChallengeGetPayload<S extends boolean | null | undefined | ChallengeDefaultArgs> =
    $Result.GetResult<Prisma.$ChallengePayload, S>;

  type ChallengeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChallengeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ChallengeCountAggregateInputType | true;
    };

  export interface ChallengeDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Challenge'];
      meta: { name: 'Challenge' };
    };
    /**
     * Find zero or one Challenge that matches the filter.
     * @param {ChallengeFindUniqueArgs} args - Arguments to find a Challenge
     * @example
     * // Get one Challenge
     * const challenge = await prisma.challenge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChallengeFindUniqueArgs>(
      args: SelectSubset<T, ChallengeFindUniqueArgs<ExtArgs>>
    ): Prisma__ChallengeClient<
      $Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, 'findUnique'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find one Challenge that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChallengeFindUniqueOrThrowArgs} args - Arguments to find a Challenge
     * @example
     * // Get one Challenge
     * const challenge = await prisma.challenge.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChallengeFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ChallengeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ChallengeClient<
      $Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, 'findUniqueOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find the first Challenge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeFindFirstArgs} args - Arguments to find a Challenge
     * @example
     * // Get one Challenge
     * const challenge = await prisma.challenge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChallengeFindFirstArgs>(
      args?: SelectSubset<T, ChallengeFindFirstArgs<ExtArgs>>
    ): Prisma__ChallengeClient<
      $Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, 'findFirst'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find the first Challenge that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeFindFirstOrThrowArgs} args - Arguments to find a Challenge
     * @example
     * // Get one Challenge
     * const challenge = await prisma.challenge.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChallengeFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ChallengeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ChallengeClient<
      $Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, 'findFirstOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more Challenges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Challenges
     * const challenges = await prisma.challenge.findMany()
     *
     * // Get first 10 Challenges
     * const challenges = await prisma.challenge.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const challengeWithIdOnly = await prisma.challenge.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ChallengeFindManyArgs>(
      args?: SelectSubset<T, ChallengeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, 'findMany'>>;

    /**
     * Create a Challenge.
     * @param {ChallengeCreateArgs} args - Arguments to create a Challenge.
     * @example
     * // Create one Challenge
     * const Challenge = await prisma.challenge.create({
     *   data: {
     *     // ... data to create a Challenge
     *   }
     * })
     *
     */
    create<T extends ChallengeCreateArgs>(
      args: SelectSubset<T, ChallengeCreateArgs<ExtArgs>>
    ): Prisma__ChallengeClient<
      $Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, 'create'>,
      never,
      ExtArgs
    >;

    /**
     * Create many Challenges.
     * @param {ChallengeCreateManyArgs} args - Arguments to create many Challenges.
     * @example
     * // Create many Challenges
     * const challenge = await prisma.challenge.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ChallengeCreateManyArgs>(
      args?: SelectSubset<T, ChallengeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Challenges and returns the data saved in the database.
     * @param {ChallengeCreateManyAndReturnArgs} args - Arguments to create many Challenges.
     * @example
     * // Create many Challenges
     * const challenge = await prisma.challenge.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Challenges and only return the `id`
     * const challengeWithIdOnly = await prisma.challenge.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends ChallengeCreateManyAndReturnArgs>(
      args?: SelectSubset<T, ChallengeCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, 'createManyAndReturn'>
    >;

    /**
     * Delete a Challenge.
     * @param {ChallengeDeleteArgs} args - Arguments to delete one Challenge.
     * @example
     * // Delete one Challenge
     * const Challenge = await prisma.challenge.delete({
     *   where: {
     *     // ... filter to delete one Challenge
     *   }
     * })
     *
     */
    delete<T extends ChallengeDeleteArgs>(
      args: SelectSubset<T, ChallengeDeleteArgs<ExtArgs>>
    ): Prisma__ChallengeClient<
      $Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, 'delete'>,
      never,
      ExtArgs
    >;

    /**
     * Update one Challenge.
     * @param {ChallengeUpdateArgs} args - Arguments to update one Challenge.
     * @example
     * // Update one Challenge
     * const challenge = await prisma.challenge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ChallengeUpdateArgs>(
      args: SelectSubset<T, ChallengeUpdateArgs<ExtArgs>>
    ): Prisma__ChallengeClient<
      $Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, 'update'>,
      never,
      ExtArgs
    >;

    /**
     * Delete zero or more Challenges.
     * @param {ChallengeDeleteManyArgs} args - Arguments to filter Challenges to delete.
     * @example
     * // Delete a few Challenges
     * const { count } = await prisma.challenge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ChallengeDeleteManyArgs>(
      args?: SelectSubset<T, ChallengeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Challenges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Challenges
     * const challenge = await prisma.challenge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ChallengeUpdateManyArgs>(
      args: SelectSubset<T, ChallengeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Challenge.
     * @param {ChallengeUpsertArgs} args - Arguments to update or create a Challenge.
     * @example
     * // Update or create a Challenge
     * const challenge = await prisma.challenge.upsert({
     *   create: {
     *     // ... data to create a Challenge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Challenge we want to update
     *   }
     * })
     */
    upsert<T extends ChallengeUpsertArgs>(
      args: SelectSubset<T, ChallengeUpsertArgs<ExtArgs>>
    ): Prisma__ChallengeClient<
      $Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, 'upsert'>,
      never,
      ExtArgs
    >;

    /**
     * Count the number of Challenges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeCountArgs} args - Arguments to filter Challenges to count.
     * @example
     * // Count the number of Challenges
     * const count = await prisma.challenge.count({
     *   where: {
     *     // ... the filter for the Challenges we want to count
     *   }
     * })
     **/
    count<T extends ChallengeCountArgs>(
      args?: Subset<T, ChallengeCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChallengeCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Challenge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ChallengeAggregateArgs>(
      args: Subset<T, ChallengeAggregateArgs>
    ): Prisma.PrismaPromise<GetChallengeAggregateType<T>>;

    /**
     * Group by Challenge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends ChallengeGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChallengeGroupByArgs['orderBy'] }
        : { orderBy?: ChallengeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, ChallengeGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetChallengeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Challenge model
     */
    readonly fields: ChallengeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Challenge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChallengeClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    owner<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null,
      Null,
      ExtArgs
    >;
    submissions<T extends Challenge$submissionsArgs<ExtArgs> = {}>(
      args?: Subset<T, Challenge$submissionsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ChallengeSubmissionPayload<ExtArgs>, T, 'findMany'> | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Challenge model
   */
  interface ChallengeFieldRefs {
    readonly id: FieldRef<'Challenge', 'String'>;
    readonly slug: FieldRef<'Challenge', 'String'>;
    readonly title: FieldRef<'Challenge', 'String'>;
    readonly problemStatement: FieldRef<'Challenge', 'String'>;
    readonly ownerId: FieldRef<'Challenge', 'String'>;
    readonly ownerOrg: FieldRef<'Challenge', 'String'>;
    readonly rewardType: FieldRef<'Challenge', 'RewardType'>;
    readonly rewardValue: FieldRef<'Challenge', 'String'>;
    readonly categories: FieldRef<'Challenge', 'String[]'>;
    readonly skills: FieldRef<'Challenge', 'String[]'>;
    readonly attachments: FieldRef<'Challenge', 'String[]'>;
    readonly status: FieldRef<'Challenge', 'ChallengeStatus'>;
    readonly visibility: FieldRef<'Challenge', 'ChallengeVisibility'>;
    readonly deadlineAt: FieldRef<'Challenge', 'DateTime'>;
    readonly createdAt: FieldRef<'Challenge', 'DateTime'>;
    readonly updatedAt: FieldRef<'Challenge', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * Challenge findUnique
   */
  export type ChallengeFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null;
    /**
     * Filter, which Challenge to fetch.
     */
    where: ChallengeWhereUniqueInput;
  };

  /**
   * Challenge findUniqueOrThrow
   */
  export type ChallengeFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null;
    /**
     * Filter, which Challenge to fetch.
     */
    where: ChallengeWhereUniqueInput;
  };

  /**
   * Challenge findFirst
   */
  export type ChallengeFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null;
    /**
     * Filter, which Challenge to fetch.
     */
    where?: ChallengeWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Challenges to fetch.
     */
    orderBy?: ChallengeOrderByWithRelationInput | ChallengeOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Challenges.
     */
    cursor?: ChallengeWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Challenges from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Challenges.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Challenges.
     */
    distinct?: ChallengeScalarFieldEnum | ChallengeScalarFieldEnum[];
  };

  /**
   * Challenge findFirstOrThrow
   */
  export type ChallengeFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null;
    /**
     * Filter, which Challenge to fetch.
     */
    where?: ChallengeWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Challenges to fetch.
     */
    orderBy?: ChallengeOrderByWithRelationInput | ChallengeOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Challenges.
     */
    cursor?: ChallengeWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Challenges from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Challenges.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Challenges.
     */
    distinct?: ChallengeScalarFieldEnum | ChallengeScalarFieldEnum[];
  };

  /**
   * Challenge findMany
   */
  export type ChallengeFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null;
    /**
     * Filter, which Challenges to fetch.
     */
    where?: ChallengeWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Challenges to fetch.
     */
    orderBy?: ChallengeOrderByWithRelationInput | ChallengeOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Challenges.
     */
    cursor?: ChallengeWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Challenges from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Challenges.
     */
    skip?: number;
    distinct?: ChallengeScalarFieldEnum | ChallengeScalarFieldEnum[];
  };

  /**
   * Challenge create
   */
  export type ChallengeCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null;
    /**
     * The data needed to create a Challenge.
     */
    data: XOR<ChallengeCreateInput, ChallengeUncheckedCreateInput>;
  };

  /**
   * Challenge createMany
   */
  export type ChallengeCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Challenges.
     */
    data: ChallengeCreateManyInput | ChallengeCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Challenge createManyAndReturn
   */
  export type ChallengeCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * The data used to create many Challenges.
     */
    data: ChallengeCreateManyInput | ChallengeCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Challenge update
   */
  export type ChallengeUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null;
    /**
     * The data needed to update a Challenge.
     */
    data: XOR<ChallengeUpdateInput, ChallengeUncheckedUpdateInput>;
    /**
     * Choose, which Challenge to update.
     */
    where: ChallengeWhereUniqueInput;
  };

  /**
   * Challenge updateMany
   */
  export type ChallengeUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Challenges.
     */
    data: XOR<ChallengeUpdateManyMutationInput, ChallengeUncheckedUpdateManyInput>;
    /**
     * Filter which Challenges to update
     */
    where?: ChallengeWhereInput;
  };

  /**
   * Challenge upsert
   */
  export type ChallengeUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null;
    /**
     * The filter to search for the Challenge to update in case it exists.
     */
    where: ChallengeWhereUniqueInput;
    /**
     * In case the Challenge found by the `where` argument doesn't exist, create a new Challenge with this data.
     */
    create: XOR<ChallengeCreateInput, ChallengeUncheckedCreateInput>;
    /**
     * In case the Challenge was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChallengeUpdateInput, ChallengeUncheckedUpdateInput>;
  };

  /**
   * Challenge delete
   */
  export type ChallengeDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null;
    /**
     * Filter which Challenge to delete.
     */
    where: ChallengeWhereUniqueInput;
  };

  /**
   * Challenge deleteMany
   */
  export type ChallengeDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Challenges to delete
     */
    where?: ChallengeWhereInput;
  };

  /**
   * Challenge.submissions
   */
  export type Challenge$submissionsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ChallengeSubmission
     */
    select?: ChallengeSubmissionSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeSubmissionInclude<ExtArgs> | null;
    where?: ChallengeSubmissionWhereInput;
    orderBy?:
      | ChallengeSubmissionOrderByWithRelationInput
      | ChallengeSubmissionOrderByWithRelationInput[];
    cursor?: ChallengeSubmissionWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ChallengeSubmissionScalarFieldEnum | ChallengeSubmissionScalarFieldEnum[];
  };

  /**
   * Challenge without action
   */
  export type ChallengeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null;
  };

  /**
   * Model ChallengeSubmission
   */

  export type AggregateChallengeSubmission = {
    _count: ChallengeSubmissionCountAggregateOutputType | null;
    _avg: ChallengeSubmissionAvgAggregateOutputType | null;
    _sum: ChallengeSubmissionSumAggregateOutputType | null;
    _min: ChallengeSubmissionMinAggregateOutputType | null;
    _max: ChallengeSubmissionMaxAggregateOutputType | null;
  };

  export type ChallengeSubmissionAvgAggregateOutputType = {
    score: Decimal | null;
  };

  export type ChallengeSubmissionSumAggregateOutputType = {
    score: Decimal | null;
  };

  export type ChallengeSubmissionMinAggregateOutputType = {
    id: string | null;
    challengeId: string | null;
    userId: string | null;
    teamId: string | null;
    title: string | null;
    repoUrl: string | null;
    content: string | null;
    status: $Enums.ChallengeSubmissionStatus | null;
    score: Decimal | null;
    feedback: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type ChallengeSubmissionMaxAggregateOutputType = {
    id: string | null;
    challengeId: string | null;
    userId: string | null;
    teamId: string | null;
    title: string | null;
    repoUrl: string | null;
    content: string | null;
    status: $Enums.ChallengeSubmissionStatus | null;
    score: Decimal | null;
    feedback: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type ChallengeSubmissionCountAggregateOutputType = {
    id: number;
    challengeId: number;
    userId: number;
    teamId: number;
    title: number;
    repoUrl: number;
    content: number;
    files: number;
    status: number;
    score: number;
    feedback: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type ChallengeSubmissionAvgAggregateInputType = {
    score?: true;
  };

  export type ChallengeSubmissionSumAggregateInputType = {
    score?: true;
  };

  export type ChallengeSubmissionMinAggregateInputType = {
    id?: true;
    challengeId?: true;
    userId?: true;
    teamId?: true;
    title?: true;
    repoUrl?: true;
    content?: true;
    status?: true;
    score?: true;
    feedback?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type ChallengeSubmissionMaxAggregateInputType = {
    id?: true;
    challengeId?: true;
    userId?: true;
    teamId?: true;
    title?: true;
    repoUrl?: true;
    content?: true;
    status?: true;
    score?: true;
    feedback?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type ChallengeSubmissionCountAggregateInputType = {
    id?: true;
    challengeId?: true;
    userId?: true;
    teamId?: true;
    title?: true;
    repoUrl?: true;
    content?: true;
    files?: true;
    status?: true;
    score?: true;
    feedback?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type ChallengeSubmissionAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which ChallengeSubmission to aggregate.
     */
    where?: ChallengeSubmissionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ChallengeSubmissions to fetch.
     */
    orderBy?:
      | ChallengeSubmissionOrderByWithRelationInput
      | ChallengeSubmissionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ChallengeSubmissionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ChallengeSubmissions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ChallengeSubmissions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned ChallengeSubmissions
     **/
    _count?: true | ChallengeSubmissionCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: ChallengeSubmissionAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: ChallengeSubmissionSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ChallengeSubmissionMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ChallengeSubmissionMaxAggregateInputType;
  };

  export type GetChallengeSubmissionAggregateType<T extends ChallengeSubmissionAggregateArgs> = {
    [P in keyof T & keyof AggregateChallengeSubmission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChallengeSubmission[P]>
      : GetScalarType<T[P], AggregateChallengeSubmission[P]>;
  };

  export type ChallengeSubmissionGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ChallengeSubmissionWhereInput;
    orderBy?:
      | ChallengeSubmissionOrderByWithAggregationInput
      | ChallengeSubmissionOrderByWithAggregationInput[];
    by: ChallengeSubmissionScalarFieldEnum[] | ChallengeSubmissionScalarFieldEnum;
    having?: ChallengeSubmissionScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ChallengeSubmissionCountAggregateInputType | true;
    _avg?: ChallengeSubmissionAvgAggregateInputType;
    _sum?: ChallengeSubmissionSumAggregateInputType;
    _min?: ChallengeSubmissionMinAggregateInputType;
    _max?: ChallengeSubmissionMaxAggregateInputType;
  };

  export type ChallengeSubmissionGroupByOutputType = {
    id: string;
    challengeId: string;
    userId: string | null;
    teamId: string | null;
    title: string;
    repoUrl: string | null;
    content: string;
    files: string[];
    status: $Enums.ChallengeSubmissionStatus;
    score: Decimal | null;
    feedback: string | null;
    createdAt: Date;
    updatedAt: Date;
    _count: ChallengeSubmissionCountAggregateOutputType | null;
    _avg: ChallengeSubmissionAvgAggregateOutputType | null;
    _sum: ChallengeSubmissionSumAggregateOutputType | null;
    _min: ChallengeSubmissionMinAggregateOutputType | null;
    _max: ChallengeSubmissionMaxAggregateOutputType | null;
  };

  type GetChallengeSubmissionGroupByPayload<T extends ChallengeSubmissionGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<ChallengeSubmissionGroupByOutputType, T['by']> & {
          [P in keyof T & keyof ChallengeSubmissionGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChallengeSubmissionGroupByOutputType[P]>
            : GetScalarType<T[P], ChallengeSubmissionGroupByOutputType[P]>;
        }
      >
    >;

  export type ChallengeSubmissionSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      challengeId?: boolean;
      userId?: boolean;
      teamId?: boolean;
      title?: boolean;
      repoUrl?: boolean;
      content?: boolean;
      files?: boolean;
      status?: boolean;
      score?: boolean;
      feedback?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      challenge?: boolean | ChallengeDefaultArgs<ExtArgs>;
      user?: boolean | ChallengeSubmission$userArgs<ExtArgs>;
      team?: boolean | ChallengeSubmission$teamArgs<ExtArgs>;
    },
    ExtArgs['result']['challengeSubmission']
  >;

  export type ChallengeSubmissionSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      challengeId?: boolean;
      userId?: boolean;
      teamId?: boolean;
      title?: boolean;
      repoUrl?: boolean;
      content?: boolean;
      files?: boolean;
      status?: boolean;
      score?: boolean;
      feedback?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      challenge?: boolean | ChallengeDefaultArgs<ExtArgs>;
      user?: boolean | ChallengeSubmission$userArgs<ExtArgs>;
      team?: boolean | ChallengeSubmission$teamArgs<ExtArgs>;
    },
    ExtArgs['result']['challengeSubmission']
  >;

  export type ChallengeSubmissionSelectScalar = {
    id?: boolean;
    challengeId?: boolean;
    userId?: boolean;
    teamId?: boolean;
    title?: boolean;
    repoUrl?: boolean;
    content?: boolean;
    files?: boolean;
    status?: boolean;
    score?: boolean;
    feedback?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type ChallengeSubmissionInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>;
    user?: boolean | ChallengeSubmission$userArgs<ExtArgs>;
    team?: boolean | ChallengeSubmission$teamArgs<ExtArgs>;
  };
  export type ChallengeSubmissionIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>;
    user?: boolean | ChallengeSubmission$userArgs<ExtArgs>;
    team?: boolean | ChallengeSubmission$teamArgs<ExtArgs>;
  };

  export type $ChallengeSubmissionPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'ChallengeSubmission';
    objects: {
      challenge: Prisma.$ChallengePayload<ExtArgs>;
      user: Prisma.$UserPayload<ExtArgs> | null;
      team: Prisma.$TeamPayload<ExtArgs> | null;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        challengeId: string;
        userId: string | null;
        teamId: string | null;
        title: string;
        repoUrl: string | null;
        content: string;
        files: string[];
        status: $Enums.ChallengeSubmissionStatus;
        score: Prisma.Decimal | null;
        feedback: string | null;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs['result']['challengeSubmission']
    >;
    composites: {};
  };

  type ChallengeSubmissionGetPayload<
    S extends boolean | null | undefined | ChallengeSubmissionDefaultArgs,
  > = $Result.GetResult<Prisma.$ChallengeSubmissionPayload, S>;

  type ChallengeSubmissionCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<ChallengeSubmissionFindManyArgs, 'select' | 'include' | 'distinct'> & {
    select?: ChallengeSubmissionCountAggregateInputType | true;
  };

  export interface ChallengeSubmissionDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['ChallengeSubmission'];
      meta: { name: 'ChallengeSubmission' };
    };
    /**
     * Find zero or one ChallengeSubmission that matches the filter.
     * @param {ChallengeSubmissionFindUniqueArgs} args - Arguments to find a ChallengeSubmission
     * @example
     * // Get one ChallengeSubmission
     * const challengeSubmission = await prisma.challengeSubmission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChallengeSubmissionFindUniqueArgs>(
      args: SelectSubset<T, ChallengeSubmissionFindUniqueArgs<ExtArgs>>
    ): Prisma__ChallengeSubmissionClient<
      $Result.GetResult<Prisma.$ChallengeSubmissionPayload<ExtArgs>, T, 'findUnique'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find one ChallengeSubmission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChallengeSubmissionFindUniqueOrThrowArgs} args - Arguments to find a ChallengeSubmission
     * @example
     * // Get one ChallengeSubmission
     * const challengeSubmission = await prisma.challengeSubmission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChallengeSubmissionFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ChallengeSubmissionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ChallengeSubmissionClient<
      $Result.GetResult<Prisma.$ChallengeSubmissionPayload<ExtArgs>, T, 'findUniqueOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find the first ChallengeSubmission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeSubmissionFindFirstArgs} args - Arguments to find a ChallengeSubmission
     * @example
     * // Get one ChallengeSubmission
     * const challengeSubmission = await prisma.challengeSubmission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChallengeSubmissionFindFirstArgs>(
      args?: SelectSubset<T, ChallengeSubmissionFindFirstArgs<ExtArgs>>
    ): Prisma__ChallengeSubmissionClient<
      $Result.GetResult<Prisma.$ChallengeSubmissionPayload<ExtArgs>, T, 'findFirst'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find the first ChallengeSubmission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeSubmissionFindFirstOrThrowArgs} args - Arguments to find a ChallengeSubmission
     * @example
     * // Get one ChallengeSubmission
     * const challengeSubmission = await prisma.challengeSubmission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChallengeSubmissionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ChallengeSubmissionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ChallengeSubmissionClient<
      $Result.GetResult<Prisma.$ChallengeSubmissionPayload<ExtArgs>, T, 'findFirstOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more ChallengeSubmissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeSubmissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChallengeSubmissions
     * const challengeSubmissions = await prisma.challengeSubmission.findMany()
     *
     * // Get first 10 ChallengeSubmissions
     * const challengeSubmissions = await prisma.challengeSubmission.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const challengeSubmissionWithIdOnly = await prisma.challengeSubmission.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ChallengeSubmissionFindManyArgs>(
      args?: SelectSubset<T, ChallengeSubmissionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ChallengeSubmissionPayload<ExtArgs>, T, 'findMany'>
    >;

    /**
     * Create a ChallengeSubmission.
     * @param {ChallengeSubmissionCreateArgs} args - Arguments to create a ChallengeSubmission.
     * @example
     * // Create one ChallengeSubmission
     * const ChallengeSubmission = await prisma.challengeSubmission.create({
     *   data: {
     *     // ... data to create a ChallengeSubmission
     *   }
     * })
     *
     */
    create<T extends ChallengeSubmissionCreateArgs>(
      args: SelectSubset<T, ChallengeSubmissionCreateArgs<ExtArgs>>
    ): Prisma__ChallengeSubmissionClient<
      $Result.GetResult<Prisma.$ChallengeSubmissionPayload<ExtArgs>, T, 'create'>,
      never,
      ExtArgs
    >;

    /**
     * Create many ChallengeSubmissions.
     * @param {ChallengeSubmissionCreateManyArgs} args - Arguments to create many ChallengeSubmissions.
     * @example
     * // Create many ChallengeSubmissions
     * const challengeSubmission = await prisma.challengeSubmission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ChallengeSubmissionCreateManyArgs>(
      args?: SelectSubset<T, ChallengeSubmissionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many ChallengeSubmissions and returns the data saved in the database.
     * @param {ChallengeSubmissionCreateManyAndReturnArgs} args - Arguments to create many ChallengeSubmissions.
     * @example
     * // Create many ChallengeSubmissions
     * const challengeSubmission = await prisma.challengeSubmission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many ChallengeSubmissions and only return the `id`
     * const challengeSubmissionWithIdOnly = await prisma.challengeSubmission.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends ChallengeSubmissionCreateManyAndReturnArgs>(
      args?: SelectSubset<T, ChallengeSubmissionCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ChallengeSubmissionPayload<ExtArgs>, T, 'createManyAndReturn'>
    >;

    /**
     * Delete a ChallengeSubmission.
     * @param {ChallengeSubmissionDeleteArgs} args - Arguments to delete one ChallengeSubmission.
     * @example
     * // Delete one ChallengeSubmission
     * const ChallengeSubmission = await prisma.challengeSubmission.delete({
     *   where: {
     *     // ... filter to delete one ChallengeSubmission
     *   }
     * })
     *
     */
    delete<T extends ChallengeSubmissionDeleteArgs>(
      args: SelectSubset<T, ChallengeSubmissionDeleteArgs<ExtArgs>>
    ): Prisma__ChallengeSubmissionClient<
      $Result.GetResult<Prisma.$ChallengeSubmissionPayload<ExtArgs>, T, 'delete'>,
      never,
      ExtArgs
    >;

    /**
     * Update one ChallengeSubmission.
     * @param {ChallengeSubmissionUpdateArgs} args - Arguments to update one ChallengeSubmission.
     * @example
     * // Update one ChallengeSubmission
     * const challengeSubmission = await prisma.challengeSubmission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ChallengeSubmissionUpdateArgs>(
      args: SelectSubset<T, ChallengeSubmissionUpdateArgs<ExtArgs>>
    ): Prisma__ChallengeSubmissionClient<
      $Result.GetResult<Prisma.$ChallengeSubmissionPayload<ExtArgs>, T, 'update'>,
      never,
      ExtArgs
    >;

    /**
     * Delete zero or more ChallengeSubmissions.
     * @param {ChallengeSubmissionDeleteManyArgs} args - Arguments to filter ChallengeSubmissions to delete.
     * @example
     * // Delete a few ChallengeSubmissions
     * const { count } = await prisma.challengeSubmission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ChallengeSubmissionDeleteManyArgs>(
      args?: SelectSubset<T, ChallengeSubmissionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more ChallengeSubmissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeSubmissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChallengeSubmissions
     * const challengeSubmission = await prisma.challengeSubmission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ChallengeSubmissionUpdateManyArgs>(
      args: SelectSubset<T, ChallengeSubmissionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one ChallengeSubmission.
     * @param {ChallengeSubmissionUpsertArgs} args - Arguments to update or create a ChallengeSubmission.
     * @example
     * // Update or create a ChallengeSubmission
     * const challengeSubmission = await prisma.challengeSubmission.upsert({
     *   create: {
     *     // ... data to create a ChallengeSubmission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChallengeSubmission we want to update
     *   }
     * })
     */
    upsert<T extends ChallengeSubmissionUpsertArgs>(
      args: SelectSubset<T, ChallengeSubmissionUpsertArgs<ExtArgs>>
    ): Prisma__ChallengeSubmissionClient<
      $Result.GetResult<Prisma.$ChallengeSubmissionPayload<ExtArgs>, T, 'upsert'>,
      never,
      ExtArgs
    >;

    /**
     * Count the number of ChallengeSubmissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeSubmissionCountArgs} args - Arguments to filter ChallengeSubmissions to count.
     * @example
     * // Count the number of ChallengeSubmissions
     * const count = await prisma.challengeSubmission.count({
     *   where: {
     *     // ... the filter for the ChallengeSubmissions we want to count
     *   }
     * })
     **/
    count<T extends ChallengeSubmissionCountArgs>(
      args?: Subset<T, ChallengeSubmissionCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChallengeSubmissionCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a ChallengeSubmission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeSubmissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ChallengeSubmissionAggregateArgs>(
      args: Subset<T, ChallengeSubmissionAggregateArgs>
    ): Prisma.PrismaPromise<GetChallengeSubmissionAggregateType<T>>;

    /**
     * Group by ChallengeSubmission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeSubmissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends ChallengeSubmissionGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChallengeSubmissionGroupByArgs['orderBy'] }
        : { orderBy?: ChallengeSubmissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, ChallengeSubmissionGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetChallengeSubmissionGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the ChallengeSubmission model
     */
    readonly fields: ChallengeSubmissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChallengeSubmission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChallengeSubmissionClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    challenge<T extends ChallengeDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, ChallengeDefaultArgs<ExtArgs>>
    ): Prisma__ChallengeClient<
      $Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null,
      Null,
      ExtArgs
    >;
    user<T extends ChallengeSubmission$userArgs<ExtArgs> = {}>(
      args?: Subset<T, ChallengeSubmission$userArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null,
      null,
      ExtArgs
    >;
    team<T extends ChallengeSubmission$teamArgs<ExtArgs> = {}>(
      args?: Subset<T, ChallengeSubmission$teamArgs<ExtArgs>>
    ): Prisma__TeamClient<
      $Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null,
      null,
      ExtArgs
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the ChallengeSubmission model
   */
  interface ChallengeSubmissionFieldRefs {
    readonly id: FieldRef<'ChallengeSubmission', 'String'>;
    readonly challengeId: FieldRef<'ChallengeSubmission', 'String'>;
    readonly userId: FieldRef<'ChallengeSubmission', 'String'>;
    readonly teamId: FieldRef<'ChallengeSubmission', 'String'>;
    readonly title: FieldRef<'ChallengeSubmission', 'String'>;
    readonly repoUrl: FieldRef<'ChallengeSubmission', 'String'>;
    readonly content: FieldRef<'ChallengeSubmission', 'String'>;
    readonly files: FieldRef<'ChallengeSubmission', 'String[]'>;
    readonly status: FieldRef<'ChallengeSubmission', 'ChallengeSubmissionStatus'>;
    readonly score: FieldRef<'ChallengeSubmission', 'Decimal'>;
    readonly feedback: FieldRef<'ChallengeSubmission', 'String'>;
    readonly createdAt: FieldRef<'ChallengeSubmission', 'DateTime'>;
    readonly updatedAt: FieldRef<'ChallengeSubmission', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * ChallengeSubmission findUnique
   */
  export type ChallengeSubmissionFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ChallengeSubmission
     */
    select?: ChallengeSubmissionSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeSubmissionInclude<ExtArgs> | null;
    /**
     * Filter, which ChallengeSubmission to fetch.
     */
    where: ChallengeSubmissionWhereUniqueInput;
  };

  /**
   * ChallengeSubmission findUniqueOrThrow
   */
  export type ChallengeSubmissionFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ChallengeSubmission
     */
    select?: ChallengeSubmissionSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeSubmissionInclude<ExtArgs> | null;
    /**
     * Filter, which ChallengeSubmission to fetch.
     */
    where: ChallengeSubmissionWhereUniqueInput;
  };

  /**
   * ChallengeSubmission findFirst
   */
  export type ChallengeSubmissionFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ChallengeSubmission
     */
    select?: ChallengeSubmissionSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeSubmissionInclude<ExtArgs> | null;
    /**
     * Filter, which ChallengeSubmission to fetch.
     */
    where?: ChallengeSubmissionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ChallengeSubmissions to fetch.
     */
    orderBy?:
      | ChallengeSubmissionOrderByWithRelationInput
      | ChallengeSubmissionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ChallengeSubmissions.
     */
    cursor?: ChallengeSubmissionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ChallengeSubmissions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ChallengeSubmissions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ChallengeSubmissions.
     */
    distinct?: ChallengeSubmissionScalarFieldEnum | ChallengeSubmissionScalarFieldEnum[];
  };

  /**
   * ChallengeSubmission findFirstOrThrow
   */
  export type ChallengeSubmissionFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ChallengeSubmission
     */
    select?: ChallengeSubmissionSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeSubmissionInclude<ExtArgs> | null;
    /**
     * Filter, which ChallengeSubmission to fetch.
     */
    where?: ChallengeSubmissionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ChallengeSubmissions to fetch.
     */
    orderBy?:
      | ChallengeSubmissionOrderByWithRelationInput
      | ChallengeSubmissionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ChallengeSubmissions.
     */
    cursor?: ChallengeSubmissionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ChallengeSubmissions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ChallengeSubmissions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ChallengeSubmissions.
     */
    distinct?: ChallengeSubmissionScalarFieldEnum | ChallengeSubmissionScalarFieldEnum[];
  };

  /**
   * ChallengeSubmission findMany
   */
  export type ChallengeSubmissionFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ChallengeSubmission
     */
    select?: ChallengeSubmissionSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeSubmissionInclude<ExtArgs> | null;
    /**
     * Filter, which ChallengeSubmissions to fetch.
     */
    where?: ChallengeSubmissionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ChallengeSubmissions to fetch.
     */
    orderBy?:
      | ChallengeSubmissionOrderByWithRelationInput
      | ChallengeSubmissionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing ChallengeSubmissions.
     */
    cursor?: ChallengeSubmissionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ChallengeSubmissions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ChallengeSubmissions.
     */
    skip?: number;
    distinct?: ChallengeSubmissionScalarFieldEnum | ChallengeSubmissionScalarFieldEnum[];
  };

  /**
   * ChallengeSubmission create
   */
  export type ChallengeSubmissionCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ChallengeSubmission
     */
    select?: ChallengeSubmissionSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeSubmissionInclude<ExtArgs> | null;
    /**
     * The data needed to create a ChallengeSubmission.
     */
    data: XOR<ChallengeSubmissionCreateInput, ChallengeSubmissionUncheckedCreateInput>;
  };

  /**
   * ChallengeSubmission createMany
   */
  export type ChallengeSubmissionCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many ChallengeSubmissions.
     */
    data: ChallengeSubmissionCreateManyInput | ChallengeSubmissionCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * ChallengeSubmission createManyAndReturn
   */
  export type ChallengeSubmissionCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ChallengeSubmission
     */
    select?: ChallengeSubmissionSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * The data used to create many ChallengeSubmissions.
     */
    data: ChallengeSubmissionCreateManyInput | ChallengeSubmissionCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeSubmissionIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * ChallengeSubmission update
   */
  export type ChallengeSubmissionUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ChallengeSubmission
     */
    select?: ChallengeSubmissionSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeSubmissionInclude<ExtArgs> | null;
    /**
     * The data needed to update a ChallengeSubmission.
     */
    data: XOR<ChallengeSubmissionUpdateInput, ChallengeSubmissionUncheckedUpdateInput>;
    /**
     * Choose, which ChallengeSubmission to update.
     */
    where: ChallengeSubmissionWhereUniqueInput;
  };

  /**
   * ChallengeSubmission updateMany
   */
  export type ChallengeSubmissionUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update ChallengeSubmissions.
     */
    data: XOR<
      ChallengeSubmissionUpdateManyMutationInput,
      ChallengeSubmissionUncheckedUpdateManyInput
    >;
    /**
     * Filter which ChallengeSubmissions to update
     */
    where?: ChallengeSubmissionWhereInput;
  };

  /**
   * ChallengeSubmission upsert
   */
  export type ChallengeSubmissionUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ChallengeSubmission
     */
    select?: ChallengeSubmissionSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeSubmissionInclude<ExtArgs> | null;
    /**
     * The filter to search for the ChallengeSubmission to update in case it exists.
     */
    where: ChallengeSubmissionWhereUniqueInput;
    /**
     * In case the ChallengeSubmission found by the `where` argument doesn't exist, create a new ChallengeSubmission with this data.
     */
    create: XOR<ChallengeSubmissionCreateInput, ChallengeSubmissionUncheckedCreateInput>;
    /**
     * In case the ChallengeSubmission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChallengeSubmissionUpdateInput, ChallengeSubmissionUncheckedUpdateInput>;
  };

  /**
   * ChallengeSubmission delete
   */
  export type ChallengeSubmissionDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ChallengeSubmission
     */
    select?: ChallengeSubmissionSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeSubmissionInclude<ExtArgs> | null;
    /**
     * Filter which ChallengeSubmission to delete.
     */
    where: ChallengeSubmissionWhereUniqueInput;
  };

  /**
   * ChallengeSubmission deleteMany
   */
  export type ChallengeSubmissionDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which ChallengeSubmissions to delete
     */
    where?: ChallengeSubmissionWhereInput;
  };

  /**
   * ChallengeSubmission.user
   */
  export type ChallengeSubmission$userArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    where?: UserWhereInput;
  };

  /**
   * ChallengeSubmission.team
   */
  export type ChallengeSubmission$teamArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null;
    where?: TeamWhereInput;
  };

  /**
   * ChallengeSubmission without action
   */
  export type ChallengeSubmissionDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ChallengeSubmission
     */
    select?: ChallengeSubmissionSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeSubmissionInclude<ExtArgs> | null;
  };

  /**
   * Model Announcement
   */

  export type AggregateAnnouncement = {
    _count: AnnouncementCountAggregateOutputType | null;
    _min: AnnouncementMinAggregateOutputType | null;
    _max: AnnouncementMaxAggregateOutputType | null;
  };

  export type AnnouncementMinAggregateOutputType = {
    id: string | null;
    scope: $Enums.AnnouncementScope | null;
    scopeId: string | null;
    title: string | null;
    body: string | null;
    pinned: boolean | null;
    publishedAt: Date | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type AnnouncementMaxAggregateOutputType = {
    id: string | null;
    scope: $Enums.AnnouncementScope | null;
    scopeId: string | null;
    title: string | null;
    body: string | null;
    pinned: boolean | null;
    publishedAt: Date | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type AnnouncementCountAggregateOutputType = {
    id: number;
    scope: number;
    scopeId: number;
    title: number;
    body: number;
    pinned: number;
    publishedAt: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type AnnouncementMinAggregateInputType = {
    id?: true;
    scope?: true;
    scopeId?: true;
    title?: true;
    body?: true;
    pinned?: true;
    publishedAt?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type AnnouncementMaxAggregateInputType = {
    id?: true;
    scope?: true;
    scopeId?: true;
    title?: true;
    body?: true;
    pinned?: true;
    publishedAt?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type AnnouncementCountAggregateInputType = {
    id?: true;
    scope?: true;
    scopeId?: true;
    title?: true;
    body?: true;
    pinned?: true;
    publishedAt?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type AnnouncementAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Announcement to aggregate.
     */
    where?: AnnouncementWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Announcements to fetch.
     */
    orderBy?: AnnouncementOrderByWithRelationInput | AnnouncementOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: AnnouncementWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Announcements from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Announcements.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Announcements
     **/
    _count?: true | AnnouncementCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: AnnouncementMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: AnnouncementMaxAggregateInputType;
  };

  export type GetAnnouncementAggregateType<T extends AnnouncementAggregateArgs> = {
    [P in keyof T & keyof AggregateAnnouncement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnnouncement[P]>
      : GetScalarType<T[P], AggregateAnnouncement[P]>;
  };

  export type AnnouncementGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AnnouncementWhereInput;
    orderBy?: AnnouncementOrderByWithAggregationInput | AnnouncementOrderByWithAggregationInput[];
    by: AnnouncementScalarFieldEnum[] | AnnouncementScalarFieldEnum;
    having?: AnnouncementScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: AnnouncementCountAggregateInputType | true;
    _min?: AnnouncementMinAggregateInputType;
    _max?: AnnouncementMaxAggregateInputType;
  };

  export type AnnouncementGroupByOutputType = {
    id: string;
    scope: $Enums.AnnouncementScope;
    scopeId: string | null;
    title: string;
    body: string;
    pinned: boolean;
    publishedAt: Date | null;
    createdAt: Date;
    updatedAt: Date;
    _count: AnnouncementCountAggregateOutputType | null;
    _min: AnnouncementMinAggregateOutputType | null;
    _max: AnnouncementMaxAggregateOutputType | null;
  };

  type GetAnnouncementGroupByPayload<T extends AnnouncementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnnouncementGroupByOutputType, T['by']> & {
        [P in keyof T & keyof AnnouncementGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], AnnouncementGroupByOutputType[P]>
          : GetScalarType<T[P], AnnouncementGroupByOutputType[P]>;
      }
    >
  >;

  export type AnnouncementSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      scope?: boolean;
      scopeId?: boolean;
      title?: boolean;
      body?: boolean;
      pinned?: boolean;
      publishedAt?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      hackathon?: boolean | Announcement$hackathonArgs<ExtArgs>;
    },
    ExtArgs['result']['announcement']
  >;

  export type AnnouncementSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      scope?: boolean;
      scopeId?: boolean;
      title?: boolean;
      body?: boolean;
      pinned?: boolean;
      publishedAt?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      hackathon?: boolean | Announcement$hackathonArgs<ExtArgs>;
    },
    ExtArgs['result']['announcement']
  >;

  export type AnnouncementSelectScalar = {
    id?: boolean;
    scope?: boolean;
    scopeId?: boolean;
    title?: boolean;
    body?: boolean;
    pinned?: boolean;
    publishedAt?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type AnnouncementInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    hackathon?: boolean | Announcement$hackathonArgs<ExtArgs>;
  };
  export type AnnouncementIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    hackathon?: boolean | Announcement$hackathonArgs<ExtArgs>;
  };

  export type $AnnouncementPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'Announcement';
    objects: {
      hackathon: Prisma.$HackathonPayload<ExtArgs> | null;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        scope: $Enums.AnnouncementScope;
        scopeId: string | null;
        title: string;
        body: string;
        pinned: boolean;
        publishedAt: Date | null;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs['result']['announcement']
    >;
    composites: {};
  };

  type AnnouncementGetPayload<S extends boolean | null | undefined | AnnouncementDefaultArgs> =
    $Result.GetResult<Prisma.$AnnouncementPayload, S>;

  type AnnouncementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AnnouncementFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AnnouncementCountAggregateInputType | true;
    };

  export interface AnnouncementDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Announcement'];
      meta: { name: 'Announcement' };
    };
    /**
     * Find zero or one Announcement that matches the filter.
     * @param {AnnouncementFindUniqueArgs} args - Arguments to find a Announcement
     * @example
     * // Get one Announcement
     * const announcement = await prisma.announcement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnnouncementFindUniqueArgs>(
      args: SelectSubset<T, AnnouncementFindUniqueArgs<ExtArgs>>
    ): Prisma__AnnouncementClient<
      $Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, 'findUnique'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find one Announcement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AnnouncementFindUniqueOrThrowArgs} args - Arguments to find a Announcement
     * @example
     * // Get one Announcement
     * const announcement = await prisma.announcement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnnouncementFindUniqueOrThrowArgs>(
      args: SelectSubset<T, AnnouncementFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AnnouncementClient<
      $Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, 'findUniqueOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find the first Announcement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementFindFirstArgs} args - Arguments to find a Announcement
     * @example
     * // Get one Announcement
     * const announcement = await prisma.announcement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnnouncementFindFirstArgs>(
      args?: SelectSubset<T, AnnouncementFindFirstArgs<ExtArgs>>
    ): Prisma__AnnouncementClient<
      $Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, 'findFirst'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find the first Announcement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementFindFirstOrThrowArgs} args - Arguments to find a Announcement
     * @example
     * // Get one Announcement
     * const announcement = await prisma.announcement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnnouncementFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AnnouncementFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AnnouncementClient<
      $Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, 'findFirstOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more Announcements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Announcements
     * const announcements = await prisma.announcement.findMany()
     *
     * // Get first 10 Announcements
     * const announcements = await prisma.announcement.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const announcementWithIdOnly = await prisma.announcement.findMany({ select: { id: true } })
     *
     */
    findMany<T extends AnnouncementFindManyArgs>(
      args?: SelectSubset<T, AnnouncementFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, 'findMany'>>;

    /**
     * Create a Announcement.
     * @param {AnnouncementCreateArgs} args - Arguments to create a Announcement.
     * @example
     * // Create one Announcement
     * const Announcement = await prisma.announcement.create({
     *   data: {
     *     // ... data to create a Announcement
     *   }
     * })
     *
     */
    create<T extends AnnouncementCreateArgs>(
      args: SelectSubset<T, AnnouncementCreateArgs<ExtArgs>>
    ): Prisma__AnnouncementClient<
      $Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, 'create'>,
      never,
      ExtArgs
    >;

    /**
     * Create many Announcements.
     * @param {AnnouncementCreateManyArgs} args - Arguments to create many Announcements.
     * @example
     * // Create many Announcements
     * const announcement = await prisma.announcement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends AnnouncementCreateManyArgs>(
      args?: SelectSubset<T, AnnouncementCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Announcements and returns the data saved in the database.
     * @param {AnnouncementCreateManyAndReturnArgs} args - Arguments to create many Announcements.
     * @example
     * // Create many Announcements
     * const announcement = await prisma.announcement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Announcements and only return the `id`
     * const announcementWithIdOnly = await prisma.announcement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends AnnouncementCreateManyAndReturnArgs>(
      args?: SelectSubset<T, AnnouncementCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, 'createManyAndReturn'>
    >;

    /**
     * Delete a Announcement.
     * @param {AnnouncementDeleteArgs} args - Arguments to delete one Announcement.
     * @example
     * // Delete one Announcement
     * const Announcement = await prisma.announcement.delete({
     *   where: {
     *     // ... filter to delete one Announcement
     *   }
     * })
     *
     */
    delete<T extends AnnouncementDeleteArgs>(
      args: SelectSubset<T, AnnouncementDeleteArgs<ExtArgs>>
    ): Prisma__AnnouncementClient<
      $Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, 'delete'>,
      never,
      ExtArgs
    >;

    /**
     * Update one Announcement.
     * @param {AnnouncementUpdateArgs} args - Arguments to update one Announcement.
     * @example
     * // Update one Announcement
     * const announcement = await prisma.announcement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends AnnouncementUpdateArgs>(
      args: SelectSubset<T, AnnouncementUpdateArgs<ExtArgs>>
    ): Prisma__AnnouncementClient<
      $Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, 'update'>,
      never,
      ExtArgs
    >;

    /**
     * Delete zero or more Announcements.
     * @param {AnnouncementDeleteManyArgs} args - Arguments to filter Announcements to delete.
     * @example
     * // Delete a few Announcements
     * const { count } = await prisma.announcement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends AnnouncementDeleteManyArgs>(
      args?: SelectSubset<T, AnnouncementDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Announcements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Announcements
     * const announcement = await prisma.announcement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends AnnouncementUpdateManyArgs>(
      args: SelectSubset<T, AnnouncementUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Announcement.
     * @param {AnnouncementUpsertArgs} args - Arguments to update or create a Announcement.
     * @example
     * // Update or create a Announcement
     * const announcement = await prisma.announcement.upsert({
     *   create: {
     *     // ... data to create a Announcement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Announcement we want to update
     *   }
     * })
     */
    upsert<T extends AnnouncementUpsertArgs>(
      args: SelectSubset<T, AnnouncementUpsertArgs<ExtArgs>>
    ): Prisma__AnnouncementClient<
      $Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, 'upsert'>,
      never,
      ExtArgs
    >;

    /**
     * Count the number of Announcements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementCountArgs} args - Arguments to filter Announcements to count.
     * @example
     * // Count the number of Announcements
     * const count = await prisma.announcement.count({
     *   where: {
     *     // ... the filter for the Announcements we want to count
     *   }
     * })
     **/
    count<T extends AnnouncementCountArgs>(
      args?: Subset<T, AnnouncementCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnnouncementCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Announcement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends AnnouncementAggregateArgs>(
      args: Subset<T, AnnouncementAggregateArgs>
    ): Prisma.PrismaPromise<GetAnnouncementAggregateType<T>>;

    /**
     * Group by Announcement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends AnnouncementGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnnouncementGroupByArgs['orderBy'] }
        : { orderBy?: AnnouncementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, AnnouncementGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetAnnouncementGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Announcement model
     */
    readonly fields: AnnouncementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Announcement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnnouncementClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    hackathon<T extends Announcement$hackathonArgs<ExtArgs> = {}>(
      args?: Subset<T, Announcement$hackathonArgs<ExtArgs>>
    ): Prisma__HackathonClient<
      $Result.GetResult<Prisma.$HackathonPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null,
      null,
      ExtArgs
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Announcement model
   */
  interface AnnouncementFieldRefs {
    readonly id: FieldRef<'Announcement', 'String'>;
    readonly scope: FieldRef<'Announcement', 'AnnouncementScope'>;
    readonly scopeId: FieldRef<'Announcement', 'String'>;
    readonly title: FieldRef<'Announcement', 'String'>;
    readonly body: FieldRef<'Announcement', 'String'>;
    readonly pinned: FieldRef<'Announcement', 'Boolean'>;
    readonly publishedAt: FieldRef<'Announcement', 'DateTime'>;
    readonly createdAt: FieldRef<'Announcement', 'DateTime'>;
    readonly updatedAt: FieldRef<'Announcement', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * Announcement findUnique
   */
  export type AnnouncementFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null;
    /**
     * Filter, which Announcement to fetch.
     */
    where: AnnouncementWhereUniqueInput;
  };

  /**
   * Announcement findUniqueOrThrow
   */
  export type AnnouncementFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null;
    /**
     * Filter, which Announcement to fetch.
     */
    where: AnnouncementWhereUniqueInput;
  };

  /**
   * Announcement findFirst
   */
  export type AnnouncementFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null;
    /**
     * Filter, which Announcement to fetch.
     */
    where?: AnnouncementWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Announcements to fetch.
     */
    orderBy?: AnnouncementOrderByWithRelationInput | AnnouncementOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Announcements.
     */
    cursor?: AnnouncementWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Announcements from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Announcements.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Announcements.
     */
    distinct?: AnnouncementScalarFieldEnum | AnnouncementScalarFieldEnum[];
  };

  /**
   * Announcement findFirstOrThrow
   */
  export type AnnouncementFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null;
    /**
     * Filter, which Announcement to fetch.
     */
    where?: AnnouncementWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Announcements to fetch.
     */
    orderBy?: AnnouncementOrderByWithRelationInput | AnnouncementOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Announcements.
     */
    cursor?: AnnouncementWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Announcements from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Announcements.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Announcements.
     */
    distinct?: AnnouncementScalarFieldEnum | AnnouncementScalarFieldEnum[];
  };

  /**
   * Announcement findMany
   */
  export type AnnouncementFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null;
    /**
     * Filter, which Announcements to fetch.
     */
    where?: AnnouncementWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Announcements to fetch.
     */
    orderBy?: AnnouncementOrderByWithRelationInput | AnnouncementOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Announcements.
     */
    cursor?: AnnouncementWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Announcements from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Announcements.
     */
    skip?: number;
    distinct?: AnnouncementScalarFieldEnum | AnnouncementScalarFieldEnum[];
  };

  /**
   * Announcement create
   */
  export type AnnouncementCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null;
    /**
     * The data needed to create a Announcement.
     */
    data: XOR<AnnouncementCreateInput, AnnouncementUncheckedCreateInput>;
  };

  /**
   * Announcement createMany
   */
  export type AnnouncementCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Announcements.
     */
    data: AnnouncementCreateManyInput | AnnouncementCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Announcement createManyAndReturn
   */
  export type AnnouncementCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * The data used to create many Announcements.
     */
    data: AnnouncementCreateManyInput | AnnouncementCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Announcement update
   */
  export type AnnouncementUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null;
    /**
     * The data needed to update a Announcement.
     */
    data: XOR<AnnouncementUpdateInput, AnnouncementUncheckedUpdateInput>;
    /**
     * Choose, which Announcement to update.
     */
    where: AnnouncementWhereUniqueInput;
  };

  /**
   * Announcement updateMany
   */
  export type AnnouncementUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Announcements.
     */
    data: XOR<AnnouncementUpdateManyMutationInput, AnnouncementUncheckedUpdateManyInput>;
    /**
     * Filter which Announcements to update
     */
    where?: AnnouncementWhereInput;
  };

  /**
   * Announcement upsert
   */
  export type AnnouncementUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null;
    /**
     * The filter to search for the Announcement to update in case it exists.
     */
    where: AnnouncementWhereUniqueInput;
    /**
     * In case the Announcement found by the `where` argument doesn't exist, create a new Announcement with this data.
     */
    create: XOR<AnnouncementCreateInput, AnnouncementUncheckedCreateInput>;
    /**
     * In case the Announcement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnnouncementUpdateInput, AnnouncementUncheckedUpdateInput>;
  };

  /**
   * Announcement delete
   */
  export type AnnouncementDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null;
    /**
     * Filter which Announcement to delete.
     */
    where: AnnouncementWhereUniqueInput;
  };

  /**
   * Announcement deleteMany
   */
  export type AnnouncementDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Announcements to delete
     */
    where?: AnnouncementWhereInput;
  };

  /**
   * Announcement.hackathon
   */
  export type Announcement$hackathonArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Hackathon
     */
    select?: HackathonSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HackathonInclude<ExtArgs> | null;
    where?: HackathonWhereInput;
  };

  /**
   * Announcement without action
   */
  export type AnnouncementDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null;
  };

  /**
   * Model CommentThread
   */

  export type AggregateCommentThread = {
    _count: CommentThreadCountAggregateOutputType | null;
    _min: CommentThreadMinAggregateOutputType | null;
    _max: CommentThreadMaxAggregateOutputType | null;
  };

  export type CommentThreadMinAggregateOutputType = {
    id: string | null;
    entityType: $Enums.CommentEntityType | null;
    entityId: string | null;
    createdAt: Date | null;
  };

  export type CommentThreadMaxAggregateOutputType = {
    id: string | null;
    entityType: $Enums.CommentEntityType | null;
    entityId: string | null;
    createdAt: Date | null;
  };

  export type CommentThreadCountAggregateOutputType = {
    id: number;
    entityType: number;
    entityId: number;
    createdAt: number;
    _all: number;
  };

  export type CommentThreadMinAggregateInputType = {
    id?: true;
    entityType?: true;
    entityId?: true;
    createdAt?: true;
  };

  export type CommentThreadMaxAggregateInputType = {
    id?: true;
    entityType?: true;
    entityId?: true;
    createdAt?: true;
  };

  export type CommentThreadCountAggregateInputType = {
    id?: true;
    entityType?: true;
    entityId?: true;
    createdAt?: true;
    _all?: true;
  };

  export type CommentThreadAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which CommentThread to aggregate.
     */
    where?: CommentThreadWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of CommentThreads to fetch.
     */
    orderBy?: CommentThreadOrderByWithRelationInput | CommentThreadOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: CommentThreadWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` CommentThreads from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` CommentThreads.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned CommentThreads
     **/
    _count?: true | CommentThreadCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: CommentThreadMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: CommentThreadMaxAggregateInputType;
  };

  export type GetCommentThreadAggregateType<T extends CommentThreadAggregateArgs> = {
    [P in keyof T & keyof AggregateCommentThread]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommentThread[P]>
      : GetScalarType<T[P], AggregateCommentThread[P]>;
  };

  export type CommentThreadGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: CommentThreadWhereInput;
    orderBy?: CommentThreadOrderByWithAggregationInput | CommentThreadOrderByWithAggregationInput[];
    by: CommentThreadScalarFieldEnum[] | CommentThreadScalarFieldEnum;
    having?: CommentThreadScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: CommentThreadCountAggregateInputType | true;
    _min?: CommentThreadMinAggregateInputType;
    _max?: CommentThreadMaxAggregateInputType;
  };

  export type CommentThreadGroupByOutputType = {
    id: string;
    entityType: $Enums.CommentEntityType;
    entityId: string;
    createdAt: Date;
    _count: CommentThreadCountAggregateOutputType | null;
    _min: CommentThreadMinAggregateOutputType | null;
    _max: CommentThreadMaxAggregateOutputType | null;
  };

  type GetCommentThreadGroupByPayload<T extends CommentThreadGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentThreadGroupByOutputType, T['by']> & {
        [P in keyof T & keyof CommentThreadGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], CommentThreadGroupByOutputType[P]>
          : GetScalarType<T[P], CommentThreadGroupByOutputType[P]>;
      }
    >
  >;

  export type CommentThreadSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      entityType?: boolean;
      entityId?: boolean;
      createdAt?: boolean;
      comments?: boolean | CommentThread$commentsArgs<ExtArgs>;
      _count?: boolean | CommentThreadCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['commentThread']
  >;

  export type CommentThreadSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      entityType?: boolean;
      entityId?: boolean;
      createdAt?: boolean;
    },
    ExtArgs['result']['commentThread']
  >;

  export type CommentThreadSelectScalar = {
    id?: boolean;
    entityType?: boolean;
    entityId?: boolean;
    createdAt?: boolean;
  };

  export type CommentThreadInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    comments?: boolean | CommentThread$commentsArgs<ExtArgs>;
    _count?: boolean | CommentThreadCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type CommentThreadIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};

  export type $CommentThreadPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'CommentThread';
    objects: {
      comments: Prisma.$CommentPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        entityType: $Enums.CommentEntityType;
        entityId: string;
        createdAt: Date;
      },
      ExtArgs['result']['commentThread']
    >;
    composites: {};
  };

  type CommentThreadGetPayload<S extends boolean | null | undefined | CommentThreadDefaultArgs> =
    $Result.GetResult<Prisma.$CommentThreadPayload, S>;

  type CommentThreadCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CommentThreadFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CommentThreadCountAggregateInputType | true;
    };

  export interface CommentThreadDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['CommentThread'];
      meta: { name: 'CommentThread' };
    };
    /**
     * Find zero or one CommentThread that matches the filter.
     * @param {CommentThreadFindUniqueArgs} args - Arguments to find a CommentThread
     * @example
     * // Get one CommentThread
     * const commentThread = await prisma.commentThread.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommentThreadFindUniqueArgs>(
      args: SelectSubset<T, CommentThreadFindUniqueArgs<ExtArgs>>
    ): Prisma__CommentThreadClient<
      $Result.GetResult<Prisma.$CommentThreadPayload<ExtArgs>, T, 'findUnique'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find one CommentThread that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CommentThreadFindUniqueOrThrowArgs} args - Arguments to find a CommentThread
     * @example
     * // Get one CommentThread
     * const commentThread = await prisma.commentThread.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommentThreadFindUniqueOrThrowArgs>(
      args: SelectSubset<T, CommentThreadFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CommentThreadClient<
      $Result.GetResult<Prisma.$CommentThreadPayload<ExtArgs>, T, 'findUniqueOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find the first CommentThread that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentThreadFindFirstArgs} args - Arguments to find a CommentThread
     * @example
     * // Get one CommentThread
     * const commentThread = await prisma.commentThread.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommentThreadFindFirstArgs>(
      args?: SelectSubset<T, CommentThreadFindFirstArgs<ExtArgs>>
    ): Prisma__CommentThreadClient<
      $Result.GetResult<Prisma.$CommentThreadPayload<ExtArgs>, T, 'findFirst'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find the first CommentThread that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentThreadFindFirstOrThrowArgs} args - Arguments to find a CommentThread
     * @example
     * // Get one CommentThread
     * const commentThread = await prisma.commentThread.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommentThreadFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CommentThreadFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CommentThreadClient<
      $Result.GetResult<Prisma.$CommentThreadPayload<ExtArgs>, T, 'findFirstOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more CommentThreads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentThreadFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CommentThreads
     * const commentThreads = await prisma.commentThread.findMany()
     *
     * // Get first 10 CommentThreads
     * const commentThreads = await prisma.commentThread.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const commentThreadWithIdOnly = await prisma.commentThread.findMany({ select: { id: true } })
     *
     */
    findMany<T extends CommentThreadFindManyArgs>(
      args?: SelectSubset<T, CommentThreadFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$CommentThreadPayload<ExtArgs>, T, 'findMany'>
    >;

    /**
     * Create a CommentThread.
     * @param {CommentThreadCreateArgs} args - Arguments to create a CommentThread.
     * @example
     * // Create one CommentThread
     * const CommentThread = await prisma.commentThread.create({
     *   data: {
     *     // ... data to create a CommentThread
     *   }
     * })
     *
     */
    create<T extends CommentThreadCreateArgs>(
      args: SelectSubset<T, CommentThreadCreateArgs<ExtArgs>>
    ): Prisma__CommentThreadClient<
      $Result.GetResult<Prisma.$CommentThreadPayload<ExtArgs>, T, 'create'>,
      never,
      ExtArgs
    >;

    /**
     * Create many CommentThreads.
     * @param {CommentThreadCreateManyArgs} args - Arguments to create many CommentThreads.
     * @example
     * // Create many CommentThreads
     * const commentThread = await prisma.commentThread.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends CommentThreadCreateManyArgs>(
      args?: SelectSubset<T, CommentThreadCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many CommentThreads and returns the data saved in the database.
     * @param {CommentThreadCreateManyAndReturnArgs} args - Arguments to create many CommentThreads.
     * @example
     * // Create many CommentThreads
     * const commentThread = await prisma.commentThread.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many CommentThreads and only return the `id`
     * const commentThreadWithIdOnly = await prisma.commentThread.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends CommentThreadCreateManyAndReturnArgs>(
      args?: SelectSubset<T, CommentThreadCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$CommentThreadPayload<ExtArgs>, T, 'createManyAndReturn'>
    >;

    /**
     * Delete a CommentThread.
     * @param {CommentThreadDeleteArgs} args - Arguments to delete one CommentThread.
     * @example
     * // Delete one CommentThread
     * const CommentThread = await prisma.commentThread.delete({
     *   where: {
     *     // ... filter to delete one CommentThread
     *   }
     * })
     *
     */
    delete<T extends CommentThreadDeleteArgs>(
      args: SelectSubset<T, CommentThreadDeleteArgs<ExtArgs>>
    ): Prisma__CommentThreadClient<
      $Result.GetResult<Prisma.$CommentThreadPayload<ExtArgs>, T, 'delete'>,
      never,
      ExtArgs
    >;

    /**
     * Update one CommentThread.
     * @param {CommentThreadUpdateArgs} args - Arguments to update one CommentThread.
     * @example
     * // Update one CommentThread
     * const commentThread = await prisma.commentThread.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends CommentThreadUpdateArgs>(
      args: SelectSubset<T, CommentThreadUpdateArgs<ExtArgs>>
    ): Prisma__CommentThreadClient<
      $Result.GetResult<Prisma.$CommentThreadPayload<ExtArgs>, T, 'update'>,
      never,
      ExtArgs
    >;

    /**
     * Delete zero or more CommentThreads.
     * @param {CommentThreadDeleteManyArgs} args - Arguments to filter CommentThreads to delete.
     * @example
     * // Delete a few CommentThreads
     * const { count } = await prisma.commentThread.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends CommentThreadDeleteManyArgs>(
      args?: SelectSubset<T, CommentThreadDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more CommentThreads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentThreadUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CommentThreads
     * const commentThread = await prisma.commentThread.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends CommentThreadUpdateManyArgs>(
      args: SelectSubset<T, CommentThreadUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one CommentThread.
     * @param {CommentThreadUpsertArgs} args - Arguments to update or create a CommentThread.
     * @example
     * // Update or create a CommentThread
     * const commentThread = await prisma.commentThread.upsert({
     *   create: {
     *     // ... data to create a CommentThread
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CommentThread we want to update
     *   }
     * })
     */
    upsert<T extends CommentThreadUpsertArgs>(
      args: SelectSubset<T, CommentThreadUpsertArgs<ExtArgs>>
    ): Prisma__CommentThreadClient<
      $Result.GetResult<Prisma.$CommentThreadPayload<ExtArgs>, T, 'upsert'>,
      never,
      ExtArgs
    >;

    /**
     * Count the number of CommentThreads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentThreadCountArgs} args - Arguments to filter CommentThreads to count.
     * @example
     * // Count the number of CommentThreads
     * const count = await prisma.commentThread.count({
     *   where: {
     *     // ... the filter for the CommentThreads we want to count
     *   }
     * })
     **/
    count<T extends CommentThreadCountArgs>(
      args?: Subset<T, CommentThreadCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentThreadCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a CommentThread.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentThreadAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends CommentThreadAggregateArgs>(
      args: Subset<T, CommentThreadAggregateArgs>
    ): Prisma.PrismaPromise<GetCommentThreadAggregateType<T>>;

    /**
     * Group by CommentThread.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentThreadGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends CommentThreadGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentThreadGroupByArgs['orderBy'] }
        : { orderBy?: CommentThreadGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, CommentThreadGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetCommentThreadGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the CommentThread model
     */
    readonly fields: CommentThreadFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CommentThread.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentThreadClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    comments<T extends CommentThread$commentsArgs<ExtArgs> = {}>(
      args?: Subset<T, CommentThread$commentsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'findMany'> | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the CommentThread model
   */
  interface CommentThreadFieldRefs {
    readonly id: FieldRef<'CommentThread', 'String'>;
    readonly entityType: FieldRef<'CommentThread', 'CommentEntityType'>;
    readonly entityId: FieldRef<'CommentThread', 'String'>;
    readonly createdAt: FieldRef<'CommentThread', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * CommentThread findUnique
   */
  export type CommentThreadFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CommentThread
     */
    select?: CommentThreadSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentThreadInclude<ExtArgs> | null;
    /**
     * Filter, which CommentThread to fetch.
     */
    where: CommentThreadWhereUniqueInput;
  };

  /**
   * CommentThread findUniqueOrThrow
   */
  export type CommentThreadFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CommentThread
     */
    select?: CommentThreadSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentThreadInclude<ExtArgs> | null;
    /**
     * Filter, which CommentThread to fetch.
     */
    where: CommentThreadWhereUniqueInput;
  };

  /**
   * CommentThread findFirst
   */
  export type CommentThreadFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CommentThread
     */
    select?: CommentThreadSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentThreadInclude<ExtArgs> | null;
    /**
     * Filter, which CommentThread to fetch.
     */
    where?: CommentThreadWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of CommentThreads to fetch.
     */
    orderBy?: CommentThreadOrderByWithRelationInput | CommentThreadOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for CommentThreads.
     */
    cursor?: CommentThreadWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` CommentThreads from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` CommentThreads.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of CommentThreads.
     */
    distinct?: CommentThreadScalarFieldEnum | CommentThreadScalarFieldEnum[];
  };

  /**
   * CommentThread findFirstOrThrow
   */
  export type CommentThreadFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CommentThread
     */
    select?: CommentThreadSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentThreadInclude<ExtArgs> | null;
    /**
     * Filter, which CommentThread to fetch.
     */
    where?: CommentThreadWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of CommentThreads to fetch.
     */
    orderBy?: CommentThreadOrderByWithRelationInput | CommentThreadOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for CommentThreads.
     */
    cursor?: CommentThreadWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` CommentThreads from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` CommentThreads.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of CommentThreads.
     */
    distinct?: CommentThreadScalarFieldEnum | CommentThreadScalarFieldEnum[];
  };

  /**
   * CommentThread findMany
   */
  export type CommentThreadFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CommentThread
     */
    select?: CommentThreadSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentThreadInclude<ExtArgs> | null;
    /**
     * Filter, which CommentThreads to fetch.
     */
    where?: CommentThreadWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of CommentThreads to fetch.
     */
    orderBy?: CommentThreadOrderByWithRelationInput | CommentThreadOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing CommentThreads.
     */
    cursor?: CommentThreadWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` CommentThreads from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` CommentThreads.
     */
    skip?: number;
    distinct?: CommentThreadScalarFieldEnum | CommentThreadScalarFieldEnum[];
  };

  /**
   * CommentThread create
   */
  export type CommentThreadCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CommentThread
     */
    select?: CommentThreadSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentThreadInclude<ExtArgs> | null;
    /**
     * The data needed to create a CommentThread.
     */
    data: XOR<CommentThreadCreateInput, CommentThreadUncheckedCreateInput>;
  };

  /**
   * CommentThread createMany
   */
  export type CommentThreadCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many CommentThreads.
     */
    data: CommentThreadCreateManyInput | CommentThreadCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * CommentThread createManyAndReturn
   */
  export type CommentThreadCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CommentThread
     */
    select?: CommentThreadSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * The data used to create many CommentThreads.
     */
    data: CommentThreadCreateManyInput | CommentThreadCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * CommentThread update
   */
  export type CommentThreadUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CommentThread
     */
    select?: CommentThreadSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentThreadInclude<ExtArgs> | null;
    /**
     * The data needed to update a CommentThread.
     */
    data: XOR<CommentThreadUpdateInput, CommentThreadUncheckedUpdateInput>;
    /**
     * Choose, which CommentThread to update.
     */
    where: CommentThreadWhereUniqueInput;
  };

  /**
   * CommentThread updateMany
   */
  export type CommentThreadUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update CommentThreads.
     */
    data: XOR<CommentThreadUpdateManyMutationInput, CommentThreadUncheckedUpdateManyInput>;
    /**
     * Filter which CommentThreads to update
     */
    where?: CommentThreadWhereInput;
  };

  /**
   * CommentThread upsert
   */
  export type CommentThreadUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CommentThread
     */
    select?: CommentThreadSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentThreadInclude<ExtArgs> | null;
    /**
     * The filter to search for the CommentThread to update in case it exists.
     */
    where: CommentThreadWhereUniqueInput;
    /**
     * In case the CommentThread found by the `where` argument doesn't exist, create a new CommentThread with this data.
     */
    create: XOR<CommentThreadCreateInput, CommentThreadUncheckedCreateInput>;
    /**
     * In case the CommentThread was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentThreadUpdateInput, CommentThreadUncheckedUpdateInput>;
  };

  /**
   * CommentThread delete
   */
  export type CommentThreadDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CommentThread
     */
    select?: CommentThreadSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentThreadInclude<ExtArgs> | null;
    /**
     * Filter which CommentThread to delete.
     */
    where: CommentThreadWhereUniqueInput;
  };

  /**
   * CommentThread deleteMany
   */
  export type CommentThreadDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which CommentThreads to delete
     */
    where?: CommentThreadWhereInput;
  };

  /**
   * CommentThread.comments
   */
  export type CommentThread$commentsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null;
    where?: CommentWhereInput;
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[];
    cursor?: CommentWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[];
  };

  /**
   * CommentThread without action
   */
  export type CommentThreadDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CommentThread
     */
    select?: CommentThreadSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentThreadInclude<ExtArgs> | null;
  };

  /**
   * Model Comment
   */

  export type AggregateComment = {
    _count: CommentCountAggregateOutputType | null;
    _min: CommentMinAggregateOutputType | null;
    _max: CommentMaxAggregateOutputType | null;
  };

  export type CommentMinAggregateOutputType = {
    id: string | null;
    threadId: string | null;
    authorId: string | null;
    parentId: string | null;
    body: string | null;
    isFlagged: boolean | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type CommentMaxAggregateOutputType = {
    id: string | null;
    threadId: string | null;
    authorId: string | null;
    parentId: string | null;
    body: string | null;
    isFlagged: boolean | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type CommentCountAggregateOutputType = {
    id: number;
    threadId: number;
    authorId: number;
    parentId: number;
    body: number;
    isFlagged: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type CommentMinAggregateInputType = {
    id?: true;
    threadId?: true;
    authorId?: true;
    parentId?: true;
    body?: true;
    isFlagged?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type CommentMaxAggregateInputType = {
    id?: true;
    threadId?: true;
    authorId?: true;
    parentId?: true;
    body?: true;
    isFlagged?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type CommentCountAggregateInputType = {
    id?: true;
    threadId?: true;
    authorId?: true;
    parentId?: true;
    body?: true;
    isFlagged?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type CommentAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Comment to aggregate.
     */
    where?: CommentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: CommentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Comments.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Comments
     **/
    _count?: true | CommentCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: CommentMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: CommentMaxAggregateInputType;
  };

  export type GetCommentAggregateType<T extends CommentAggregateArgs> = {
    [P in keyof T & keyof AggregateComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComment[P]>
      : GetScalarType<T[P], AggregateComment[P]>;
  };

  export type CommentGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByWithAggregationInput | CommentOrderByWithAggregationInput[];
    by: CommentScalarFieldEnum[] | CommentScalarFieldEnum;
    having?: CommentScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: CommentCountAggregateInputType | true;
    _min?: CommentMinAggregateInputType;
    _max?: CommentMaxAggregateInputType;
  };

  export type CommentGroupByOutputType = {
    id: string;
    threadId: string;
    authorId: string;
    parentId: string | null;
    body: string;
    isFlagged: boolean;
    createdAt: Date;
    updatedAt: Date;
    _count: CommentCountAggregateOutputType | null;
    _min: CommentMinAggregateOutputType | null;
    _max: CommentMaxAggregateOutputType | null;
  };

  type GetCommentGroupByPayload<T extends CommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentGroupByOutputType, T['by']> & {
        [P in keyof T & keyof CommentGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], CommentGroupByOutputType[P]>
          : GetScalarType<T[P], CommentGroupByOutputType[P]>;
      }
    >
  >;

  export type CommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        threadId?: boolean;
        authorId?: boolean;
        parentId?: boolean;
        body?: boolean;
        isFlagged?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        thread?: boolean | CommentThreadDefaultArgs<ExtArgs>;
        author?: boolean | UserDefaultArgs<ExtArgs>;
        parent?: boolean | Comment$parentArgs<ExtArgs>;
        replies?: boolean | Comment$repliesArgs<ExtArgs>;
        _count?: boolean | CommentCountOutputTypeDefaultArgs<ExtArgs>;
      },
      ExtArgs['result']['comment']
    >;

  export type CommentSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      threadId?: boolean;
      authorId?: boolean;
      parentId?: boolean;
      body?: boolean;
      isFlagged?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      thread?: boolean | CommentThreadDefaultArgs<ExtArgs>;
      author?: boolean | UserDefaultArgs<ExtArgs>;
      parent?: boolean | Comment$parentArgs<ExtArgs>;
    },
    ExtArgs['result']['comment']
  >;

  export type CommentSelectScalar = {
    id?: boolean;
    threadId?: boolean;
    authorId?: boolean;
    parentId?: boolean;
    body?: boolean;
    isFlagged?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type CommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    thread?: boolean | CommentThreadDefaultArgs<ExtArgs>;
    author?: boolean | UserDefaultArgs<ExtArgs>;
    parent?: boolean | Comment$parentArgs<ExtArgs>;
    replies?: boolean | Comment$repliesArgs<ExtArgs>;
    _count?: boolean | CommentCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type CommentIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    thread?: boolean | CommentThreadDefaultArgs<ExtArgs>;
    author?: boolean | UserDefaultArgs<ExtArgs>;
    parent?: boolean | Comment$parentArgs<ExtArgs>;
  };

  export type $CommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      name: 'Comment';
      objects: {
        thread: Prisma.$CommentThreadPayload<ExtArgs>;
        author: Prisma.$UserPayload<ExtArgs>;
        parent: Prisma.$CommentPayload<ExtArgs> | null;
        replies: Prisma.$CommentPayload<ExtArgs>[];
      };
      scalars: $Extensions.GetPayloadResult<
        {
          id: string;
          threadId: string;
          authorId: string;
          parentId: string | null;
          body: string;
          isFlagged: boolean;
          createdAt: Date;
          updatedAt: Date;
        },
        ExtArgs['result']['comment']
      >;
      composites: {};
    };

  type CommentGetPayload<S extends boolean | null | undefined | CommentDefaultArgs> =
    $Result.GetResult<Prisma.$CommentPayload, S>;

  type CommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    CommentFindManyArgs,
    'select' | 'include' | 'distinct'
  > & {
    select?: CommentCountAggregateInputType | true;
  };

  export interface CommentDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comment']; meta: { name: 'Comment' } };
    /**
     * Find zero or one Comment that matches the filter.
     * @param {CommentFindUniqueArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommentFindUniqueArgs>(
      args: SelectSubset<T, CommentFindUniqueArgs<ExtArgs>>
    ): Prisma__CommentClient<
      $Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'findUnique'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find one Comment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CommentFindUniqueOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommentFindUniqueOrThrowArgs>(
      args: SelectSubset<T, CommentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CommentClient<
      $Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'findUniqueOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find the first Comment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommentFindFirstArgs>(
      args?: SelectSubset<T, CommentFindFirstArgs<ExtArgs>>
    ): Prisma__CommentClient<
      $Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'findFirst'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find the first Comment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommentFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CommentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CommentClient<
      $Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'findFirstOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comment.findMany()
     *
     * // Get first 10 Comments
     * const comments = await prisma.comment.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const commentWithIdOnly = await prisma.comment.findMany({ select: { id: true } })
     *
     */
    findMany<T extends CommentFindManyArgs>(
      args?: SelectSubset<T, CommentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'findMany'>>;

    /**
     * Create a Comment.
     * @param {CommentCreateArgs} args - Arguments to create a Comment.
     * @example
     * // Create one Comment
     * const Comment = await prisma.comment.create({
     *   data: {
     *     // ... data to create a Comment
     *   }
     * })
     *
     */
    create<T extends CommentCreateArgs>(
      args: SelectSubset<T, CommentCreateArgs<ExtArgs>>
    ): Prisma__CommentClient<
      $Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'create'>,
      never,
      ExtArgs
    >;

    /**
     * Create many Comments.
     * @param {CommentCreateManyArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends CommentCreateManyArgs>(
      args?: SelectSubset<T, CommentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Comments and returns the data saved in the database.
     * @param {CommentCreateManyAndReturnArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Comments and only return the `id`
     * const commentWithIdOnly = await prisma.comment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends CommentCreateManyAndReturnArgs>(
      args?: SelectSubset<T, CommentCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'createManyAndReturn'>
    >;

    /**
     * Delete a Comment.
     * @param {CommentDeleteArgs} args - Arguments to delete one Comment.
     * @example
     * // Delete one Comment
     * const Comment = await prisma.comment.delete({
     *   where: {
     *     // ... filter to delete one Comment
     *   }
     * })
     *
     */
    delete<T extends CommentDeleteArgs>(
      args: SelectSubset<T, CommentDeleteArgs<ExtArgs>>
    ): Prisma__CommentClient<
      $Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'delete'>,
      never,
      ExtArgs
    >;

    /**
     * Update one Comment.
     * @param {CommentUpdateArgs} args - Arguments to update one Comment.
     * @example
     * // Update one Comment
     * const comment = await prisma.comment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends CommentUpdateArgs>(
      args: SelectSubset<T, CommentUpdateArgs<ExtArgs>>
    ): Prisma__CommentClient<
      $Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'update'>,
      never,
      ExtArgs
    >;

    /**
     * Delete zero or more Comments.
     * @param {CommentDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends CommentDeleteManyArgs>(
      args?: SelectSubset<T, CommentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends CommentUpdateManyArgs>(
      args: SelectSubset<T, CommentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Comment.
     * @param {CommentUpsertArgs} args - Arguments to update or create a Comment.
     * @example
     * // Update or create a Comment
     * const comment = await prisma.comment.upsert({
     *   create: {
     *     // ... data to create a Comment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comment we want to update
     *   }
     * })
     */
    upsert<T extends CommentUpsertArgs>(
      args: SelectSubset<T, CommentUpsertArgs<ExtArgs>>
    ): Prisma__CommentClient<
      $Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'upsert'>,
      never,
      ExtArgs
    >;

    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comment.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
     **/
    count<T extends CommentCountArgs>(
      args?: Subset<T, CommentCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends CommentAggregateArgs>(
      args: Subset<T, CommentAggregateArgs>
    ): Prisma.PrismaPromise<GetCommentAggregateType<T>>;

    /**
     * Group by Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends CommentGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentGroupByArgs['orderBy'] }
        : { orderBy?: CommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, CommentGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Comment model
     */
    readonly fields: CommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    thread<T extends CommentThreadDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, CommentThreadDefaultArgs<ExtArgs>>
    ): Prisma__CommentThreadClient<
      $Result.GetResult<Prisma.$CommentThreadPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null,
      Null,
      ExtArgs
    >;
    author<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null,
      Null,
      ExtArgs
    >;
    parent<T extends Comment$parentArgs<ExtArgs> = {}>(
      args?: Subset<T, Comment$parentArgs<ExtArgs>>
    ): Prisma__CommentClient<
      $Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null,
      null,
      ExtArgs
    >;
    replies<T extends Comment$repliesArgs<ExtArgs> = {}>(
      args?: Subset<T, Comment$repliesArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'findMany'> | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Comment model
   */
  interface CommentFieldRefs {
    readonly id: FieldRef<'Comment', 'String'>;
    readonly threadId: FieldRef<'Comment', 'String'>;
    readonly authorId: FieldRef<'Comment', 'String'>;
    readonly parentId: FieldRef<'Comment', 'String'>;
    readonly body: FieldRef<'Comment', 'String'>;
    readonly isFlagged: FieldRef<'Comment', 'Boolean'>;
    readonly createdAt: FieldRef<'Comment', 'DateTime'>;
    readonly updatedAt: FieldRef<'Comment', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * Comment findUnique
   */
  export type CommentFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null;
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput;
  };

  /**
   * Comment findUniqueOrThrow
   */
  export type CommentFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null;
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput;
  };

  /**
   * Comment findFirst
   */
  export type CommentFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null;
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Comments.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[];
  };

  /**
   * Comment findFirstOrThrow
   */
  export type CommentFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null;
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Comments.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[];
  };

  /**
   * Comment findMany
   */
  export type CommentFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null;
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Comments.
     */
    cursor?: CommentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Comments.
     */
    skip?: number;
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[];
  };

  /**
   * Comment create
   */
  export type CommentCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null;
    /**
     * The data needed to create a Comment.
     */
    data: XOR<CommentCreateInput, CommentUncheckedCreateInput>;
  };

  /**
   * Comment createMany
   */
  export type CommentCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Comment createManyAndReturn
   */
  export type CommentCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Comment update
   */
  export type CommentUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null;
    /**
     * The data needed to update a Comment.
     */
    data: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>;
    /**
     * Choose, which Comment to update.
     */
    where: CommentWhereUniqueInput;
  };

  /**
   * Comment updateMany
   */
  export type CommentUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>;
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput;
  };

  /**
   * Comment upsert
   */
  export type CommentUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null;
    /**
     * The filter to search for the Comment to update in case it exists.
     */
    where: CommentWhereUniqueInput;
    /**
     * In case the Comment found by the `where` argument doesn't exist, create a new Comment with this data.
     */
    create: XOR<CommentCreateInput, CommentUncheckedCreateInput>;
    /**
     * In case the Comment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>;
  };

  /**
   * Comment delete
   */
  export type CommentDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null;
    /**
     * Filter which Comment to delete.
     */
    where: CommentWhereUniqueInput;
  };

  /**
   * Comment deleteMany
   */
  export type CommentDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Comments to delete
     */
    where?: CommentWhereInput;
  };

  /**
   * Comment.parent
   */
  export type Comment$parentArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null;
    where?: CommentWhereInput;
  };

  /**
   * Comment.replies
   */
  export type Comment$repliesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null;
    where?: CommentWhereInput;
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[];
    cursor?: CommentWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[];
  };

  /**
   * Comment without action
   */
  export type CommentDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null;
  };

  /**
   * Model GamificationProfile
   */

  export type AggregateGamificationProfile = {
    _count: GamificationProfileCountAggregateOutputType | null;
    _avg: GamificationProfileAvgAggregateOutputType | null;
    _sum: GamificationProfileSumAggregateOutputType | null;
    _min: GamificationProfileMinAggregateOutputType | null;
    _max: GamificationProfileMaxAggregateOutputType | null;
  };

  export type GamificationProfileAvgAggregateOutputType = {
    xp: number | null;
    level: number | null;
    streakDays: number | null;
    vaultKeys: number | null;
  };

  export type GamificationProfileSumAggregateOutputType = {
    xp: number | null;
    level: number | null;
    streakDays: number | null;
    vaultKeys: number | null;
  };

  export type GamificationProfileMinAggregateOutputType = {
    userId: string | null;
    xp: number | null;
    level: number | null;
    streakDays: number | null;
    vaultKeys: number | null;
    lastActivityAt: Date | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type GamificationProfileMaxAggregateOutputType = {
    userId: string | null;
    xp: number | null;
    level: number | null;
    streakDays: number | null;
    vaultKeys: number | null;
    lastActivityAt: Date | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type GamificationProfileCountAggregateOutputType = {
    userId: number;
    xp: number;
    level: number;
    streakDays: number;
    vaultKeys: number;
    badges: number;
    lastActivityAt: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type GamificationProfileAvgAggregateInputType = {
    xp?: true;
    level?: true;
    streakDays?: true;
    vaultKeys?: true;
  };

  export type GamificationProfileSumAggregateInputType = {
    xp?: true;
    level?: true;
    streakDays?: true;
    vaultKeys?: true;
  };

  export type GamificationProfileMinAggregateInputType = {
    userId?: true;
    xp?: true;
    level?: true;
    streakDays?: true;
    vaultKeys?: true;
    lastActivityAt?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type GamificationProfileMaxAggregateInputType = {
    userId?: true;
    xp?: true;
    level?: true;
    streakDays?: true;
    vaultKeys?: true;
    lastActivityAt?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type GamificationProfileCountAggregateInputType = {
    userId?: true;
    xp?: true;
    level?: true;
    streakDays?: true;
    vaultKeys?: true;
    badges?: true;
    lastActivityAt?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type GamificationProfileAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which GamificationProfile to aggregate.
     */
    where?: GamificationProfileWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of GamificationProfiles to fetch.
     */
    orderBy?:
      | GamificationProfileOrderByWithRelationInput
      | GamificationProfileOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: GamificationProfileWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` GamificationProfiles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` GamificationProfiles.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned GamificationProfiles
     **/
    _count?: true | GamificationProfileCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: GamificationProfileAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: GamificationProfileSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: GamificationProfileMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: GamificationProfileMaxAggregateInputType;
  };

  export type GetGamificationProfileAggregateType<T extends GamificationProfileAggregateArgs> = {
    [P in keyof T & keyof AggregateGamificationProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGamificationProfile[P]>
      : GetScalarType<T[P], AggregateGamificationProfile[P]>;
  };

  export type GamificationProfileGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: GamificationProfileWhereInput;
    orderBy?:
      | GamificationProfileOrderByWithAggregationInput
      | GamificationProfileOrderByWithAggregationInput[];
    by: GamificationProfileScalarFieldEnum[] | GamificationProfileScalarFieldEnum;
    having?: GamificationProfileScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: GamificationProfileCountAggregateInputType | true;
    _avg?: GamificationProfileAvgAggregateInputType;
    _sum?: GamificationProfileSumAggregateInputType;
    _min?: GamificationProfileMinAggregateInputType;
    _max?: GamificationProfileMaxAggregateInputType;
  };

  export type GamificationProfileGroupByOutputType = {
    userId: string;
    xp: number;
    level: number;
    streakDays: number;
    vaultKeys: number;
    badges: string[];
    lastActivityAt: Date | null;
    createdAt: Date;
    updatedAt: Date;
    _count: GamificationProfileCountAggregateOutputType | null;
    _avg: GamificationProfileAvgAggregateOutputType | null;
    _sum: GamificationProfileSumAggregateOutputType | null;
    _min: GamificationProfileMinAggregateOutputType | null;
    _max: GamificationProfileMaxAggregateOutputType | null;
  };

  type GetGamificationProfileGroupByPayload<T extends GamificationProfileGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<GamificationProfileGroupByOutputType, T['by']> & {
          [P in keyof T & keyof GamificationProfileGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GamificationProfileGroupByOutputType[P]>
            : GetScalarType<T[P], GamificationProfileGroupByOutputType[P]>;
        }
      >
    >;

  export type GamificationProfileSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      userId?: boolean;
      xp?: boolean;
      level?: boolean;
      streakDays?: boolean;
      vaultKeys?: boolean;
      badges?: boolean;
      lastActivityAt?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['gamificationProfile']
  >;

  export type GamificationProfileSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      userId?: boolean;
      xp?: boolean;
      level?: boolean;
      streakDays?: boolean;
      vaultKeys?: boolean;
      badges?: boolean;
      lastActivityAt?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['gamificationProfile']
  >;

  export type GamificationProfileSelectScalar = {
    userId?: boolean;
    xp?: boolean;
    level?: boolean;
    streakDays?: boolean;
    vaultKeys?: boolean;
    badges?: boolean;
    lastActivityAt?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type GamificationProfileInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type GamificationProfileIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $GamificationProfilePayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'GamificationProfile';
    objects: {
      user: Prisma.$UserPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        userId: string;
        xp: number;
        level: number;
        streakDays: number;
        vaultKeys: number;
        badges: string[];
        lastActivityAt: Date | null;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs['result']['gamificationProfile']
    >;
    composites: {};
  };

  type GamificationProfileGetPayload<
    S extends boolean | null | undefined | GamificationProfileDefaultArgs,
  > = $Result.GetResult<Prisma.$GamificationProfilePayload, S>;

  type GamificationProfileCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<GamificationProfileFindManyArgs, 'select' | 'include' | 'distinct'> & {
    select?: GamificationProfileCountAggregateInputType | true;
  };

  export interface GamificationProfileDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['GamificationProfile'];
      meta: { name: 'GamificationProfile' };
    };
    /**
     * Find zero or one GamificationProfile that matches the filter.
     * @param {GamificationProfileFindUniqueArgs} args - Arguments to find a GamificationProfile
     * @example
     * // Get one GamificationProfile
     * const gamificationProfile = await prisma.gamificationProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GamificationProfileFindUniqueArgs>(
      args: SelectSubset<T, GamificationProfileFindUniqueArgs<ExtArgs>>
    ): Prisma__GamificationProfileClient<
      $Result.GetResult<Prisma.$GamificationProfilePayload<ExtArgs>, T, 'findUnique'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find one GamificationProfile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GamificationProfileFindUniqueOrThrowArgs} args - Arguments to find a GamificationProfile
     * @example
     * // Get one GamificationProfile
     * const gamificationProfile = await prisma.gamificationProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GamificationProfileFindUniqueOrThrowArgs>(
      args: SelectSubset<T, GamificationProfileFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__GamificationProfileClient<
      $Result.GetResult<Prisma.$GamificationProfilePayload<ExtArgs>, T, 'findUniqueOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find the first GamificationProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GamificationProfileFindFirstArgs} args - Arguments to find a GamificationProfile
     * @example
     * // Get one GamificationProfile
     * const gamificationProfile = await prisma.gamificationProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GamificationProfileFindFirstArgs>(
      args?: SelectSubset<T, GamificationProfileFindFirstArgs<ExtArgs>>
    ): Prisma__GamificationProfileClient<
      $Result.GetResult<Prisma.$GamificationProfilePayload<ExtArgs>, T, 'findFirst'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find the first GamificationProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GamificationProfileFindFirstOrThrowArgs} args - Arguments to find a GamificationProfile
     * @example
     * // Get one GamificationProfile
     * const gamificationProfile = await prisma.gamificationProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GamificationProfileFindFirstOrThrowArgs>(
      args?: SelectSubset<T, GamificationProfileFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__GamificationProfileClient<
      $Result.GetResult<Prisma.$GamificationProfilePayload<ExtArgs>, T, 'findFirstOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more GamificationProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GamificationProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GamificationProfiles
     * const gamificationProfiles = await prisma.gamificationProfile.findMany()
     *
     * // Get first 10 GamificationProfiles
     * const gamificationProfiles = await prisma.gamificationProfile.findMany({ take: 10 })
     *
     * // Only select the `userId`
     * const gamificationProfileWithUserIdOnly = await prisma.gamificationProfile.findMany({ select: { userId: true } })
     *
     */
    findMany<T extends GamificationProfileFindManyArgs>(
      args?: SelectSubset<T, GamificationProfileFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$GamificationProfilePayload<ExtArgs>, T, 'findMany'>
    >;

    /**
     * Create a GamificationProfile.
     * @param {GamificationProfileCreateArgs} args - Arguments to create a GamificationProfile.
     * @example
     * // Create one GamificationProfile
     * const GamificationProfile = await prisma.gamificationProfile.create({
     *   data: {
     *     // ... data to create a GamificationProfile
     *   }
     * })
     *
     */
    create<T extends GamificationProfileCreateArgs>(
      args: SelectSubset<T, GamificationProfileCreateArgs<ExtArgs>>
    ): Prisma__GamificationProfileClient<
      $Result.GetResult<Prisma.$GamificationProfilePayload<ExtArgs>, T, 'create'>,
      never,
      ExtArgs
    >;

    /**
     * Create many GamificationProfiles.
     * @param {GamificationProfileCreateManyArgs} args - Arguments to create many GamificationProfiles.
     * @example
     * // Create many GamificationProfiles
     * const gamificationProfile = await prisma.gamificationProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends GamificationProfileCreateManyArgs>(
      args?: SelectSubset<T, GamificationProfileCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many GamificationProfiles and returns the data saved in the database.
     * @param {GamificationProfileCreateManyAndReturnArgs} args - Arguments to create many GamificationProfiles.
     * @example
     * // Create many GamificationProfiles
     * const gamificationProfile = await prisma.gamificationProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many GamificationProfiles and only return the `userId`
     * const gamificationProfileWithUserIdOnly = await prisma.gamificationProfile.createManyAndReturn({
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends GamificationProfileCreateManyAndReturnArgs>(
      args?: SelectSubset<T, GamificationProfileCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$GamificationProfilePayload<ExtArgs>, T, 'createManyAndReturn'>
    >;

    /**
     * Delete a GamificationProfile.
     * @param {GamificationProfileDeleteArgs} args - Arguments to delete one GamificationProfile.
     * @example
     * // Delete one GamificationProfile
     * const GamificationProfile = await prisma.gamificationProfile.delete({
     *   where: {
     *     // ... filter to delete one GamificationProfile
     *   }
     * })
     *
     */
    delete<T extends GamificationProfileDeleteArgs>(
      args: SelectSubset<T, GamificationProfileDeleteArgs<ExtArgs>>
    ): Prisma__GamificationProfileClient<
      $Result.GetResult<Prisma.$GamificationProfilePayload<ExtArgs>, T, 'delete'>,
      never,
      ExtArgs
    >;

    /**
     * Update one GamificationProfile.
     * @param {GamificationProfileUpdateArgs} args - Arguments to update one GamificationProfile.
     * @example
     * // Update one GamificationProfile
     * const gamificationProfile = await prisma.gamificationProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends GamificationProfileUpdateArgs>(
      args: SelectSubset<T, GamificationProfileUpdateArgs<ExtArgs>>
    ): Prisma__GamificationProfileClient<
      $Result.GetResult<Prisma.$GamificationProfilePayload<ExtArgs>, T, 'update'>,
      never,
      ExtArgs
    >;

    /**
     * Delete zero or more GamificationProfiles.
     * @param {GamificationProfileDeleteManyArgs} args - Arguments to filter GamificationProfiles to delete.
     * @example
     * // Delete a few GamificationProfiles
     * const { count } = await prisma.gamificationProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends GamificationProfileDeleteManyArgs>(
      args?: SelectSubset<T, GamificationProfileDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more GamificationProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GamificationProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GamificationProfiles
     * const gamificationProfile = await prisma.gamificationProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends GamificationProfileUpdateManyArgs>(
      args: SelectSubset<T, GamificationProfileUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one GamificationProfile.
     * @param {GamificationProfileUpsertArgs} args - Arguments to update or create a GamificationProfile.
     * @example
     * // Update or create a GamificationProfile
     * const gamificationProfile = await prisma.gamificationProfile.upsert({
     *   create: {
     *     // ... data to create a GamificationProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GamificationProfile we want to update
     *   }
     * })
     */
    upsert<T extends GamificationProfileUpsertArgs>(
      args: SelectSubset<T, GamificationProfileUpsertArgs<ExtArgs>>
    ): Prisma__GamificationProfileClient<
      $Result.GetResult<Prisma.$GamificationProfilePayload<ExtArgs>, T, 'upsert'>,
      never,
      ExtArgs
    >;

    /**
     * Count the number of GamificationProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GamificationProfileCountArgs} args - Arguments to filter GamificationProfiles to count.
     * @example
     * // Count the number of GamificationProfiles
     * const count = await prisma.gamificationProfile.count({
     *   where: {
     *     // ... the filter for the GamificationProfiles we want to count
     *   }
     * })
     **/
    count<T extends GamificationProfileCountArgs>(
      args?: Subset<T, GamificationProfileCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GamificationProfileCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a GamificationProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GamificationProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends GamificationProfileAggregateArgs>(
      args: Subset<T, GamificationProfileAggregateArgs>
    ): Prisma.PrismaPromise<GetGamificationProfileAggregateType<T>>;

    /**
     * Group by GamificationProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GamificationProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends GamificationProfileGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GamificationProfileGroupByArgs['orderBy'] }
        : { orderBy?: GamificationProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, GamificationProfileGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetGamificationProfileGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the GamificationProfile model
     */
    readonly fields: GamificationProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GamificationProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GamificationProfileClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null,
      Null,
      ExtArgs
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the GamificationProfile model
   */
  interface GamificationProfileFieldRefs {
    readonly userId: FieldRef<'GamificationProfile', 'String'>;
    readonly xp: FieldRef<'GamificationProfile', 'Int'>;
    readonly level: FieldRef<'GamificationProfile', 'Int'>;
    readonly streakDays: FieldRef<'GamificationProfile', 'Int'>;
    readonly vaultKeys: FieldRef<'GamificationProfile', 'Int'>;
    readonly badges: FieldRef<'GamificationProfile', 'String[]'>;
    readonly lastActivityAt: FieldRef<'GamificationProfile', 'DateTime'>;
    readonly createdAt: FieldRef<'GamificationProfile', 'DateTime'>;
    readonly updatedAt: FieldRef<'GamificationProfile', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * GamificationProfile findUnique
   */
  export type GamificationProfileFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the GamificationProfile
     */
    select?: GamificationProfileSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GamificationProfileInclude<ExtArgs> | null;
    /**
     * Filter, which GamificationProfile to fetch.
     */
    where: GamificationProfileWhereUniqueInput;
  };

  /**
   * GamificationProfile findUniqueOrThrow
   */
  export type GamificationProfileFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the GamificationProfile
     */
    select?: GamificationProfileSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GamificationProfileInclude<ExtArgs> | null;
    /**
     * Filter, which GamificationProfile to fetch.
     */
    where: GamificationProfileWhereUniqueInput;
  };

  /**
   * GamificationProfile findFirst
   */
  export type GamificationProfileFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the GamificationProfile
     */
    select?: GamificationProfileSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GamificationProfileInclude<ExtArgs> | null;
    /**
     * Filter, which GamificationProfile to fetch.
     */
    where?: GamificationProfileWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of GamificationProfiles to fetch.
     */
    orderBy?:
      | GamificationProfileOrderByWithRelationInput
      | GamificationProfileOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for GamificationProfiles.
     */
    cursor?: GamificationProfileWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` GamificationProfiles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` GamificationProfiles.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of GamificationProfiles.
     */
    distinct?: GamificationProfileScalarFieldEnum | GamificationProfileScalarFieldEnum[];
  };

  /**
   * GamificationProfile findFirstOrThrow
   */
  export type GamificationProfileFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the GamificationProfile
     */
    select?: GamificationProfileSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GamificationProfileInclude<ExtArgs> | null;
    /**
     * Filter, which GamificationProfile to fetch.
     */
    where?: GamificationProfileWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of GamificationProfiles to fetch.
     */
    orderBy?:
      | GamificationProfileOrderByWithRelationInput
      | GamificationProfileOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for GamificationProfiles.
     */
    cursor?: GamificationProfileWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` GamificationProfiles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` GamificationProfiles.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of GamificationProfiles.
     */
    distinct?: GamificationProfileScalarFieldEnum | GamificationProfileScalarFieldEnum[];
  };

  /**
   * GamificationProfile findMany
   */
  export type GamificationProfileFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the GamificationProfile
     */
    select?: GamificationProfileSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GamificationProfileInclude<ExtArgs> | null;
    /**
     * Filter, which GamificationProfiles to fetch.
     */
    where?: GamificationProfileWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of GamificationProfiles to fetch.
     */
    orderBy?:
      | GamificationProfileOrderByWithRelationInput
      | GamificationProfileOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing GamificationProfiles.
     */
    cursor?: GamificationProfileWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` GamificationProfiles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` GamificationProfiles.
     */
    skip?: number;
    distinct?: GamificationProfileScalarFieldEnum | GamificationProfileScalarFieldEnum[];
  };

  /**
   * GamificationProfile create
   */
  export type GamificationProfileCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the GamificationProfile
     */
    select?: GamificationProfileSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GamificationProfileInclude<ExtArgs> | null;
    /**
     * The data needed to create a GamificationProfile.
     */
    data: XOR<GamificationProfileCreateInput, GamificationProfileUncheckedCreateInput>;
  };

  /**
   * GamificationProfile createMany
   */
  export type GamificationProfileCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many GamificationProfiles.
     */
    data: GamificationProfileCreateManyInput | GamificationProfileCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * GamificationProfile createManyAndReturn
   */
  export type GamificationProfileCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the GamificationProfile
     */
    select?: GamificationProfileSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * The data used to create many GamificationProfiles.
     */
    data: GamificationProfileCreateManyInput | GamificationProfileCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GamificationProfileIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * GamificationProfile update
   */
  export type GamificationProfileUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the GamificationProfile
     */
    select?: GamificationProfileSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GamificationProfileInclude<ExtArgs> | null;
    /**
     * The data needed to update a GamificationProfile.
     */
    data: XOR<GamificationProfileUpdateInput, GamificationProfileUncheckedUpdateInput>;
    /**
     * Choose, which GamificationProfile to update.
     */
    where: GamificationProfileWhereUniqueInput;
  };

  /**
   * GamificationProfile updateMany
   */
  export type GamificationProfileUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update GamificationProfiles.
     */
    data: XOR<
      GamificationProfileUpdateManyMutationInput,
      GamificationProfileUncheckedUpdateManyInput
    >;
    /**
     * Filter which GamificationProfiles to update
     */
    where?: GamificationProfileWhereInput;
  };

  /**
   * GamificationProfile upsert
   */
  export type GamificationProfileUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the GamificationProfile
     */
    select?: GamificationProfileSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GamificationProfileInclude<ExtArgs> | null;
    /**
     * The filter to search for the GamificationProfile to update in case it exists.
     */
    where: GamificationProfileWhereUniqueInput;
    /**
     * In case the GamificationProfile found by the `where` argument doesn't exist, create a new GamificationProfile with this data.
     */
    create: XOR<GamificationProfileCreateInput, GamificationProfileUncheckedCreateInput>;
    /**
     * In case the GamificationProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GamificationProfileUpdateInput, GamificationProfileUncheckedUpdateInput>;
  };

  /**
   * GamificationProfile delete
   */
  export type GamificationProfileDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the GamificationProfile
     */
    select?: GamificationProfileSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GamificationProfileInclude<ExtArgs> | null;
    /**
     * Filter which GamificationProfile to delete.
     */
    where: GamificationProfileWhereUniqueInput;
  };

  /**
   * GamificationProfile deleteMany
   */
  export type GamificationProfileDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which GamificationProfiles to delete
     */
    where?: GamificationProfileWhereInput;
  };

  /**
   * GamificationProfile without action
   */
  export type GamificationProfileDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the GamificationProfile
     */
    select?: GamificationProfileSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GamificationProfileInclude<ExtArgs> | null;
  };

  /**
   * Model Badge
   */

  export type AggregateBadge = {
    _count: BadgeCountAggregateOutputType | null;
    _avg: BadgeAvgAggregateOutputType | null;
    _sum: BadgeSumAggregateOutputType | null;
    _min: BadgeMinAggregateOutputType | null;
    _max: BadgeMaxAggregateOutputType | null;
  };

  export type BadgeAvgAggregateOutputType = {
    xpRequired: number | null;
  };

  export type BadgeSumAggregateOutputType = {
    xpRequired: number | null;
  };

  export type BadgeMinAggregateOutputType = {
    id: string | null;
    slug: string | null;
    name: string | null;
    description: string | null;
    icon: string | null;
    xpRequired: number | null;
    rarity: string | null;
    createdAt: Date | null;
  };

  export type BadgeMaxAggregateOutputType = {
    id: string | null;
    slug: string | null;
    name: string | null;
    description: string | null;
    icon: string | null;
    xpRequired: number | null;
    rarity: string | null;
    createdAt: Date | null;
  };

  export type BadgeCountAggregateOutputType = {
    id: number;
    slug: number;
    name: number;
    description: number;
    icon: number;
    xpRequired: number;
    rarity: number;
    createdAt: number;
    _all: number;
  };

  export type BadgeAvgAggregateInputType = {
    xpRequired?: true;
  };

  export type BadgeSumAggregateInputType = {
    xpRequired?: true;
  };

  export type BadgeMinAggregateInputType = {
    id?: true;
    slug?: true;
    name?: true;
    description?: true;
    icon?: true;
    xpRequired?: true;
    rarity?: true;
    createdAt?: true;
  };

  export type BadgeMaxAggregateInputType = {
    id?: true;
    slug?: true;
    name?: true;
    description?: true;
    icon?: true;
    xpRequired?: true;
    rarity?: true;
    createdAt?: true;
  };

  export type BadgeCountAggregateInputType = {
    id?: true;
    slug?: true;
    name?: true;
    description?: true;
    icon?: true;
    xpRequired?: true;
    rarity?: true;
    createdAt?: true;
    _all?: true;
  };

  export type BadgeAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Badge to aggregate.
     */
    where?: BadgeWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Badges to fetch.
     */
    orderBy?: BadgeOrderByWithRelationInput | BadgeOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: BadgeWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Badges from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Badges.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Badges
     **/
    _count?: true | BadgeCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: BadgeAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: BadgeSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: BadgeMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: BadgeMaxAggregateInputType;
  };

  export type GetBadgeAggregateType<T extends BadgeAggregateArgs> = {
    [P in keyof T & keyof AggregateBadge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBadge[P]>
      : GetScalarType<T[P], AggregateBadge[P]>;
  };

  export type BadgeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      where?: BadgeWhereInput;
      orderBy?: BadgeOrderByWithAggregationInput | BadgeOrderByWithAggregationInput[];
      by: BadgeScalarFieldEnum[] | BadgeScalarFieldEnum;
      having?: BadgeScalarWhereWithAggregatesInput;
      take?: number;
      skip?: number;
      _count?: BadgeCountAggregateInputType | true;
      _avg?: BadgeAvgAggregateInputType;
      _sum?: BadgeSumAggregateInputType;
      _min?: BadgeMinAggregateInputType;
      _max?: BadgeMaxAggregateInputType;
    };

  export type BadgeGroupByOutputType = {
    id: string;
    slug: string;
    name: string;
    description: string;
    icon: string;
    xpRequired: number;
    rarity: string;
    createdAt: Date;
    _count: BadgeCountAggregateOutputType | null;
    _avg: BadgeAvgAggregateOutputType | null;
    _sum: BadgeSumAggregateOutputType | null;
    _min: BadgeMinAggregateOutputType | null;
    _max: BadgeMaxAggregateOutputType | null;
  };

  type GetBadgeGroupByPayload<T extends BadgeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BadgeGroupByOutputType, T['by']> & {
        [P in keyof T & keyof BadgeGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], BadgeGroupByOutputType[P]>
          : GetScalarType<T[P], BadgeGroupByOutputType[P]>;
      }
    >
  >;

  export type BadgeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        slug?: boolean;
        name?: boolean;
        description?: boolean;
        icon?: boolean;
        xpRequired?: boolean;
        rarity?: boolean;
        createdAt?: boolean;
      },
      ExtArgs['result']['badge']
    >;

  export type BadgeSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      slug?: boolean;
      name?: boolean;
      description?: boolean;
      icon?: boolean;
      xpRequired?: boolean;
      rarity?: boolean;
      createdAt?: boolean;
    },
    ExtArgs['result']['badge']
  >;

  export type BadgeSelectScalar = {
    id?: boolean;
    slug?: boolean;
    name?: boolean;
    description?: boolean;
    icon?: boolean;
    xpRequired?: boolean;
    rarity?: boolean;
    createdAt?: boolean;
  };

  export type $BadgePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: 'Badge';
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        slug: string;
        name: string;
        description: string;
        icon: string;
        xpRequired: number;
        rarity: string;
        createdAt: Date;
      },
      ExtArgs['result']['badge']
    >;
    composites: {};
  };

  type BadgeGetPayload<S extends boolean | null | undefined | BadgeDefaultArgs> = $Result.GetResult<
    Prisma.$BadgePayload,
    S
  >;

  type BadgeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    BadgeFindManyArgs,
    'select' | 'include' | 'distinct'
  > & {
    select?: BadgeCountAggregateInputType | true;
  };

  export interface BadgeDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Badge']; meta: { name: 'Badge' } };
    /**
     * Find zero or one Badge that matches the filter.
     * @param {BadgeFindUniqueArgs} args - Arguments to find a Badge
     * @example
     * // Get one Badge
     * const badge = await prisma.badge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BadgeFindUniqueArgs>(
      args: SelectSubset<T, BadgeFindUniqueArgs<ExtArgs>>
    ): Prisma__BadgeClient<
      $Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, 'findUnique'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find one Badge that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BadgeFindUniqueOrThrowArgs} args - Arguments to find a Badge
     * @example
     * // Get one Badge
     * const badge = await prisma.badge.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BadgeFindUniqueOrThrowArgs>(
      args: SelectSubset<T, BadgeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__BadgeClient<
      $Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, 'findUniqueOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find the first Badge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeFindFirstArgs} args - Arguments to find a Badge
     * @example
     * // Get one Badge
     * const badge = await prisma.badge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BadgeFindFirstArgs>(
      args?: SelectSubset<T, BadgeFindFirstArgs<ExtArgs>>
    ): Prisma__BadgeClient<
      $Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, 'findFirst'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find the first Badge that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeFindFirstOrThrowArgs} args - Arguments to find a Badge
     * @example
     * // Get one Badge
     * const badge = await prisma.badge.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BadgeFindFirstOrThrowArgs>(
      args?: SelectSubset<T, BadgeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__BadgeClient<
      $Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, 'findFirstOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more Badges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Badges
     * const badges = await prisma.badge.findMany()
     *
     * // Get first 10 Badges
     * const badges = await prisma.badge.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const badgeWithIdOnly = await prisma.badge.findMany({ select: { id: true } })
     *
     */
    findMany<T extends BadgeFindManyArgs>(
      args?: SelectSubset<T, BadgeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, 'findMany'>>;

    /**
     * Create a Badge.
     * @param {BadgeCreateArgs} args - Arguments to create a Badge.
     * @example
     * // Create one Badge
     * const Badge = await prisma.badge.create({
     *   data: {
     *     // ... data to create a Badge
     *   }
     * })
     *
     */
    create<T extends BadgeCreateArgs>(
      args: SelectSubset<T, BadgeCreateArgs<ExtArgs>>
    ): Prisma__BadgeClient<
      $Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, 'create'>,
      never,
      ExtArgs
    >;

    /**
     * Create many Badges.
     * @param {BadgeCreateManyArgs} args - Arguments to create many Badges.
     * @example
     * // Create many Badges
     * const badge = await prisma.badge.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends BadgeCreateManyArgs>(
      args?: SelectSubset<T, BadgeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Badges and returns the data saved in the database.
     * @param {BadgeCreateManyAndReturnArgs} args - Arguments to create many Badges.
     * @example
     * // Create many Badges
     * const badge = await prisma.badge.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Badges and only return the `id`
     * const badgeWithIdOnly = await prisma.badge.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends BadgeCreateManyAndReturnArgs>(
      args?: SelectSubset<T, BadgeCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, 'createManyAndReturn'>
    >;

    /**
     * Delete a Badge.
     * @param {BadgeDeleteArgs} args - Arguments to delete one Badge.
     * @example
     * // Delete one Badge
     * const Badge = await prisma.badge.delete({
     *   where: {
     *     // ... filter to delete one Badge
     *   }
     * })
     *
     */
    delete<T extends BadgeDeleteArgs>(
      args: SelectSubset<T, BadgeDeleteArgs<ExtArgs>>
    ): Prisma__BadgeClient<
      $Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, 'delete'>,
      never,
      ExtArgs
    >;

    /**
     * Update one Badge.
     * @param {BadgeUpdateArgs} args - Arguments to update one Badge.
     * @example
     * // Update one Badge
     * const badge = await prisma.badge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends BadgeUpdateArgs>(
      args: SelectSubset<T, BadgeUpdateArgs<ExtArgs>>
    ): Prisma__BadgeClient<
      $Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, 'update'>,
      never,
      ExtArgs
    >;

    /**
     * Delete zero or more Badges.
     * @param {BadgeDeleteManyArgs} args - Arguments to filter Badges to delete.
     * @example
     * // Delete a few Badges
     * const { count } = await prisma.badge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends BadgeDeleteManyArgs>(
      args?: SelectSubset<T, BadgeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Badges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Badges
     * const badge = await prisma.badge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends BadgeUpdateManyArgs>(
      args: SelectSubset<T, BadgeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Badge.
     * @param {BadgeUpsertArgs} args - Arguments to update or create a Badge.
     * @example
     * // Update or create a Badge
     * const badge = await prisma.badge.upsert({
     *   create: {
     *     // ... data to create a Badge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Badge we want to update
     *   }
     * })
     */
    upsert<T extends BadgeUpsertArgs>(
      args: SelectSubset<T, BadgeUpsertArgs<ExtArgs>>
    ): Prisma__BadgeClient<
      $Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, 'upsert'>,
      never,
      ExtArgs
    >;

    /**
     * Count the number of Badges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeCountArgs} args - Arguments to filter Badges to count.
     * @example
     * // Count the number of Badges
     * const count = await prisma.badge.count({
     *   where: {
     *     // ... the filter for the Badges we want to count
     *   }
     * })
     **/
    count<T extends BadgeCountArgs>(
      args?: Subset<T, BadgeCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BadgeCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Badge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends BadgeAggregateArgs>(
      args: Subset<T, BadgeAggregateArgs>
    ): Prisma.PrismaPromise<GetBadgeAggregateType<T>>;

    /**
     * Group by Badge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends BadgeGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BadgeGroupByArgs['orderBy'] }
        : { orderBy?: BadgeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, BadgeGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetBadgeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Badge model
     */
    readonly fields: BadgeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Badge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BadgeClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Badge model
   */
  interface BadgeFieldRefs {
    readonly id: FieldRef<'Badge', 'String'>;
    readonly slug: FieldRef<'Badge', 'String'>;
    readonly name: FieldRef<'Badge', 'String'>;
    readonly description: FieldRef<'Badge', 'String'>;
    readonly icon: FieldRef<'Badge', 'String'>;
    readonly xpRequired: FieldRef<'Badge', 'Int'>;
    readonly rarity: FieldRef<'Badge', 'String'>;
    readonly createdAt: FieldRef<'Badge', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * Badge findUnique
   */
  export type BadgeFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null;
    /**
     * Filter, which Badge to fetch.
     */
    where: BadgeWhereUniqueInput;
  };

  /**
   * Badge findUniqueOrThrow
   */
  export type BadgeFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null;
    /**
     * Filter, which Badge to fetch.
     */
    where: BadgeWhereUniqueInput;
  };

  /**
   * Badge findFirst
   */
  export type BadgeFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null;
    /**
     * Filter, which Badge to fetch.
     */
    where?: BadgeWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Badges to fetch.
     */
    orderBy?: BadgeOrderByWithRelationInput | BadgeOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Badges.
     */
    cursor?: BadgeWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Badges from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Badges.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Badges.
     */
    distinct?: BadgeScalarFieldEnum | BadgeScalarFieldEnum[];
  };

  /**
   * Badge findFirstOrThrow
   */
  export type BadgeFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null;
    /**
     * Filter, which Badge to fetch.
     */
    where?: BadgeWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Badges to fetch.
     */
    orderBy?: BadgeOrderByWithRelationInput | BadgeOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Badges.
     */
    cursor?: BadgeWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Badges from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Badges.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Badges.
     */
    distinct?: BadgeScalarFieldEnum | BadgeScalarFieldEnum[];
  };

  /**
   * Badge findMany
   */
  export type BadgeFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null;
    /**
     * Filter, which Badges to fetch.
     */
    where?: BadgeWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Badges to fetch.
     */
    orderBy?: BadgeOrderByWithRelationInput | BadgeOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Badges.
     */
    cursor?: BadgeWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Badges from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Badges.
     */
    skip?: number;
    distinct?: BadgeScalarFieldEnum | BadgeScalarFieldEnum[];
  };

  /**
   * Badge create
   */
  export type BadgeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the Badge
       */
      select?: BadgeSelect<ExtArgs> | null;
      /**
       * The data needed to create a Badge.
       */
      data: XOR<BadgeCreateInput, BadgeUncheckedCreateInput>;
    };

  /**
   * Badge createMany
   */
  export type BadgeCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Badges.
     */
    data: BadgeCreateManyInput | BadgeCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Badge createManyAndReturn
   */
  export type BadgeCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * The data used to create many Badges.
     */
    data: BadgeCreateManyInput | BadgeCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Badge update
   */
  export type BadgeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the Badge
       */
      select?: BadgeSelect<ExtArgs> | null;
      /**
       * The data needed to update a Badge.
       */
      data: XOR<BadgeUpdateInput, BadgeUncheckedUpdateInput>;
      /**
       * Choose, which Badge to update.
       */
      where: BadgeWhereUniqueInput;
    };

  /**
   * Badge updateMany
   */
  export type BadgeUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Badges.
     */
    data: XOR<BadgeUpdateManyMutationInput, BadgeUncheckedUpdateManyInput>;
    /**
     * Filter which Badges to update
     */
    where?: BadgeWhereInput;
  };

  /**
   * Badge upsert
   */
  export type BadgeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the Badge
       */
      select?: BadgeSelect<ExtArgs> | null;
      /**
       * The filter to search for the Badge to update in case it exists.
       */
      where: BadgeWhereUniqueInput;
      /**
       * In case the Badge found by the `where` argument doesn't exist, create a new Badge with this data.
       */
      create: XOR<BadgeCreateInput, BadgeUncheckedCreateInput>;
      /**
       * In case the Badge was found with the provided `where` argument, update it with this data.
       */
      update: XOR<BadgeUpdateInput, BadgeUncheckedUpdateInput>;
    };

  /**
   * Badge delete
   */
  export type BadgeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the Badge
       */
      select?: BadgeSelect<ExtArgs> | null;
      /**
       * Filter which Badge to delete.
       */
      where: BadgeWhereUniqueInput;
    };

  /**
   * Badge deleteMany
   */
  export type BadgeDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Badges to delete
     */
    where?: BadgeWhereInput;
  };

  /**
   * Badge without action
   */
  export type BadgeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the Badge
       */
      select?: BadgeSelect<ExtArgs> | null;
    };

  /**
   * Model XpEvent
   */

  export type AggregateXpEvent = {
    _count: XpEventCountAggregateOutputType | null;
    _avg: XpEventAvgAggregateOutputType | null;
    _sum: XpEventSumAggregateOutputType | null;
    _min: XpEventMinAggregateOutputType | null;
    _max: XpEventMaxAggregateOutputType | null;
  };

  export type XpEventAvgAggregateOutputType = {
    points: number | null;
  };

  export type XpEventSumAggregateOutputType = {
    points: number | null;
  };

  export type XpEventMinAggregateOutputType = {
    id: string | null;
    userId: string | null;
    eventType: string | null;
    points: number | null;
    refType: string | null;
    refId: string | null;
    createdAt: Date | null;
  };

  export type XpEventMaxAggregateOutputType = {
    id: string | null;
    userId: string | null;
    eventType: string | null;
    points: number | null;
    refType: string | null;
    refId: string | null;
    createdAt: Date | null;
  };

  export type XpEventCountAggregateOutputType = {
    id: number;
    userId: number;
    eventType: number;
    points: number;
    refType: number;
    refId: number;
    metadata: number;
    createdAt: number;
    _all: number;
  };

  export type XpEventAvgAggregateInputType = {
    points?: true;
  };

  export type XpEventSumAggregateInputType = {
    points?: true;
  };

  export type XpEventMinAggregateInputType = {
    id?: true;
    userId?: true;
    eventType?: true;
    points?: true;
    refType?: true;
    refId?: true;
    createdAt?: true;
  };

  export type XpEventMaxAggregateInputType = {
    id?: true;
    userId?: true;
    eventType?: true;
    points?: true;
    refType?: true;
    refId?: true;
    createdAt?: true;
  };

  export type XpEventCountAggregateInputType = {
    id?: true;
    userId?: true;
    eventType?: true;
    points?: true;
    refType?: true;
    refId?: true;
    metadata?: true;
    createdAt?: true;
    _all?: true;
  };

  export type XpEventAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which XpEvent to aggregate.
     */
    where?: XpEventWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of XpEvents to fetch.
     */
    orderBy?: XpEventOrderByWithRelationInput | XpEventOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: XpEventWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` XpEvents from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` XpEvents.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned XpEvents
     **/
    _count?: true | XpEventCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: XpEventAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: XpEventSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: XpEventMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: XpEventMaxAggregateInputType;
  };

  export type GetXpEventAggregateType<T extends XpEventAggregateArgs> = {
    [P in keyof T & keyof AggregateXpEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateXpEvent[P]>
      : GetScalarType<T[P], AggregateXpEvent[P]>;
  };

  export type XpEventGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: XpEventWhereInput;
    orderBy?: XpEventOrderByWithAggregationInput | XpEventOrderByWithAggregationInput[];
    by: XpEventScalarFieldEnum[] | XpEventScalarFieldEnum;
    having?: XpEventScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: XpEventCountAggregateInputType | true;
    _avg?: XpEventAvgAggregateInputType;
    _sum?: XpEventSumAggregateInputType;
    _min?: XpEventMinAggregateInputType;
    _max?: XpEventMaxAggregateInputType;
  };

  export type XpEventGroupByOutputType = {
    id: string;
    userId: string;
    eventType: string;
    points: number;
    refType: string | null;
    refId: string | null;
    metadata: JsonValue | null;
    createdAt: Date;
    _count: XpEventCountAggregateOutputType | null;
    _avg: XpEventAvgAggregateOutputType | null;
    _sum: XpEventSumAggregateOutputType | null;
    _min: XpEventMinAggregateOutputType | null;
    _max: XpEventMaxAggregateOutputType | null;
  };

  type GetXpEventGroupByPayload<T extends XpEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<XpEventGroupByOutputType, T['by']> & {
        [P in keyof T & keyof XpEventGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], XpEventGroupByOutputType[P]>
          : GetScalarType<T[P], XpEventGroupByOutputType[P]>;
      }
    >
  >;

  export type XpEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        userId?: boolean;
        eventType?: boolean;
        points?: boolean;
        refType?: boolean;
        refId?: boolean;
        metadata?: boolean;
        createdAt?: boolean;
        user?: boolean | UserDefaultArgs<ExtArgs>;
      },
      ExtArgs['result']['xpEvent']
    >;

  export type XpEventSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      eventType?: boolean;
      points?: boolean;
      refType?: boolean;
      refId?: boolean;
      metadata?: boolean;
      createdAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['xpEvent']
  >;

  export type XpEventSelectScalar = {
    id?: boolean;
    userId?: boolean;
    eventType?: boolean;
    points?: boolean;
    refType?: boolean;
    refId?: boolean;
    metadata?: boolean;
    createdAt?: boolean;
  };

  export type XpEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type XpEventIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $XpEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      name: 'XpEvent';
      objects: {
        user: Prisma.$UserPayload<ExtArgs>;
      };
      scalars: $Extensions.GetPayloadResult<
        {
          id: string;
          userId: string;
          eventType: string;
          points: number;
          refType: string | null;
          refId: string | null;
          metadata: Prisma.JsonValue | null;
          createdAt: Date;
        },
        ExtArgs['result']['xpEvent']
      >;
      composites: {};
    };

  type XpEventGetPayload<S extends boolean | null | undefined | XpEventDefaultArgs> =
    $Result.GetResult<Prisma.$XpEventPayload, S>;

  type XpEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    XpEventFindManyArgs,
    'select' | 'include' | 'distinct'
  > & {
    select?: XpEventCountAggregateInputType | true;
  };

  export interface XpEventDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['XpEvent']; meta: { name: 'XpEvent' } };
    /**
     * Find zero or one XpEvent that matches the filter.
     * @param {XpEventFindUniqueArgs} args - Arguments to find a XpEvent
     * @example
     * // Get one XpEvent
     * const xpEvent = await prisma.xpEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends XpEventFindUniqueArgs>(
      args: SelectSubset<T, XpEventFindUniqueArgs<ExtArgs>>
    ): Prisma__XpEventClient<
      $Result.GetResult<Prisma.$XpEventPayload<ExtArgs>, T, 'findUnique'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find one XpEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {XpEventFindUniqueOrThrowArgs} args - Arguments to find a XpEvent
     * @example
     * // Get one XpEvent
     * const xpEvent = await prisma.xpEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends XpEventFindUniqueOrThrowArgs>(
      args: SelectSubset<T, XpEventFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__XpEventClient<
      $Result.GetResult<Prisma.$XpEventPayload<ExtArgs>, T, 'findUniqueOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find the first XpEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XpEventFindFirstArgs} args - Arguments to find a XpEvent
     * @example
     * // Get one XpEvent
     * const xpEvent = await prisma.xpEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends XpEventFindFirstArgs>(
      args?: SelectSubset<T, XpEventFindFirstArgs<ExtArgs>>
    ): Prisma__XpEventClient<
      $Result.GetResult<Prisma.$XpEventPayload<ExtArgs>, T, 'findFirst'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find the first XpEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XpEventFindFirstOrThrowArgs} args - Arguments to find a XpEvent
     * @example
     * // Get one XpEvent
     * const xpEvent = await prisma.xpEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends XpEventFindFirstOrThrowArgs>(
      args?: SelectSubset<T, XpEventFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__XpEventClient<
      $Result.GetResult<Prisma.$XpEventPayload<ExtArgs>, T, 'findFirstOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more XpEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XpEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all XpEvents
     * const xpEvents = await prisma.xpEvent.findMany()
     *
     * // Get first 10 XpEvents
     * const xpEvents = await prisma.xpEvent.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const xpEventWithIdOnly = await prisma.xpEvent.findMany({ select: { id: true } })
     *
     */
    findMany<T extends XpEventFindManyArgs>(
      args?: SelectSubset<T, XpEventFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$XpEventPayload<ExtArgs>, T, 'findMany'>>;

    /**
     * Create a XpEvent.
     * @param {XpEventCreateArgs} args - Arguments to create a XpEvent.
     * @example
     * // Create one XpEvent
     * const XpEvent = await prisma.xpEvent.create({
     *   data: {
     *     // ... data to create a XpEvent
     *   }
     * })
     *
     */
    create<T extends XpEventCreateArgs>(
      args: SelectSubset<T, XpEventCreateArgs<ExtArgs>>
    ): Prisma__XpEventClient<
      $Result.GetResult<Prisma.$XpEventPayload<ExtArgs>, T, 'create'>,
      never,
      ExtArgs
    >;

    /**
     * Create many XpEvents.
     * @param {XpEventCreateManyArgs} args - Arguments to create many XpEvents.
     * @example
     * // Create many XpEvents
     * const xpEvent = await prisma.xpEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends XpEventCreateManyArgs>(
      args?: SelectSubset<T, XpEventCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many XpEvents and returns the data saved in the database.
     * @param {XpEventCreateManyAndReturnArgs} args - Arguments to create many XpEvents.
     * @example
     * // Create many XpEvents
     * const xpEvent = await prisma.xpEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many XpEvents and only return the `id`
     * const xpEventWithIdOnly = await prisma.xpEvent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends XpEventCreateManyAndReturnArgs>(
      args?: SelectSubset<T, XpEventCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$XpEventPayload<ExtArgs>, T, 'createManyAndReturn'>
    >;

    /**
     * Delete a XpEvent.
     * @param {XpEventDeleteArgs} args - Arguments to delete one XpEvent.
     * @example
     * // Delete one XpEvent
     * const XpEvent = await prisma.xpEvent.delete({
     *   where: {
     *     // ... filter to delete one XpEvent
     *   }
     * })
     *
     */
    delete<T extends XpEventDeleteArgs>(
      args: SelectSubset<T, XpEventDeleteArgs<ExtArgs>>
    ): Prisma__XpEventClient<
      $Result.GetResult<Prisma.$XpEventPayload<ExtArgs>, T, 'delete'>,
      never,
      ExtArgs
    >;

    /**
     * Update one XpEvent.
     * @param {XpEventUpdateArgs} args - Arguments to update one XpEvent.
     * @example
     * // Update one XpEvent
     * const xpEvent = await prisma.xpEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends XpEventUpdateArgs>(
      args: SelectSubset<T, XpEventUpdateArgs<ExtArgs>>
    ): Prisma__XpEventClient<
      $Result.GetResult<Prisma.$XpEventPayload<ExtArgs>, T, 'update'>,
      never,
      ExtArgs
    >;

    /**
     * Delete zero or more XpEvents.
     * @param {XpEventDeleteManyArgs} args - Arguments to filter XpEvents to delete.
     * @example
     * // Delete a few XpEvents
     * const { count } = await prisma.xpEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends XpEventDeleteManyArgs>(
      args?: SelectSubset<T, XpEventDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more XpEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XpEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many XpEvents
     * const xpEvent = await prisma.xpEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends XpEventUpdateManyArgs>(
      args: SelectSubset<T, XpEventUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one XpEvent.
     * @param {XpEventUpsertArgs} args - Arguments to update or create a XpEvent.
     * @example
     * // Update or create a XpEvent
     * const xpEvent = await prisma.xpEvent.upsert({
     *   create: {
     *     // ... data to create a XpEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the XpEvent we want to update
     *   }
     * })
     */
    upsert<T extends XpEventUpsertArgs>(
      args: SelectSubset<T, XpEventUpsertArgs<ExtArgs>>
    ): Prisma__XpEventClient<
      $Result.GetResult<Prisma.$XpEventPayload<ExtArgs>, T, 'upsert'>,
      never,
      ExtArgs
    >;

    /**
     * Count the number of XpEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XpEventCountArgs} args - Arguments to filter XpEvents to count.
     * @example
     * // Count the number of XpEvents
     * const count = await prisma.xpEvent.count({
     *   where: {
     *     // ... the filter for the XpEvents we want to count
     *   }
     * })
     **/
    count<T extends XpEventCountArgs>(
      args?: Subset<T, XpEventCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], XpEventCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a XpEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XpEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends XpEventAggregateArgs>(
      args: Subset<T, XpEventAggregateArgs>
    ): Prisma.PrismaPromise<GetXpEventAggregateType<T>>;

    /**
     * Group by XpEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {XpEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends XpEventGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: XpEventGroupByArgs['orderBy'] }
        : { orderBy?: XpEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, XpEventGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetXpEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the XpEvent model
     */
    readonly fields: XpEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for XpEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__XpEventClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null,
      Null,
      ExtArgs
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the XpEvent model
   */
  interface XpEventFieldRefs {
    readonly id: FieldRef<'XpEvent', 'String'>;
    readonly userId: FieldRef<'XpEvent', 'String'>;
    readonly eventType: FieldRef<'XpEvent', 'String'>;
    readonly points: FieldRef<'XpEvent', 'Int'>;
    readonly refType: FieldRef<'XpEvent', 'String'>;
    readonly refId: FieldRef<'XpEvent', 'String'>;
    readonly metadata: FieldRef<'XpEvent', 'Json'>;
    readonly createdAt: FieldRef<'XpEvent', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * XpEvent findUnique
   */
  export type XpEventFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the XpEvent
     */
    select?: XpEventSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XpEventInclude<ExtArgs> | null;
    /**
     * Filter, which XpEvent to fetch.
     */
    where: XpEventWhereUniqueInput;
  };

  /**
   * XpEvent findUniqueOrThrow
   */
  export type XpEventFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the XpEvent
     */
    select?: XpEventSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XpEventInclude<ExtArgs> | null;
    /**
     * Filter, which XpEvent to fetch.
     */
    where: XpEventWhereUniqueInput;
  };

  /**
   * XpEvent findFirst
   */
  export type XpEventFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the XpEvent
     */
    select?: XpEventSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XpEventInclude<ExtArgs> | null;
    /**
     * Filter, which XpEvent to fetch.
     */
    where?: XpEventWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of XpEvents to fetch.
     */
    orderBy?: XpEventOrderByWithRelationInput | XpEventOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for XpEvents.
     */
    cursor?: XpEventWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` XpEvents from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` XpEvents.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of XpEvents.
     */
    distinct?: XpEventScalarFieldEnum | XpEventScalarFieldEnum[];
  };

  /**
   * XpEvent findFirstOrThrow
   */
  export type XpEventFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the XpEvent
     */
    select?: XpEventSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XpEventInclude<ExtArgs> | null;
    /**
     * Filter, which XpEvent to fetch.
     */
    where?: XpEventWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of XpEvents to fetch.
     */
    orderBy?: XpEventOrderByWithRelationInput | XpEventOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for XpEvents.
     */
    cursor?: XpEventWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` XpEvents from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` XpEvents.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of XpEvents.
     */
    distinct?: XpEventScalarFieldEnum | XpEventScalarFieldEnum[];
  };

  /**
   * XpEvent findMany
   */
  export type XpEventFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the XpEvent
     */
    select?: XpEventSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XpEventInclude<ExtArgs> | null;
    /**
     * Filter, which XpEvents to fetch.
     */
    where?: XpEventWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of XpEvents to fetch.
     */
    orderBy?: XpEventOrderByWithRelationInput | XpEventOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing XpEvents.
     */
    cursor?: XpEventWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` XpEvents from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` XpEvents.
     */
    skip?: number;
    distinct?: XpEventScalarFieldEnum | XpEventScalarFieldEnum[];
  };

  /**
   * XpEvent create
   */
  export type XpEventCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the XpEvent
     */
    select?: XpEventSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XpEventInclude<ExtArgs> | null;
    /**
     * The data needed to create a XpEvent.
     */
    data: XOR<XpEventCreateInput, XpEventUncheckedCreateInput>;
  };

  /**
   * XpEvent createMany
   */
  export type XpEventCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many XpEvents.
     */
    data: XpEventCreateManyInput | XpEventCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * XpEvent createManyAndReturn
   */
  export type XpEventCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the XpEvent
     */
    select?: XpEventSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * The data used to create many XpEvents.
     */
    data: XpEventCreateManyInput | XpEventCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XpEventIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * XpEvent update
   */
  export type XpEventUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the XpEvent
     */
    select?: XpEventSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XpEventInclude<ExtArgs> | null;
    /**
     * The data needed to update a XpEvent.
     */
    data: XOR<XpEventUpdateInput, XpEventUncheckedUpdateInput>;
    /**
     * Choose, which XpEvent to update.
     */
    where: XpEventWhereUniqueInput;
  };

  /**
   * XpEvent updateMany
   */
  export type XpEventUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update XpEvents.
     */
    data: XOR<XpEventUpdateManyMutationInput, XpEventUncheckedUpdateManyInput>;
    /**
     * Filter which XpEvents to update
     */
    where?: XpEventWhereInput;
  };

  /**
   * XpEvent upsert
   */
  export type XpEventUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the XpEvent
     */
    select?: XpEventSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XpEventInclude<ExtArgs> | null;
    /**
     * The filter to search for the XpEvent to update in case it exists.
     */
    where: XpEventWhereUniqueInput;
    /**
     * In case the XpEvent found by the `where` argument doesn't exist, create a new XpEvent with this data.
     */
    create: XOR<XpEventCreateInput, XpEventUncheckedCreateInput>;
    /**
     * In case the XpEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<XpEventUpdateInput, XpEventUncheckedUpdateInput>;
  };

  /**
   * XpEvent delete
   */
  export type XpEventDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the XpEvent
     */
    select?: XpEventSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XpEventInclude<ExtArgs> | null;
    /**
     * Filter which XpEvent to delete.
     */
    where: XpEventWhereUniqueInput;
  };

  /**
   * XpEvent deleteMany
   */
  export type XpEventDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which XpEvents to delete
     */
    where?: XpEventWhereInput;
  };

  /**
   * XpEvent without action
   */
  export type XpEventDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the XpEvent
     */
    select?: XpEventSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: XpEventInclude<ExtArgs> | null;
  };

  /**
   * Model LeaderboardSnapshot
   */

  export type AggregateLeaderboardSnapshot = {
    _count: LeaderboardSnapshotCountAggregateOutputType | null;
    _min: LeaderboardSnapshotMinAggregateOutputType | null;
    _max: LeaderboardSnapshotMaxAggregateOutputType | null;
  };

  export type LeaderboardSnapshotMinAggregateOutputType = {
    id: string | null;
    scope: $Enums.LeaderboardScope | null;
    scopeId: string | null;
    period: $Enums.LeaderboardPeriod | null;
    createdAt: Date | null;
  };

  export type LeaderboardSnapshotMaxAggregateOutputType = {
    id: string | null;
    scope: $Enums.LeaderboardScope | null;
    scopeId: string | null;
    period: $Enums.LeaderboardPeriod | null;
    createdAt: Date | null;
  };

  export type LeaderboardSnapshotCountAggregateOutputType = {
    id: number;
    scope: number;
    scopeId: number;
    period: number;
    data: number;
    createdAt: number;
    _all: number;
  };

  export type LeaderboardSnapshotMinAggregateInputType = {
    id?: true;
    scope?: true;
    scopeId?: true;
    period?: true;
    createdAt?: true;
  };

  export type LeaderboardSnapshotMaxAggregateInputType = {
    id?: true;
    scope?: true;
    scopeId?: true;
    period?: true;
    createdAt?: true;
  };

  export type LeaderboardSnapshotCountAggregateInputType = {
    id?: true;
    scope?: true;
    scopeId?: true;
    period?: true;
    data?: true;
    createdAt?: true;
    _all?: true;
  };

  export type LeaderboardSnapshotAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which LeaderboardSnapshot to aggregate.
     */
    where?: LeaderboardSnapshotWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of LeaderboardSnapshots to fetch.
     */
    orderBy?:
      | LeaderboardSnapshotOrderByWithRelationInput
      | LeaderboardSnapshotOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: LeaderboardSnapshotWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` LeaderboardSnapshots from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` LeaderboardSnapshots.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned LeaderboardSnapshots
     **/
    _count?: true | LeaderboardSnapshotCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: LeaderboardSnapshotMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: LeaderboardSnapshotMaxAggregateInputType;
  };

  export type GetLeaderboardSnapshotAggregateType<T extends LeaderboardSnapshotAggregateArgs> = {
    [P in keyof T & keyof AggregateLeaderboardSnapshot]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeaderboardSnapshot[P]>
      : GetScalarType<T[P], AggregateLeaderboardSnapshot[P]>;
  };

  export type LeaderboardSnapshotGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: LeaderboardSnapshotWhereInput;
    orderBy?:
      | LeaderboardSnapshotOrderByWithAggregationInput
      | LeaderboardSnapshotOrderByWithAggregationInput[];
    by: LeaderboardSnapshotScalarFieldEnum[] | LeaderboardSnapshotScalarFieldEnum;
    having?: LeaderboardSnapshotScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: LeaderboardSnapshotCountAggregateInputType | true;
    _min?: LeaderboardSnapshotMinAggregateInputType;
    _max?: LeaderboardSnapshotMaxAggregateInputType;
  };

  export type LeaderboardSnapshotGroupByOutputType = {
    id: string;
    scope: $Enums.LeaderboardScope;
    scopeId: string | null;
    period: $Enums.LeaderboardPeriod;
    data: JsonValue;
    createdAt: Date;
    _count: LeaderboardSnapshotCountAggregateOutputType | null;
    _min: LeaderboardSnapshotMinAggregateOutputType | null;
    _max: LeaderboardSnapshotMaxAggregateOutputType | null;
  };

  type GetLeaderboardSnapshotGroupByPayload<T extends LeaderboardSnapshotGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<LeaderboardSnapshotGroupByOutputType, T['by']> & {
          [P in keyof T & keyof LeaderboardSnapshotGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeaderboardSnapshotGroupByOutputType[P]>
            : GetScalarType<T[P], LeaderboardSnapshotGroupByOutputType[P]>;
        }
      >
    >;

  export type LeaderboardSnapshotSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      scope?: boolean;
      scopeId?: boolean;
      period?: boolean;
      data?: boolean;
      createdAt?: boolean;
    },
    ExtArgs['result']['leaderboardSnapshot']
  >;

  export type LeaderboardSnapshotSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      scope?: boolean;
      scopeId?: boolean;
      period?: boolean;
      data?: boolean;
      createdAt?: boolean;
    },
    ExtArgs['result']['leaderboardSnapshot']
  >;

  export type LeaderboardSnapshotSelectScalar = {
    id?: boolean;
    scope?: boolean;
    scopeId?: boolean;
    period?: boolean;
    data?: boolean;
    createdAt?: boolean;
  };

  export type $LeaderboardSnapshotPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'LeaderboardSnapshot';
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        scope: $Enums.LeaderboardScope;
        scopeId: string | null;
        period: $Enums.LeaderboardPeriod;
        data: Prisma.JsonValue;
        createdAt: Date;
      },
      ExtArgs['result']['leaderboardSnapshot']
    >;
    composites: {};
  };

  type LeaderboardSnapshotGetPayload<
    S extends boolean | null | undefined | LeaderboardSnapshotDefaultArgs,
  > = $Result.GetResult<Prisma.$LeaderboardSnapshotPayload, S>;

  type LeaderboardSnapshotCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<LeaderboardSnapshotFindManyArgs, 'select' | 'include' | 'distinct'> & {
    select?: LeaderboardSnapshotCountAggregateInputType | true;
  };

  export interface LeaderboardSnapshotDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['LeaderboardSnapshot'];
      meta: { name: 'LeaderboardSnapshot' };
    };
    /**
     * Find zero or one LeaderboardSnapshot that matches the filter.
     * @param {LeaderboardSnapshotFindUniqueArgs} args - Arguments to find a LeaderboardSnapshot
     * @example
     * // Get one LeaderboardSnapshot
     * const leaderboardSnapshot = await prisma.leaderboardSnapshot.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeaderboardSnapshotFindUniqueArgs>(
      args: SelectSubset<T, LeaderboardSnapshotFindUniqueArgs<ExtArgs>>
    ): Prisma__LeaderboardSnapshotClient<
      $Result.GetResult<Prisma.$LeaderboardSnapshotPayload<ExtArgs>, T, 'findUnique'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find one LeaderboardSnapshot that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LeaderboardSnapshotFindUniqueOrThrowArgs} args - Arguments to find a LeaderboardSnapshot
     * @example
     * // Get one LeaderboardSnapshot
     * const leaderboardSnapshot = await prisma.leaderboardSnapshot.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeaderboardSnapshotFindUniqueOrThrowArgs>(
      args: SelectSubset<T, LeaderboardSnapshotFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__LeaderboardSnapshotClient<
      $Result.GetResult<Prisma.$LeaderboardSnapshotPayload<ExtArgs>, T, 'findUniqueOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find the first LeaderboardSnapshot that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardSnapshotFindFirstArgs} args - Arguments to find a LeaderboardSnapshot
     * @example
     * // Get one LeaderboardSnapshot
     * const leaderboardSnapshot = await prisma.leaderboardSnapshot.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeaderboardSnapshotFindFirstArgs>(
      args?: SelectSubset<T, LeaderboardSnapshotFindFirstArgs<ExtArgs>>
    ): Prisma__LeaderboardSnapshotClient<
      $Result.GetResult<Prisma.$LeaderboardSnapshotPayload<ExtArgs>, T, 'findFirst'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find the first LeaderboardSnapshot that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardSnapshotFindFirstOrThrowArgs} args - Arguments to find a LeaderboardSnapshot
     * @example
     * // Get one LeaderboardSnapshot
     * const leaderboardSnapshot = await prisma.leaderboardSnapshot.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeaderboardSnapshotFindFirstOrThrowArgs>(
      args?: SelectSubset<T, LeaderboardSnapshotFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__LeaderboardSnapshotClient<
      $Result.GetResult<Prisma.$LeaderboardSnapshotPayload<ExtArgs>, T, 'findFirstOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more LeaderboardSnapshots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardSnapshotFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LeaderboardSnapshots
     * const leaderboardSnapshots = await prisma.leaderboardSnapshot.findMany()
     *
     * // Get first 10 LeaderboardSnapshots
     * const leaderboardSnapshots = await prisma.leaderboardSnapshot.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const leaderboardSnapshotWithIdOnly = await prisma.leaderboardSnapshot.findMany({ select: { id: true } })
     *
     */
    findMany<T extends LeaderboardSnapshotFindManyArgs>(
      args?: SelectSubset<T, LeaderboardSnapshotFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$LeaderboardSnapshotPayload<ExtArgs>, T, 'findMany'>
    >;

    /**
     * Create a LeaderboardSnapshot.
     * @param {LeaderboardSnapshotCreateArgs} args - Arguments to create a LeaderboardSnapshot.
     * @example
     * // Create one LeaderboardSnapshot
     * const LeaderboardSnapshot = await prisma.leaderboardSnapshot.create({
     *   data: {
     *     // ... data to create a LeaderboardSnapshot
     *   }
     * })
     *
     */
    create<T extends LeaderboardSnapshotCreateArgs>(
      args: SelectSubset<T, LeaderboardSnapshotCreateArgs<ExtArgs>>
    ): Prisma__LeaderboardSnapshotClient<
      $Result.GetResult<Prisma.$LeaderboardSnapshotPayload<ExtArgs>, T, 'create'>,
      never,
      ExtArgs
    >;

    /**
     * Create many LeaderboardSnapshots.
     * @param {LeaderboardSnapshotCreateManyArgs} args - Arguments to create many LeaderboardSnapshots.
     * @example
     * // Create many LeaderboardSnapshots
     * const leaderboardSnapshot = await prisma.leaderboardSnapshot.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends LeaderboardSnapshotCreateManyArgs>(
      args?: SelectSubset<T, LeaderboardSnapshotCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many LeaderboardSnapshots and returns the data saved in the database.
     * @param {LeaderboardSnapshotCreateManyAndReturnArgs} args - Arguments to create many LeaderboardSnapshots.
     * @example
     * // Create many LeaderboardSnapshots
     * const leaderboardSnapshot = await prisma.leaderboardSnapshot.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many LeaderboardSnapshots and only return the `id`
     * const leaderboardSnapshotWithIdOnly = await prisma.leaderboardSnapshot.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends LeaderboardSnapshotCreateManyAndReturnArgs>(
      args?: SelectSubset<T, LeaderboardSnapshotCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$LeaderboardSnapshotPayload<ExtArgs>, T, 'createManyAndReturn'>
    >;

    /**
     * Delete a LeaderboardSnapshot.
     * @param {LeaderboardSnapshotDeleteArgs} args - Arguments to delete one LeaderboardSnapshot.
     * @example
     * // Delete one LeaderboardSnapshot
     * const LeaderboardSnapshot = await prisma.leaderboardSnapshot.delete({
     *   where: {
     *     // ... filter to delete one LeaderboardSnapshot
     *   }
     * })
     *
     */
    delete<T extends LeaderboardSnapshotDeleteArgs>(
      args: SelectSubset<T, LeaderboardSnapshotDeleteArgs<ExtArgs>>
    ): Prisma__LeaderboardSnapshotClient<
      $Result.GetResult<Prisma.$LeaderboardSnapshotPayload<ExtArgs>, T, 'delete'>,
      never,
      ExtArgs
    >;

    /**
     * Update one LeaderboardSnapshot.
     * @param {LeaderboardSnapshotUpdateArgs} args - Arguments to update one LeaderboardSnapshot.
     * @example
     * // Update one LeaderboardSnapshot
     * const leaderboardSnapshot = await prisma.leaderboardSnapshot.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends LeaderboardSnapshotUpdateArgs>(
      args: SelectSubset<T, LeaderboardSnapshotUpdateArgs<ExtArgs>>
    ): Prisma__LeaderboardSnapshotClient<
      $Result.GetResult<Prisma.$LeaderboardSnapshotPayload<ExtArgs>, T, 'update'>,
      never,
      ExtArgs
    >;

    /**
     * Delete zero or more LeaderboardSnapshots.
     * @param {LeaderboardSnapshotDeleteManyArgs} args - Arguments to filter LeaderboardSnapshots to delete.
     * @example
     * // Delete a few LeaderboardSnapshots
     * const { count } = await prisma.leaderboardSnapshot.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends LeaderboardSnapshotDeleteManyArgs>(
      args?: SelectSubset<T, LeaderboardSnapshotDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more LeaderboardSnapshots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardSnapshotUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LeaderboardSnapshots
     * const leaderboardSnapshot = await prisma.leaderboardSnapshot.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends LeaderboardSnapshotUpdateManyArgs>(
      args: SelectSubset<T, LeaderboardSnapshotUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one LeaderboardSnapshot.
     * @param {LeaderboardSnapshotUpsertArgs} args - Arguments to update or create a LeaderboardSnapshot.
     * @example
     * // Update or create a LeaderboardSnapshot
     * const leaderboardSnapshot = await prisma.leaderboardSnapshot.upsert({
     *   create: {
     *     // ... data to create a LeaderboardSnapshot
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LeaderboardSnapshot we want to update
     *   }
     * })
     */
    upsert<T extends LeaderboardSnapshotUpsertArgs>(
      args: SelectSubset<T, LeaderboardSnapshotUpsertArgs<ExtArgs>>
    ): Prisma__LeaderboardSnapshotClient<
      $Result.GetResult<Prisma.$LeaderboardSnapshotPayload<ExtArgs>, T, 'upsert'>,
      never,
      ExtArgs
    >;

    /**
     * Count the number of LeaderboardSnapshots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardSnapshotCountArgs} args - Arguments to filter LeaderboardSnapshots to count.
     * @example
     * // Count the number of LeaderboardSnapshots
     * const count = await prisma.leaderboardSnapshot.count({
     *   where: {
     *     // ... the filter for the LeaderboardSnapshots we want to count
     *   }
     * })
     **/
    count<T extends LeaderboardSnapshotCountArgs>(
      args?: Subset<T, LeaderboardSnapshotCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeaderboardSnapshotCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a LeaderboardSnapshot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardSnapshotAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends LeaderboardSnapshotAggregateArgs>(
      args: Subset<T, LeaderboardSnapshotAggregateArgs>
    ): Prisma.PrismaPromise<GetLeaderboardSnapshotAggregateType<T>>;

    /**
     * Group by LeaderboardSnapshot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardSnapshotGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends LeaderboardSnapshotGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeaderboardSnapshotGroupByArgs['orderBy'] }
        : { orderBy?: LeaderboardSnapshotGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, LeaderboardSnapshotGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetLeaderboardSnapshotGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the LeaderboardSnapshot model
     */
    readonly fields: LeaderboardSnapshotFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LeaderboardSnapshot.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeaderboardSnapshotClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the LeaderboardSnapshot model
   */
  interface LeaderboardSnapshotFieldRefs {
    readonly id: FieldRef<'LeaderboardSnapshot', 'String'>;
    readonly scope: FieldRef<'LeaderboardSnapshot', 'LeaderboardScope'>;
    readonly scopeId: FieldRef<'LeaderboardSnapshot', 'String'>;
    readonly period: FieldRef<'LeaderboardSnapshot', 'LeaderboardPeriod'>;
    readonly data: FieldRef<'LeaderboardSnapshot', 'Json'>;
    readonly createdAt: FieldRef<'LeaderboardSnapshot', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * LeaderboardSnapshot findUnique
   */
  export type LeaderboardSnapshotFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LeaderboardSnapshot
     */
    select?: LeaderboardSnapshotSelect<ExtArgs> | null;
    /**
     * Filter, which LeaderboardSnapshot to fetch.
     */
    where: LeaderboardSnapshotWhereUniqueInput;
  };

  /**
   * LeaderboardSnapshot findUniqueOrThrow
   */
  export type LeaderboardSnapshotFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LeaderboardSnapshot
     */
    select?: LeaderboardSnapshotSelect<ExtArgs> | null;
    /**
     * Filter, which LeaderboardSnapshot to fetch.
     */
    where: LeaderboardSnapshotWhereUniqueInput;
  };

  /**
   * LeaderboardSnapshot findFirst
   */
  export type LeaderboardSnapshotFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LeaderboardSnapshot
     */
    select?: LeaderboardSnapshotSelect<ExtArgs> | null;
    /**
     * Filter, which LeaderboardSnapshot to fetch.
     */
    where?: LeaderboardSnapshotWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of LeaderboardSnapshots to fetch.
     */
    orderBy?:
      | LeaderboardSnapshotOrderByWithRelationInput
      | LeaderboardSnapshotOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for LeaderboardSnapshots.
     */
    cursor?: LeaderboardSnapshotWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` LeaderboardSnapshots from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` LeaderboardSnapshots.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of LeaderboardSnapshots.
     */
    distinct?: LeaderboardSnapshotScalarFieldEnum | LeaderboardSnapshotScalarFieldEnum[];
  };

  /**
   * LeaderboardSnapshot findFirstOrThrow
   */
  export type LeaderboardSnapshotFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LeaderboardSnapshot
     */
    select?: LeaderboardSnapshotSelect<ExtArgs> | null;
    /**
     * Filter, which LeaderboardSnapshot to fetch.
     */
    where?: LeaderboardSnapshotWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of LeaderboardSnapshots to fetch.
     */
    orderBy?:
      | LeaderboardSnapshotOrderByWithRelationInput
      | LeaderboardSnapshotOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for LeaderboardSnapshots.
     */
    cursor?: LeaderboardSnapshotWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` LeaderboardSnapshots from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` LeaderboardSnapshots.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of LeaderboardSnapshots.
     */
    distinct?: LeaderboardSnapshotScalarFieldEnum | LeaderboardSnapshotScalarFieldEnum[];
  };

  /**
   * LeaderboardSnapshot findMany
   */
  export type LeaderboardSnapshotFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LeaderboardSnapshot
     */
    select?: LeaderboardSnapshotSelect<ExtArgs> | null;
    /**
     * Filter, which LeaderboardSnapshots to fetch.
     */
    where?: LeaderboardSnapshotWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of LeaderboardSnapshots to fetch.
     */
    orderBy?:
      | LeaderboardSnapshotOrderByWithRelationInput
      | LeaderboardSnapshotOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing LeaderboardSnapshots.
     */
    cursor?: LeaderboardSnapshotWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` LeaderboardSnapshots from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` LeaderboardSnapshots.
     */
    skip?: number;
    distinct?: LeaderboardSnapshotScalarFieldEnum | LeaderboardSnapshotScalarFieldEnum[];
  };

  /**
   * LeaderboardSnapshot create
   */
  export type LeaderboardSnapshotCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LeaderboardSnapshot
     */
    select?: LeaderboardSnapshotSelect<ExtArgs> | null;
    /**
     * The data needed to create a LeaderboardSnapshot.
     */
    data: XOR<LeaderboardSnapshotCreateInput, LeaderboardSnapshotUncheckedCreateInput>;
  };

  /**
   * LeaderboardSnapshot createMany
   */
  export type LeaderboardSnapshotCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many LeaderboardSnapshots.
     */
    data: LeaderboardSnapshotCreateManyInput | LeaderboardSnapshotCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * LeaderboardSnapshot createManyAndReturn
   */
  export type LeaderboardSnapshotCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LeaderboardSnapshot
     */
    select?: LeaderboardSnapshotSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * The data used to create many LeaderboardSnapshots.
     */
    data: LeaderboardSnapshotCreateManyInput | LeaderboardSnapshotCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * LeaderboardSnapshot update
   */
  export type LeaderboardSnapshotUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LeaderboardSnapshot
     */
    select?: LeaderboardSnapshotSelect<ExtArgs> | null;
    /**
     * The data needed to update a LeaderboardSnapshot.
     */
    data: XOR<LeaderboardSnapshotUpdateInput, LeaderboardSnapshotUncheckedUpdateInput>;
    /**
     * Choose, which LeaderboardSnapshot to update.
     */
    where: LeaderboardSnapshotWhereUniqueInput;
  };

  /**
   * LeaderboardSnapshot updateMany
   */
  export type LeaderboardSnapshotUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update LeaderboardSnapshots.
     */
    data: XOR<
      LeaderboardSnapshotUpdateManyMutationInput,
      LeaderboardSnapshotUncheckedUpdateManyInput
    >;
    /**
     * Filter which LeaderboardSnapshots to update
     */
    where?: LeaderboardSnapshotWhereInput;
  };

  /**
   * LeaderboardSnapshot upsert
   */
  export type LeaderboardSnapshotUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LeaderboardSnapshot
     */
    select?: LeaderboardSnapshotSelect<ExtArgs> | null;
    /**
     * The filter to search for the LeaderboardSnapshot to update in case it exists.
     */
    where: LeaderboardSnapshotWhereUniqueInput;
    /**
     * In case the LeaderboardSnapshot found by the `where` argument doesn't exist, create a new LeaderboardSnapshot with this data.
     */
    create: XOR<LeaderboardSnapshotCreateInput, LeaderboardSnapshotUncheckedCreateInput>;
    /**
     * In case the LeaderboardSnapshot was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeaderboardSnapshotUpdateInput, LeaderboardSnapshotUncheckedUpdateInput>;
  };

  /**
   * LeaderboardSnapshot delete
   */
  export type LeaderboardSnapshotDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LeaderboardSnapshot
     */
    select?: LeaderboardSnapshotSelect<ExtArgs> | null;
    /**
     * Filter which LeaderboardSnapshot to delete.
     */
    where: LeaderboardSnapshotWhereUniqueInput;
  };

  /**
   * LeaderboardSnapshot deleteMany
   */
  export type LeaderboardSnapshotDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which LeaderboardSnapshots to delete
     */
    where?: LeaderboardSnapshotWhereInput;
  };

  /**
   * LeaderboardSnapshot without action
   */
  export type LeaderboardSnapshotDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LeaderboardSnapshot
     */
    select?: LeaderboardSnapshotSelect<ExtArgs> | null;
  };

  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null;
    _min: NotificationMinAggregateOutputType | null;
    _max: NotificationMaxAggregateOutputType | null;
  };

  export type NotificationMinAggregateOutputType = {
    id: string | null;
    userId: string | null;
    type: string | null;
    readAt: Date | null;
    createdAt: Date | null;
  };

  export type NotificationMaxAggregateOutputType = {
    id: string | null;
    userId: string | null;
    type: string | null;
    readAt: Date | null;
    createdAt: Date | null;
  };

  export type NotificationCountAggregateOutputType = {
    id: number;
    userId: number;
    type: number;
    data: number;
    readAt: number;
    createdAt: number;
    _all: number;
  };

  export type NotificationMinAggregateInputType = {
    id?: true;
    userId?: true;
    type?: true;
    readAt?: true;
    createdAt?: true;
  };

  export type NotificationMaxAggregateInputType = {
    id?: true;
    userId?: true;
    type?: true;
    readAt?: true;
    createdAt?: true;
  };

  export type NotificationCountAggregateInputType = {
    id?: true;
    userId?: true;
    type?: true;
    data?: true;
    readAt?: true;
    createdAt?: true;
    _all?: true;
  };

  export type NotificationAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Notifications.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Notifications
     **/
    _count?: true | NotificationCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: NotificationMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: NotificationMaxAggregateInputType;
  };

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
    [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>;
  };

  export type NotificationGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: NotificationWhereInput;
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[];
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum;
    having?: NotificationScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: NotificationCountAggregateInputType | true;
    _min?: NotificationMinAggregateInputType;
    _max?: NotificationMaxAggregateInputType;
  };

  export type NotificationGroupByOutputType = {
    id: string;
    userId: string;
    type: string;
    data: JsonValue;
    readAt: Date | null;
    createdAt: Date;
    _count: NotificationCountAggregateOutputType | null;
    _min: NotificationMinAggregateOutputType | null;
    _max: NotificationMaxAggregateOutputType | null;
  };

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> & {
        [P in keyof T & keyof NotificationGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
          : GetScalarType<T[P], NotificationGroupByOutputType[P]>;
      }
    >
  >;

  export type NotificationSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      type?: boolean;
      data?: boolean;
      readAt?: boolean;
      createdAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['notification']
  >;

  export type NotificationSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      type?: boolean;
      data?: boolean;
      readAt?: boolean;
      createdAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['notification']
  >;

  export type NotificationSelectScalar = {
    id?: boolean;
    userId?: boolean;
    type?: boolean;
    data?: boolean;
    readAt?: boolean;
    createdAt?: boolean;
  };

  export type NotificationInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type NotificationIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $NotificationPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'Notification';
    objects: {
      user: Prisma.$UserPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        userId: string;
        type: string;
        data: Prisma.JsonValue;
        readAt: Date | null;
        createdAt: Date;
      },
      ExtArgs['result']['notification']
    >;
    composites: {};
  };

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> =
    $Result.GetResult<Prisma.$NotificationPayload, S>;

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationCountAggregateInputType | true;
    };

  export interface NotificationDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Notification'];
      meta: { name: 'Notification' };
    };
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(
      args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>
    ): Prisma__NotificationClient<
      $Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'findUnique'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(
      args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__NotificationClient<
      $Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'findUniqueOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(
      args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>
    ): Prisma__NotificationClient<
      $Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'findFirst'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(
      args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__NotificationClient<
      $Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'findFirstOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     *
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     *
     */
    findMany<T extends NotificationFindManyArgs>(
      args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'findMany'>>;

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     *
     */
    create<T extends NotificationCreateArgs>(
      args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>
    ): Prisma__NotificationClient<
      $Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'create'>,
      never,
      ExtArgs
    >;

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends NotificationCreateManyArgs>(
      args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(
      args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'createManyAndReturn'>
    >;

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     *
     */
    delete<T extends NotificationDeleteArgs>(
      args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>
    ): Prisma__NotificationClient<
      $Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'delete'>,
      never,
      ExtArgs
    >;

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends NotificationUpdateArgs>(
      args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>
    ): Prisma__NotificationClient<
      $Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'update'>,
      never,
      ExtArgs
    >;

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends NotificationDeleteManyArgs>(
      args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends NotificationUpdateManyArgs>(
      args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(
      args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>
    ): Prisma__NotificationClient<
      $Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, 'upsert'>,
      never,
      ExtArgs
    >;

    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
     **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends NotificationAggregateArgs>(
      args: Subset<T, NotificationAggregateArgs>
    ): Prisma.PrismaPromise<GetNotificationAggregateType<T>>;

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetNotificationGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Notification model
     */
    readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null,
      Null,
      ExtArgs
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<'Notification', 'String'>;
    readonly userId: FieldRef<'Notification', 'String'>;
    readonly type: FieldRef<'Notification', 'String'>;
    readonly data: FieldRef<'Notification', 'Json'>;
    readonly readAt: FieldRef<'Notification', 'DateTime'>;
    readonly createdAt: FieldRef<'Notification', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput;
  };

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput;
  };

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Notifications.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[];
  };

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Notifications.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[];
  };

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Notifications.
     */
    skip?: number;
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[];
  };

  /**
   * Notification create
   */
  export type NotificationCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>;
  };

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>;
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput;
  };

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>;
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput;
  };

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput;
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>;
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>;
  };

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput;
  };

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput;
  };

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
  };

  /**
   * Model Report
   */

  export type AggregateReport = {
    _count: ReportCountAggregateOutputType | null;
    _min: ReportMinAggregateOutputType | null;
    _max: ReportMaxAggregateOutputType | null;
  };

  export type ReportMinAggregateOutputType = {
    id: string | null;
    reporterId: string | null;
    entityType: string | null;
    entityId: string | null;
    reason: string | null;
    status: $Enums.ReportStatus | null;
    resolution: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type ReportMaxAggregateOutputType = {
    id: string | null;
    reporterId: string | null;
    entityType: string | null;
    entityId: string | null;
    reason: string | null;
    status: $Enums.ReportStatus | null;
    resolution: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type ReportCountAggregateOutputType = {
    id: number;
    reporterId: number;
    entityType: number;
    entityId: number;
    reason: number;
    status: number;
    resolution: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type ReportMinAggregateInputType = {
    id?: true;
    reporterId?: true;
    entityType?: true;
    entityId?: true;
    reason?: true;
    status?: true;
    resolution?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type ReportMaxAggregateInputType = {
    id?: true;
    reporterId?: true;
    entityType?: true;
    entityId?: true;
    reason?: true;
    status?: true;
    resolution?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type ReportCountAggregateInputType = {
    id?: true;
    reporterId?: true;
    entityType?: true;
    entityId?: true;
    reason?: true;
    status?: true;
    resolution?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type ReportAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Report to aggregate.
     */
    where?: ReportWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ReportWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Reports.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Reports
     **/
    _count?: true | ReportCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ReportMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ReportMaxAggregateInputType;
  };

  export type GetReportAggregateType<T extends ReportAggregateArgs> = {
    [P in keyof T & keyof AggregateReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReport[P]>
      : GetScalarType<T[P], AggregateReport[P]>;
  };

  export type ReportGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ReportWhereInput;
    orderBy?: ReportOrderByWithAggregationInput | ReportOrderByWithAggregationInput[];
    by: ReportScalarFieldEnum[] | ReportScalarFieldEnum;
    having?: ReportScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ReportCountAggregateInputType | true;
    _min?: ReportMinAggregateInputType;
    _max?: ReportMaxAggregateInputType;
  };

  export type ReportGroupByOutputType = {
    id: string;
    reporterId: string;
    entityType: string;
    entityId: string;
    reason: string;
    status: $Enums.ReportStatus;
    resolution: string | null;
    createdAt: Date;
    updatedAt: Date;
    _count: ReportCountAggregateOutputType | null;
    _min: ReportMinAggregateOutputType | null;
    _max: ReportMaxAggregateOutputType | null;
  };

  type GetReportGroupByPayload<T extends ReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReportGroupByOutputType, T['by']> & {
        [P in keyof T & keyof ReportGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], ReportGroupByOutputType[P]>
          : GetScalarType<T[P], ReportGroupByOutputType[P]>;
      }
    >
  >;

  export type ReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        reporterId?: boolean;
        entityType?: boolean;
        entityId?: boolean;
        reason?: boolean;
        status?: boolean;
        resolution?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        reporter?: boolean | UserDefaultArgs<ExtArgs>;
      },
      ExtArgs['result']['report']
    >;

  export type ReportSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      reporterId?: boolean;
      entityType?: boolean;
      entityId?: boolean;
      reason?: boolean;
      status?: boolean;
      resolution?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      reporter?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['report']
  >;

  export type ReportSelectScalar = {
    id?: boolean;
    reporterId?: boolean;
    entityType?: boolean;
    entityId?: boolean;
    reason?: boolean;
    status?: boolean;
    resolution?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type ReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reporter?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type ReportIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    reporter?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $ReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: 'Report';
    objects: {
      reporter: Prisma.$UserPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        reporterId: string;
        entityType: string;
        entityId: string;
        reason: string;
        status: $Enums.ReportStatus;
        resolution: string | null;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs['result']['report']
    >;
    composites: {};
  };

  type ReportGetPayload<S extends boolean | null | undefined | ReportDefaultArgs> =
    $Result.GetResult<Prisma.$ReportPayload, S>;

  type ReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    ReportFindManyArgs,
    'select' | 'include' | 'distinct'
  > & {
    select?: ReportCountAggregateInputType | true;
  };

  export interface ReportDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Report']; meta: { name: 'Report' } };
    /**
     * Find zero or one Report that matches the filter.
     * @param {ReportFindUniqueArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReportFindUniqueArgs>(
      args: SelectSubset<T, ReportFindUniqueArgs<ExtArgs>>
    ): Prisma__ReportClient<
      $Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, 'findUnique'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find one Report that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReportFindUniqueOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReportFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ReportFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ReportClient<
      $Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, 'findUniqueOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find the first Report that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindFirstArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReportFindFirstArgs>(
      args?: SelectSubset<T, ReportFindFirstArgs<ExtArgs>>
    ): Prisma__ReportClient<
      $Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, 'findFirst'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find the first Report that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindFirstOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReportFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ReportFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ReportClient<
      $Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, 'findFirstOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more Reports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reports
     * const reports = await prisma.report.findMany()
     *
     * // Get first 10 Reports
     * const reports = await prisma.report.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const reportWithIdOnly = await prisma.report.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ReportFindManyArgs>(
      args?: SelectSubset<T, ReportFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, 'findMany'>>;

    /**
     * Create a Report.
     * @param {ReportCreateArgs} args - Arguments to create a Report.
     * @example
     * // Create one Report
     * const Report = await prisma.report.create({
     *   data: {
     *     // ... data to create a Report
     *   }
     * })
     *
     */
    create<T extends ReportCreateArgs>(
      args: SelectSubset<T, ReportCreateArgs<ExtArgs>>
    ): Prisma__ReportClient<
      $Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, 'create'>,
      never,
      ExtArgs
    >;

    /**
     * Create many Reports.
     * @param {ReportCreateManyArgs} args - Arguments to create many Reports.
     * @example
     * // Create many Reports
     * const report = await prisma.report.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ReportCreateManyArgs>(
      args?: SelectSubset<T, ReportCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Reports and returns the data saved in the database.
     * @param {ReportCreateManyAndReturnArgs} args - Arguments to create many Reports.
     * @example
     * // Create many Reports
     * const report = await prisma.report.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Reports and only return the `id`
     * const reportWithIdOnly = await prisma.report.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends ReportCreateManyAndReturnArgs>(
      args?: SelectSubset<T, ReportCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, 'createManyAndReturn'>
    >;

    /**
     * Delete a Report.
     * @param {ReportDeleteArgs} args - Arguments to delete one Report.
     * @example
     * // Delete one Report
     * const Report = await prisma.report.delete({
     *   where: {
     *     // ... filter to delete one Report
     *   }
     * })
     *
     */
    delete<T extends ReportDeleteArgs>(
      args: SelectSubset<T, ReportDeleteArgs<ExtArgs>>
    ): Prisma__ReportClient<
      $Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, 'delete'>,
      never,
      ExtArgs
    >;

    /**
     * Update one Report.
     * @param {ReportUpdateArgs} args - Arguments to update one Report.
     * @example
     * // Update one Report
     * const report = await prisma.report.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ReportUpdateArgs>(
      args: SelectSubset<T, ReportUpdateArgs<ExtArgs>>
    ): Prisma__ReportClient<
      $Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, 'update'>,
      never,
      ExtArgs
    >;

    /**
     * Delete zero or more Reports.
     * @param {ReportDeleteManyArgs} args - Arguments to filter Reports to delete.
     * @example
     * // Delete a few Reports
     * const { count } = await prisma.report.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ReportDeleteManyArgs>(
      args?: SelectSubset<T, ReportDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reports
     * const report = await prisma.report.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ReportUpdateManyArgs>(
      args: SelectSubset<T, ReportUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Report.
     * @param {ReportUpsertArgs} args - Arguments to update or create a Report.
     * @example
     * // Update or create a Report
     * const report = await prisma.report.upsert({
     *   create: {
     *     // ... data to create a Report
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Report we want to update
     *   }
     * })
     */
    upsert<T extends ReportUpsertArgs>(
      args: SelectSubset<T, ReportUpsertArgs<ExtArgs>>
    ): Prisma__ReportClient<
      $Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, 'upsert'>,
      never,
      ExtArgs
    >;

    /**
     * Count the number of Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportCountArgs} args - Arguments to filter Reports to count.
     * @example
     * // Count the number of Reports
     * const count = await prisma.report.count({
     *   where: {
     *     // ... the filter for the Reports we want to count
     *   }
     * })
     **/
    count<T extends ReportCountArgs>(
      args?: Subset<T, ReportCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ReportAggregateArgs>(
      args: Subset<T, ReportAggregateArgs>
    ): Prisma.PrismaPromise<GetReportAggregateType<T>>;

    /**
     * Group by Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends ReportGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReportGroupByArgs['orderBy'] }
        : { orderBy?: ReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, ReportGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Report model
     */
    readonly fields: ReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Report.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReportClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    reporter<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null,
      Null,
      ExtArgs
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Report model
   */
  interface ReportFieldRefs {
    readonly id: FieldRef<'Report', 'String'>;
    readonly reporterId: FieldRef<'Report', 'String'>;
    readonly entityType: FieldRef<'Report', 'String'>;
    readonly entityId: FieldRef<'Report', 'String'>;
    readonly reason: FieldRef<'Report', 'String'>;
    readonly status: FieldRef<'Report', 'ReportStatus'>;
    readonly resolution: FieldRef<'Report', 'String'>;
    readonly createdAt: FieldRef<'Report', 'DateTime'>;
    readonly updatedAt: FieldRef<'Report', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * Report findUnique
   */
  export type ReportFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null;
    /**
     * Filter, which Report to fetch.
     */
    where: ReportWhereUniqueInput;
  };

  /**
   * Report findUniqueOrThrow
   */
  export type ReportFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null;
    /**
     * Filter, which Report to fetch.
     */
    where: ReportWhereUniqueInput;
  };

  /**
   * Report findFirst
   */
  export type ReportFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null;
    /**
     * Filter, which Report to fetch.
     */
    where?: ReportWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Reports.
     */
    cursor?: ReportWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Reports.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Reports.
     */
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[];
  };

  /**
   * Report findFirstOrThrow
   */
  export type ReportFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null;
    /**
     * Filter, which Report to fetch.
     */
    where?: ReportWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Reports.
     */
    cursor?: ReportWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Reports.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Reports.
     */
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[];
  };

  /**
   * Report findMany
   */
  export type ReportFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null;
    /**
     * Filter, which Reports to fetch.
     */
    where?: ReportWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Reports.
     */
    cursor?: ReportWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Reports.
     */
    skip?: number;
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[];
  };

  /**
   * Report create
   */
  export type ReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the Report
       */
      select?: ReportSelect<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: ReportInclude<ExtArgs> | null;
      /**
       * The data needed to create a Report.
       */
      data: XOR<ReportCreateInput, ReportUncheckedCreateInput>;
    };

  /**
   * Report createMany
   */
  export type ReportCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Reports.
     */
    data: ReportCreateManyInput | ReportCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Report createManyAndReturn
   */
  export type ReportCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * The data used to create many Reports.
     */
    data: ReportCreateManyInput | ReportCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Report update
   */
  export type ReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the Report
       */
      select?: ReportSelect<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: ReportInclude<ExtArgs> | null;
      /**
       * The data needed to update a Report.
       */
      data: XOR<ReportUpdateInput, ReportUncheckedUpdateInput>;
      /**
       * Choose, which Report to update.
       */
      where: ReportWhereUniqueInput;
    };

  /**
   * Report updateMany
   */
  export type ReportUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Reports.
     */
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyInput>;
    /**
     * Filter which Reports to update
     */
    where?: ReportWhereInput;
  };

  /**
   * Report upsert
   */
  export type ReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the Report
       */
      select?: ReportSelect<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: ReportInclude<ExtArgs> | null;
      /**
       * The filter to search for the Report to update in case it exists.
       */
      where: ReportWhereUniqueInput;
      /**
       * In case the Report found by the `where` argument doesn't exist, create a new Report with this data.
       */
      create: XOR<ReportCreateInput, ReportUncheckedCreateInput>;
      /**
       * In case the Report was found with the provided `where` argument, update it with this data.
       */
      update: XOR<ReportUpdateInput, ReportUncheckedUpdateInput>;
    };

  /**
   * Report delete
   */
  export type ReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the Report
       */
      select?: ReportSelect<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: ReportInclude<ExtArgs> | null;
      /**
       * Filter which Report to delete.
       */
      where: ReportWhereUniqueInput;
    };

  /**
   * Report deleteMany
   */
  export type ReportDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Reports to delete
     */
    where?: ReportWhereInput;
  };

  /**
   * Report without action
   */
  export type ReportDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null;
  };

  /**
   * Model File
   */

  export type AggregateFile = {
    _count: FileCountAggregateOutputType | null;
    _avg: FileAvgAggregateOutputType | null;
    _sum: FileSumAggregateOutputType | null;
    _min: FileMinAggregateOutputType | null;
    _max: FileMaxAggregateOutputType | null;
  };

  export type FileAvgAggregateOutputType = {
    size: number | null;
  };

  export type FileSumAggregateOutputType = {
    size: number | null;
  };

  export type FileMinAggregateOutputType = {
    id: string | null;
    filename: string | null;
    mimetype: string | null;
    size: number | null;
    key: string | null;
    url: string | null;
    type: string | null;
    uploadedById: string | null;
    entityId: string | null;
    entityType: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    deletedAt: Date | null;
  };

  export type FileMaxAggregateOutputType = {
    id: string | null;
    filename: string | null;
    mimetype: string | null;
    size: number | null;
    key: string | null;
    url: string | null;
    type: string | null;
    uploadedById: string | null;
    entityId: string | null;
    entityType: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    deletedAt: Date | null;
  };

  export type FileCountAggregateOutputType = {
    id: number;
    filename: number;
    mimetype: number;
    size: number;
    key: number;
    url: number;
    type: number;
    uploadedById: number;
    entityId: number;
    entityType: number;
    createdAt: number;
    updatedAt: number;
    deletedAt: number;
    _all: number;
  };

  export type FileAvgAggregateInputType = {
    size?: true;
  };

  export type FileSumAggregateInputType = {
    size?: true;
  };

  export type FileMinAggregateInputType = {
    id?: true;
    filename?: true;
    mimetype?: true;
    size?: true;
    key?: true;
    url?: true;
    type?: true;
    uploadedById?: true;
    entityId?: true;
    entityType?: true;
    createdAt?: true;
    updatedAt?: true;
    deletedAt?: true;
  };

  export type FileMaxAggregateInputType = {
    id?: true;
    filename?: true;
    mimetype?: true;
    size?: true;
    key?: true;
    url?: true;
    type?: true;
    uploadedById?: true;
    entityId?: true;
    entityType?: true;
    createdAt?: true;
    updatedAt?: true;
    deletedAt?: true;
  };

  export type FileCountAggregateInputType = {
    id?: true;
    filename?: true;
    mimetype?: true;
    size?: true;
    key?: true;
    url?: true;
    type?: true;
    uploadedById?: true;
    entityId?: true;
    entityType?: true;
    createdAt?: true;
    updatedAt?: true;
    deletedAt?: true;
    _all?: true;
  };

  export type FileAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which File to aggregate.
     */
    where?: FileWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Files to fetch.
     */
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: FileWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Files from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Files.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Files
     **/
    _count?: true | FileCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: FileAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: FileSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: FileMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: FileMaxAggregateInputType;
  };

  export type GetFileAggregateType<T extends FileAggregateArgs> = {
    [P in keyof T & keyof AggregateFile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFile[P]>
      : GetScalarType<T[P], AggregateFile[P]>;
  };

  export type FileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      where?: FileWhereInput;
      orderBy?: FileOrderByWithAggregationInput | FileOrderByWithAggregationInput[];
      by: FileScalarFieldEnum[] | FileScalarFieldEnum;
      having?: FileScalarWhereWithAggregatesInput;
      take?: number;
      skip?: number;
      _count?: FileCountAggregateInputType | true;
      _avg?: FileAvgAggregateInputType;
      _sum?: FileSumAggregateInputType;
      _min?: FileMinAggregateInputType;
      _max?: FileMaxAggregateInputType;
    };

  export type FileGroupByOutputType = {
    id: string;
    filename: string;
    mimetype: string;
    size: number;
    key: string;
    url: string;
    type: string;
    uploadedById: string;
    entityId: string | null;
    entityType: string | null;
    createdAt: Date;
    updatedAt: Date;
    deletedAt: Date | null;
    _count: FileCountAggregateOutputType | null;
    _avg: FileAvgAggregateOutputType | null;
    _sum: FileSumAggregateOutputType | null;
    _min: FileMinAggregateOutputType | null;
    _max: FileMaxAggregateOutputType | null;
  };

  type GetFileGroupByPayload<T extends FileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FileGroupByOutputType, T['by']> & {
        [P in keyof T & keyof FileGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], FileGroupByOutputType[P]>
          : GetScalarType<T[P], FileGroupByOutputType[P]>;
      }
    >
  >;

  export type FileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        filename?: boolean;
        mimetype?: boolean;
        size?: boolean;
        key?: boolean;
        url?: boolean;
        type?: boolean;
        uploadedById?: boolean;
        entityId?: boolean;
        entityType?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        deletedAt?: boolean;
        uploadedBy?: boolean | UserDefaultArgs<ExtArgs>;
      },
      ExtArgs['result']['file']
    >;

  export type FileSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      filename?: boolean;
      mimetype?: boolean;
      size?: boolean;
      key?: boolean;
      url?: boolean;
      type?: boolean;
      uploadedById?: boolean;
      entityId?: boolean;
      entityType?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      deletedAt?: boolean;
      uploadedBy?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['file']
  >;

  export type FileSelectScalar = {
    id?: boolean;
    filename?: boolean;
    mimetype?: boolean;
    size?: boolean;
    key?: boolean;
    url?: boolean;
    type?: boolean;
    uploadedById?: boolean;
    entityId?: boolean;
    entityType?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    deletedAt?: boolean;
  };

  export type FileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type FileIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $FilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: 'File';
    objects: {
      uploadedBy: Prisma.$UserPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        filename: string;
        mimetype: string;
        size: number;
        key: string;
        url: string;
        type: string;
        uploadedById: string;
        entityId: string | null;
        entityType: string | null;
        createdAt: Date;
        updatedAt: Date;
        deletedAt: Date | null;
      },
      ExtArgs['result']['file']
    >;
    composites: {};
  };

  type FileGetPayload<S extends boolean | null | undefined | FileDefaultArgs> = $Result.GetResult<
    Prisma.$FilePayload,
    S
  >;

  type FileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    FileFindManyArgs,
    'select' | 'include' | 'distinct'
  > & {
    select?: FileCountAggregateInputType | true;
  };

  export interface FileDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['File']; meta: { name: 'File' } };
    /**
     * Find zero or one File that matches the filter.
     * @param {FileFindUniqueArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FileFindUniqueArgs>(
      args: SelectSubset<T, FileFindUniqueArgs<ExtArgs>>
    ): Prisma__FileClient<
      $Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, 'findUnique'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find one File that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FileFindUniqueOrThrowArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FileFindUniqueOrThrowArgs>(
      args: SelectSubset<T, FileFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__FileClient<
      $Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, 'findUniqueOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find the first File that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileFindFirstArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FileFindFirstArgs>(
      args?: SelectSubset<T, FileFindFirstArgs<ExtArgs>>
    ): Prisma__FileClient<
      $Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, 'findFirst'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find the first File that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileFindFirstOrThrowArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FileFindFirstOrThrowArgs>(
      args?: SelectSubset<T, FileFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__FileClient<
      $Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, 'findFirstOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more Files that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Files
     * const files = await prisma.file.findMany()
     *
     * // Get first 10 Files
     * const files = await prisma.file.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const fileWithIdOnly = await prisma.file.findMany({ select: { id: true } })
     *
     */
    findMany<T extends FileFindManyArgs>(
      args?: SelectSubset<T, FileFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, 'findMany'>>;

    /**
     * Create a File.
     * @param {FileCreateArgs} args - Arguments to create a File.
     * @example
     * // Create one File
     * const File = await prisma.file.create({
     *   data: {
     *     // ... data to create a File
     *   }
     * })
     *
     */
    create<T extends FileCreateArgs>(
      args: SelectSubset<T, FileCreateArgs<ExtArgs>>
    ): Prisma__FileClient<
      $Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, 'create'>,
      never,
      ExtArgs
    >;

    /**
     * Create many Files.
     * @param {FileCreateManyArgs} args - Arguments to create many Files.
     * @example
     * // Create many Files
     * const file = await prisma.file.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends FileCreateManyArgs>(
      args?: SelectSubset<T, FileCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Files and returns the data saved in the database.
     * @param {FileCreateManyAndReturnArgs} args - Arguments to create many Files.
     * @example
     * // Create many Files
     * const file = await prisma.file.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Files and only return the `id`
     * const fileWithIdOnly = await prisma.file.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends FileCreateManyAndReturnArgs>(
      args?: SelectSubset<T, FileCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, 'createManyAndReturn'>
    >;

    /**
     * Delete a File.
     * @param {FileDeleteArgs} args - Arguments to delete one File.
     * @example
     * // Delete one File
     * const File = await prisma.file.delete({
     *   where: {
     *     // ... filter to delete one File
     *   }
     * })
     *
     */
    delete<T extends FileDeleteArgs>(
      args: SelectSubset<T, FileDeleteArgs<ExtArgs>>
    ): Prisma__FileClient<
      $Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, 'delete'>,
      never,
      ExtArgs
    >;

    /**
     * Update one File.
     * @param {FileUpdateArgs} args - Arguments to update one File.
     * @example
     * // Update one File
     * const file = await prisma.file.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends FileUpdateArgs>(
      args: SelectSubset<T, FileUpdateArgs<ExtArgs>>
    ): Prisma__FileClient<
      $Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, 'update'>,
      never,
      ExtArgs
    >;

    /**
     * Delete zero or more Files.
     * @param {FileDeleteManyArgs} args - Arguments to filter Files to delete.
     * @example
     * // Delete a few Files
     * const { count } = await prisma.file.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends FileDeleteManyArgs>(
      args?: SelectSubset<T, FileDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Files
     * const file = await prisma.file.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends FileUpdateManyArgs>(
      args: SelectSubset<T, FileUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one File.
     * @param {FileUpsertArgs} args - Arguments to update or create a File.
     * @example
     * // Update or create a File
     * const file = await prisma.file.upsert({
     *   create: {
     *     // ... data to create a File
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the File we want to update
     *   }
     * })
     */
    upsert<T extends FileUpsertArgs>(
      args: SelectSubset<T, FileUpsertArgs<ExtArgs>>
    ): Prisma__FileClient<
      $Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, 'upsert'>,
      never,
      ExtArgs
    >;

    /**
     * Count the number of Files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileCountArgs} args - Arguments to filter Files to count.
     * @example
     * // Count the number of Files
     * const count = await prisma.file.count({
     *   where: {
     *     // ... the filter for the Files we want to count
     *   }
     * })
     **/
    count<T extends FileCountArgs>(
      args?: Subset<T, FileCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FileCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a File.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends FileAggregateArgs>(
      args: Subset<T, FileAggregateArgs>
    ): Prisma.PrismaPromise<GetFileAggregateType<T>>;

    /**
     * Group by File.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends FileGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FileGroupByArgs['orderBy'] }
        : { orderBy?: FileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, FileGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetFileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the File model
     */
    readonly fields: FileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for File.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FileClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    uploadedBy<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null,
      Null,
      ExtArgs
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the File model
   */
  interface FileFieldRefs {
    readonly id: FieldRef<'File', 'String'>;
    readonly filename: FieldRef<'File', 'String'>;
    readonly mimetype: FieldRef<'File', 'String'>;
    readonly size: FieldRef<'File', 'Int'>;
    readonly key: FieldRef<'File', 'String'>;
    readonly url: FieldRef<'File', 'String'>;
    readonly type: FieldRef<'File', 'String'>;
    readonly uploadedById: FieldRef<'File', 'String'>;
    readonly entityId: FieldRef<'File', 'String'>;
    readonly entityType: FieldRef<'File', 'String'>;
    readonly createdAt: FieldRef<'File', 'DateTime'>;
    readonly updatedAt: FieldRef<'File', 'DateTime'>;
    readonly deletedAt: FieldRef<'File', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * File findUnique
   */
  export type FileFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null;
    /**
     * Filter, which File to fetch.
     */
    where: FileWhereUniqueInput;
  };

  /**
   * File findUniqueOrThrow
   */
  export type FileFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null;
    /**
     * Filter, which File to fetch.
     */
    where: FileWhereUniqueInput;
  };

  /**
   * File findFirst
   */
  export type FileFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null;
    /**
     * Filter, which File to fetch.
     */
    where?: FileWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Files to fetch.
     */
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Files.
     */
    cursor?: FileWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Files from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Files.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Files.
     */
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[];
  };

  /**
   * File findFirstOrThrow
   */
  export type FileFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null;
    /**
     * Filter, which File to fetch.
     */
    where?: FileWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Files to fetch.
     */
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Files.
     */
    cursor?: FileWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Files from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Files.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Files.
     */
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[];
  };

  /**
   * File findMany
   */
  export type FileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the File
       */
      select?: FileSelect<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: FileInclude<ExtArgs> | null;
      /**
       * Filter, which Files to fetch.
       */
      where?: FileWhereInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
       *
       * Determine the order of Files to fetch.
       */
      orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[];
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
       *
       * Sets the position for listing Files.
       */
      cursor?: FileWhereUniqueInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Take `±n` Files from the position of the cursor.
       */
      take?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Skip the first `n` Files.
       */
      skip?: number;
      distinct?: FileScalarFieldEnum | FileScalarFieldEnum[];
    };

  /**
   * File create
   */
  export type FileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null;
    /**
     * The data needed to create a File.
     */
    data: XOR<FileCreateInput, FileUncheckedCreateInput>;
  };

  /**
   * File createMany
   */
  export type FileCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Files.
     */
    data: FileCreateManyInput | FileCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * File createManyAndReturn
   */
  export type FileCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * The data used to create many Files.
     */
    data: FileCreateManyInput | FileCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * File update
   */
  export type FileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null;
    /**
     * The data needed to update a File.
     */
    data: XOR<FileUpdateInput, FileUncheckedUpdateInput>;
    /**
     * Choose, which File to update.
     */
    where: FileWhereUniqueInput;
  };

  /**
   * File updateMany
   */
  export type FileUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Files.
     */
    data: XOR<FileUpdateManyMutationInput, FileUncheckedUpdateManyInput>;
    /**
     * Filter which Files to update
     */
    where?: FileWhereInput;
  };

  /**
   * File upsert
   */
  export type FileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null;
    /**
     * The filter to search for the File to update in case it exists.
     */
    where: FileWhereUniqueInput;
    /**
     * In case the File found by the `where` argument doesn't exist, create a new File with this data.
     */
    create: XOR<FileCreateInput, FileUncheckedCreateInput>;
    /**
     * In case the File was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FileUpdateInput, FileUncheckedUpdateInput>;
  };

  /**
   * File delete
   */
  export type FileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null;
    /**
     * Filter which File to delete.
     */
    where: FileWhereUniqueInput;
  };

  /**
   * File deleteMany
   */
  export type FileDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Files to delete
     */
    where?: FileWhereInput;
  };

  /**
   * File without action
   */
  export type FileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the File
       */
      select?: FileSelect<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: FileInclude<ExtArgs> | null;
    };

  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted';
    ReadCommitted: 'ReadCommitted';
    RepeatableRead: 'RepeatableRead';
    Serializable: 'Serializable';
  };

  export type TransactionIsolationLevel =
    (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel];

  export const UserScalarFieldEnum: {
    id: 'id';
    email: 'email';
    emailVerified: 'emailVerified';
    name: 'name';
    handle: 'handle';
    avatarUrl: 'avatarUrl';
    bio: 'bio';
    organization: 'organization';
    password: 'password';
    roles: 'roles';
    totpSecret: 'totpSecret';
    totpEnabled: 'totpEnabled';
    passwordResetToken: 'passwordResetToken';
    passwordResetExpires: 'passwordResetExpires';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
    lastLoginAt: 'lastLoginAt';
    isActive: 'isActive';
    isBanned: 'isBanned';
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum];

  export const AccountScalarFieldEnum: {
    id: 'id';
    userId: 'userId';
    type: 'type';
    provider: 'provider';
    providerAccountId: 'providerAccountId';
    refresh_token: 'refresh_token';
    access_token: 'access_token';
    expires_at: 'expires_at';
    token_type: 'token_type';
    scope: 'scope';
    id_token: 'id_token';
    session_state: 'session_state';
  };

  export type AccountScalarFieldEnum =
    (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum];

  export const SessionScalarFieldEnum: {
    id: 'id';
    sessionToken: 'sessionToken';
    userId: 'userId';
    expires: 'expires';
  };

  export type SessionScalarFieldEnum =
    (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum];

  export const VerificationTokenScalarFieldEnum: {
    identifier: 'identifier';
    token: 'token';
    expires: 'expires';
  };

  export type VerificationTokenScalarFieldEnum =
    (typeof VerificationTokenScalarFieldEnum)[keyof typeof VerificationTokenScalarFieldEnum];

  export const ApiKeyScalarFieldEnum: {
    id: 'id';
    userId: 'userId';
    name: 'name';
    hashedKey: 'hashedKey';
    scopes: 'scopes';
    lastUsedAt: 'lastUsedAt';
    expiresAt: 'expiresAt';
    createdAt: 'createdAt';
    isActive: 'isActive';
  };

  export type ApiKeyScalarFieldEnum =
    (typeof ApiKeyScalarFieldEnum)[keyof typeof ApiKeyScalarFieldEnum];

  export const AuditLogScalarFieldEnum: {
    id: 'id';
    actorId: 'actorId';
    action: 'action';
    entityType: 'entityType';
    entityId: 'entityId';
    metadata: 'metadata';
    ipAddress: 'ipAddress';
    userAgent: 'userAgent';
    createdAt: 'createdAt';
  };

  export type AuditLogScalarFieldEnum =
    (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum];

  export const HackathonScalarFieldEnum: {
    id: 'id';
    slug: 'slug';
    title: 'title';
    description: 'description';
    coverImage: 'coverImage';
    status: 'status';
    location: 'location';
    registrationOpensAt: 'registrationOpensAt';
    registrationClosesAt: 'registrationClosesAt';
    startsAt: 'startsAt';
    endsAt: 'endsAt';
    judgingEndsAt: 'judgingEndsAt';
    prizePool: 'prizePool';
    maxTeamSize: 'maxTeamSize';
    allowSoloTeams: 'allowSoloTeams';
    rules: 'rules';
    schedule: 'schedule';
    metadata: 'metadata';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
  };

  export type HackathonScalarFieldEnum =
    (typeof HackathonScalarFieldEnum)[keyof typeof HackathonScalarFieldEnum];

  export const TrackScalarFieldEnum: {
    id: 'id';
    hackathonId: 'hackathonId';
    title: 'title';
    description: 'description';
    order: 'order';
    createdAt: 'createdAt';
  };

  export type TrackScalarFieldEnum =
    (typeof TrackScalarFieldEnum)[keyof typeof TrackScalarFieldEnum];

  export const TeamScalarFieldEnum: {
    id: 'id';
    hackathonId: 'hackathonId';
    name: 'name';
    bio: 'bio';
    logoUrl: 'logoUrl';
    repoUrl: 'repoUrl';
    demoUrl: 'demoUrl';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
  };

  export type TeamScalarFieldEnum = (typeof TeamScalarFieldEnum)[keyof typeof TeamScalarFieldEnum];

  export const TeamMemberScalarFieldEnum: {
    teamId: 'teamId';
    userId: 'userId';
    role: 'role';
    joinedAt: 'joinedAt';
  };

  export type TeamMemberScalarFieldEnum =
    (typeof TeamMemberScalarFieldEnum)[keyof typeof TeamMemberScalarFieldEnum];

  export const MentorScalarFieldEnum: {
    id: 'id';
    userId: 'userId';
    hackathonId: 'hackathonId';
    bio: 'bio';
    calendlyUrl: 'calendlyUrl';
    expertise: 'expertise';
    createdAt: 'createdAt';
  };

  export type MentorScalarFieldEnum =
    (typeof MentorScalarFieldEnum)[keyof typeof MentorScalarFieldEnum];

  export const MentorSessionScalarFieldEnum: {
    id: 'id';
    mentorId: 'mentorId';
    title: 'title';
    startsAt: 'startsAt';
    endsAt: 'endsAt';
    capacity: 'capacity';
    booked: 'booked';
    meetingUrl: 'meetingUrl';
    createdAt: 'createdAt';
  };

  export type MentorSessionScalarFieldEnum =
    (typeof MentorSessionScalarFieldEnum)[keyof typeof MentorSessionScalarFieldEnum];

  export const JudgeScalarFieldEnum: {
    id: 'id';
    userId: 'userId';
    hackathonId: 'hackathonId';
    bio: 'bio';
    createdAt: 'createdAt';
  };

  export type JudgeScalarFieldEnum =
    (typeof JudgeScalarFieldEnum)[keyof typeof JudgeScalarFieldEnum];

  export const CriteriaScalarFieldEnum: {
    id: 'id';
    hackathonId: 'hackathonId';
    name: 'name';
    description: 'description';
    maxScore: 'maxScore';
    weight: 'weight';
    order: 'order';
  };

  export type CriteriaScalarFieldEnum =
    (typeof CriteriaScalarFieldEnum)[keyof typeof CriteriaScalarFieldEnum];

  export const SubmissionScalarFieldEnum: {
    id: 'id';
    hackathonId: 'hackathonId';
    teamId: 'teamId';
    trackId: 'trackId';
    title: 'title';
    abstract: 'abstract';
    repoUrl: 'repoUrl';
    demoUrl: 'demoUrl';
    videoUrl: 'videoUrl';
    files: 'files';
    submittedAt: 'submittedAt';
    finalizedAt: 'finalizedAt';
    status: 'status';
    scoreAggregate: 'scoreAggregate';
    rank: 'rank';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
  };

  export type SubmissionScalarFieldEnum =
    (typeof SubmissionScalarFieldEnum)[keyof typeof SubmissionScalarFieldEnum];

  export const ScoreScalarFieldEnum: {
    id: 'id';
    submissionId: 'submissionId';
    judgeId: 'judgeId';
    criterionId: 'criterionId';
    score: 'score';
    feedback: 'feedback';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
  };

  export type ScoreScalarFieldEnum =
    (typeof ScoreScalarFieldEnum)[keyof typeof ScoreScalarFieldEnum];

  export const ChallengeScalarFieldEnum: {
    id: 'id';
    slug: 'slug';
    title: 'title';
    problemStatement: 'problemStatement';
    ownerId: 'ownerId';
    ownerOrg: 'ownerOrg';
    rewardType: 'rewardType';
    rewardValue: 'rewardValue';
    categories: 'categories';
    skills: 'skills';
    attachments: 'attachments';
    status: 'status';
    visibility: 'visibility';
    deadlineAt: 'deadlineAt';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
  };

  export type ChallengeScalarFieldEnum =
    (typeof ChallengeScalarFieldEnum)[keyof typeof ChallengeScalarFieldEnum];

  export const ChallengeSubmissionScalarFieldEnum: {
    id: 'id';
    challengeId: 'challengeId';
    userId: 'userId';
    teamId: 'teamId';
    title: 'title';
    repoUrl: 'repoUrl';
    content: 'content';
    files: 'files';
    status: 'status';
    score: 'score';
    feedback: 'feedback';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
  };

  export type ChallengeSubmissionScalarFieldEnum =
    (typeof ChallengeSubmissionScalarFieldEnum)[keyof typeof ChallengeSubmissionScalarFieldEnum];

  export const AnnouncementScalarFieldEnum: {
    id: 'id';
    scope: 'scope';
    scopeId: 'scopeId';
    title: 'title';
    body: 'body';
    pinned: 'pinned';
    publishedAt: 'publishedAt';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
  };

  export type AnnouncementScalarFieldEnum =
    (typeof AnnouncementScalarFieldEnum)[keyof typeof AnnouncementScalarFieldEnum];

  export const CommentThreadScalarFieldEnum: {
    id: 'id';
    entityType: 'entityType';
    entityId: 'entityId';
    createdAt: 'createdAt';
  };

  export type CommentThreadScalarFieldEnum =
    (typeof CommentThreadScalarFieldEnum)[keyof typeof CommentThreadScalarFieldEnum];

  export const CommentScalarFieldEnum: {
    id: 'id';
    threadId: 'threadId';
    authorId: 'authorId';
    parentId: 'parentId';
    body: 'body';
    isFlagged: 'isFlagged';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
  };

  export type CommentScalarFieldEnum =
    (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum];

  export const GamificationProfileScalarFieldEnum: {
    userId: 'userId';
    xp: 'xp';
    level: 'level';
    streakDays: 'streakDays';
    vaultKeys: 'vaultKeys';
    badges: 'badges';
    lastActivityAt: 'lastActivityAt';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
  };

  export type GamificationProfileScalarFieldEnum =
    (typeof GamificationProfileScalarFieldEnum)[keyof typeof GamificationProfileScalarFieldEnum];

  export const BadgeScalarFieldEnum: {
    id: 'id';
    slug: 'slug';
    name: 'name';
    description: 'description';
    icon: 'icon';
    xpRequired: 'xpRequired';
    rarity: 'rarity';
    createdAt: 'createdAt';
  };

  export type BadgeScalarFieldEnum =
    (typeof BadgeScalarFieldEnum)[keyof typeof BadgeScalarFieldEnum];

  export const XpEventScalarFieldEnum: {
    id: 'id';
    userId: 'userId';
    eventType: 'eventType';
    points: 'points';
    refType: 'refType';
    refId: 'refId';
    metadata: 'metadata';
    createdAt: 'createdAt';
  };

  export type XpEventScalarFieldEnum =
    (typeof XpEventScalarFieldEnum)[keyof typeof XpEventScalarFieldEnum];

  export const LeaderboardSnapshotScalarFieldEnum: {
    id: 'id';
    scope: 'scope';
    scopeId: 'scopeId';
    period: 'period';
    data: 'data';
    createdAt: 'createdAt';
  };

  export type LeaderboardSnapshotScalarFieldEnum =
    (typeof LeaderboardSnapshotScalarFieldEnum)[keyof typeof LeaderboardSnapshotScalarFieldEnum];

  export const NotificationScalarFieldEnum: {
    id: 'id';
    userId: 'userId';
    type: 'type';
    data: 'data';
    readAt: 'readAt';
    createdAt: 'createdAt';
  };

  export type NotificationScalarFieldEnum =
    (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum];

  export const ReportScalarFieldEnum: {
    id: 'id';
    reporterId: 'reporterId';
    entityType: 'entityType';
    entityId: 'entityId';
    reason: 'reason';
    status: 'status';
    resolution: 'resolution';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
  };

  export type ReportScalarFieldEnum =
    (typeof ReportScalarFieldEnum)[keyof typeof ReportScalarFieldEnum];

  export const FileScalarFieldEnum: {
    id: 'id';
    filename: 'filename';
    mimetype: 'mimetype';
    size: 'size';
    key: 'key';
    url: 'url';
    type: 'type';
    uploadedById: 'uploadedById';
    entityId: 'entityId';
    entityType: 'entityType';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
    deletedAt: 'deletedAt';
  };

  export type FileScalarFieldEnum = (typeof FileScalarFieldEnum)[keyof typeof FileScalarFieldEnum];

  export const SortOrder: {
    asc: 'asc';
    desc: 'desc';
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder];

  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull;
    JsonNull: typeof JsonNull;
  };

  export type NullableJsonNullValueInput =
    (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput];

  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull;
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput];

  export const QueryMode: {
    default: 'default';
    insensitive: 'insensitive';
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode];

  export const NullsOrder: {
    first: 'first';
    last: 'last';
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder];

  export const JsonNullValueFilter: {
    DbNull: typeof DbNull;
    JsonNull: typeof JsonNull;
    AnyNull: typeof AnyNull;
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter];

  /**
   * Field references
   */

  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>;

  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>;

  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>;

  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'DateTime[]'
  >;

  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>;

  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>;

  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>;

  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>;

  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>;

  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>;

  /**
   * Reference to a field of type 'HackathonStatus'
   */
  export type EnumHackathonStatusFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'HackathonStatus'
  >;

  /**
   * Reference to a field of type 'HackathonStatus[]'
   */
  export type ListEnumHackathonStatusFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'HackathonStatus[]'
  >;

  /**
   * Reference to a field of type 'HackathonLocation'
   */
  export type EnumHackathonLocationFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'HackathonLocation'
  >;

  /**
   * Reference to a field of type 'HackathonLocation[]'
   */
  export type ListEnumHackathonLocationFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'HackathonLocation[]'
  >;

  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>;

  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>;

  /**
   * Reference to a field of type 'TeamMemberRole'
   */
  export type EnumTeamMemberRoleFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'TeamMemberRole'
  >;

  /**
   * Reference to a field of type 'TeamMemberRole[]'
   */
  export type ListEnumTeamMemberRoleFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'TeamMemberRole[]'
  >;

  /**
   * Reference to a field of type 'SubmissionStatus'
   */
  export type EnumSubmissionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'SubmissionStatus'
  >;

  /**
   * Reference to a field of type 'SubmissionStatus[]'
   */
  export type ListEnumSubmissionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'SubmissionStatus[]'
  >;

  /**
   * Reference to a field of type 'RewardType'
   */
  export type EnumRewardTypeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'RewardType'
  >;

  /**
   * Reference to a field of type 'RewardType[]'
   */
  export type ListEnumRewardTypeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'RewardType[]'
  >;

  /**
   * Reference to a field of type 'ChallengeStatus'
   */
  export type EnumChallengeStatusFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'ChallengeStatus'
  >;

  /**
   * Reference to a field of type 'ChallengeStatus[]'
   */
  export type ListEnumChallengeStatusFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'ChallengeStatus[]'
  >;

  /**
   * Reference to a field of type 'ChallengeVisibility'
   */
  export type EnumChallengeVisibilityFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'ChallengeVisibility'
  >;

  /**
   * Reference to a field of type 'ChallengeVisibility[]'
   */
  export type ListEnumChallengeVisibilityFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'ChallengeVisibility[]'
  >;

  /**
   * Reference to a field of type 'ChallengeSubmissionStatus'
   */
  export type EnumChallengeSubmissionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'ChallengeSubmissionStatus'
  >;

  /**
   * Reference to a field of type 'ChallengeSubmissionStatus[]'
   */
  export type ListEnumChallengeSubmissionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'ChallengeSubmissionStatus[]'
  >;

  /**
   * Reference to a field of type 'AnnouncementScope'
   */
  export type EnumAnnouncementScopeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'AnnouncementScope'
  >;

  /**
   * Reference to a field of type 'AnnouncementScope[]'
   */
  export type ListEnumAnnouncementScopeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'AnnouncementScope[]'
  >;

  /**
   * Reference to a field of type 'CommentEntityType'
   */
  export type EnumCommentEntityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'CommentEntityType'
  >;

  /**
   * Reference to a field of type 'CommentEntityType[]'
   */
  export type ListEnumCommentEntityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'CommentEntityType[]'
  >;

  /**
   * Reference to a field of type 'LeaderboardScope'
   */
  export type EnumLeaderboardScopeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'LeaderboardScope'
  >;

  /**
   * Reference to a field of type 'LeaderboardScope[]'
   */
  export type ListEnumLeaderboardScopeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'LeaderboardScope[]'
  >;

  /**
   * Reference to a field of type 'LeaderboardPeriod'
   */
  export type EnumLeaderboardPeriodFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'LeaderboardPeriod'
  >;

  /**
   * Reference to a field of type 'LeaderboardPeriod[]'
   */
  export type ListEnumLeaderboardPeriodFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'LeaderboardPeriod[]'
  >;

  /**
   * Reference to a field of type 'ReportStatus'
   */
  export type EnumReportStatusFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'ReportStatus'
  >;

  /**
   * Reference to a field of type 'ReportStatus[]'
   */
  export type ListEnumReportStatusFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'ReportStatus[]'
  >;

  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>;

  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>;

  /**
   * Deep Input Types
   */

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[];
    OR?: UserWhereInput[];
    NOT?: UserWhereInput | UserWhereInput[];
    id?: StringFilter<'User'> | string;
    email?: StringFilter<'User'> | string;
    emailVerified?: DateTimeNullableFilter<'User'> | Date | string | null;
    name?: StringNullableFilter<'User'> | string | null;
    handle?: StringNullableFilter<'User'> | string | null;
    avatarUrl?: StringNullableFilter<'User'> | string | null;
    bio?: StringNullableFilter<'User'> | string | null;
    organization?: StringNullableFilter<'User'> | string | null;
    password?: StringNullableFilter<'User'> | string | null;
    roles?: EnumRoleNullableListFilter<'User'>;
    totpSecret?: StringNullableFilter<'User'> | string | null;
    totpEnabled?: BoolFilter<'User'> | boolean;
    passwordResetToken?: StringNullableFilter<'User'> | string | null;
    passwordResetExpires?: DateTimeNullableFilter<'User'> | Date | string | null;
    createdAt?: DateTimeFilter<'User'> | Date | string;
    updatedAt?: DateTimeFilter<'User'> | Date | string;
    lastLoginAt?: DateTimeNullableFilter<'User'> | Date | string | null;
    isActive?: BoolFilter<'User'> | boolean;
    isBanned?: BoolFilter<'User'> | boolean;
    accounts?: AccountListRelationFilter;
    sessions?: SessionListRelationFilter;
    apiKeys?: ApiKeyListRelationFilter;
    auditLogs?: AuditLogListRelationFilter;
    teamMemberships?: TeamMemberListRelationFilter;
    mentorProfiles?: MentorListRelationFilter;
    judgeAssignments?: JudgeListRelationFilter;
    challengeSubmissions?: ChallengeSubmissionListRelationFilter;
    comments?: CommentListRelationFilter;
    gamificationProfile?: XOR<
      GamificationProfileNullableRelationFilter,
      GamificationProfileWhereInput
    > | null;
    xpEvents?: XpEventListRelationFilter;
    notifications?: NotificationListRelationFilter;
    reports?: ReportListRelationFilter;
    uploadedFiles?: FileListRelationFilter;
    ownedChallenges?: ChallengeListRelationFilter;
  };

  export type UserOrderByWithRelationInput = {
    id?: SortOrder;
    email?: SortOrder;
    emailVerified?: SortOrderInput | SortOrder;
    name?: SortOrderInput | SortOrder;
    handle?: SortOrderInput | SortOrder;
    avatarUrl?: SortOrderInput | SortOrder;
    bio?: SortOrderInput | SortOrder;
    organization?: SortOrderInput | SortOrder;
    password?: SortOrderInput | SortOrder;
    roles?: SortOrder;
    totpSecret?: SortOrderInput | SortOrder;
    totpEnabled?: SortOrder;
    passwordResetToken?: SortOrderInput | SortOrder;
    passwordResetExpires?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    lastLoginAt?: SortOrderInput | SortOrder;
    isActive?: SortOrder;
    isBanned?: SortOrder;
    accounts?: AccountOrderByRelationAggregateInput;
    sessions?: SessionOrderByRelationAggregateInput;
    apiKeys?: ApiKeyOrderByRelationAggregateInput;
    auditLogs?: AuditLogOrderByRelationAggregateInput;
    teamMemberships?: TeamMemberOrderByRelationAggregateInput;
    mentorProfiles?: MentorOrderByRelationAggregateInput;
    judgeAssignments?: JudgeOrderByRelationAggregateInput;
    challengeSubmissions?: ChallengeSubmissionOrderByRelationAggregateInput;
    comments?: CommentOrderByRelationAggregateInput;
    gamificationProfile?: GamificationProfileOrderByWithRelationInput;
    xpEvents?: XpEventOrderByRelationAggregateInput;
    notifications?: NotificationOrderByRelationAggregateInput;
    reports?: ReportOrderByRelationAggregateInput;
    uploadedFiles?: FileOrderByRelationAggregateInput;
    ownedChallenges?: ChallengeOrderByRelationAggregateInput;
  };

  export type UserWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      email?: string;
      handle?: string;
      AND?: UserWhereInput | UserWhereInput[];
      OR?: UserWhereInput[];
      NOT?: UserWhereInput | UserWhereInput[];
      emailVerified?: DateTimeNullableFilter<'User'> | Date | string | null;
      name?: StringNullableFilter<'User'> | string | null;
      avatarUrl?: StringNullableFilter<'User'> | string | null;
      bio?: StringNullableFilter<'User'> | string | null;
      organization?: StringNullableFilter<'User'> | string | null;
      password?: StringNullableFilter<'User'> | string | null;
      roles?: EnumRoleNullableListFilter<'User'>;
      totpSecret?: StringNullableFilter<'User'> | string | null;
      totpEnabled?: BoolFilter<'User'> | boolean;
      passwordResetToken?: StringNullableFilter<'User'> | string | null;
      passwordResetExpires?: DateTimeNullableFilter<'User'> | Date | string | null;
      createdAt?: DateTimeFilter<'User'> | Date | string;
      updatedAt?: DateTimeFilter<'User'> | Date | string;
      lastLoginAt?: DateTimeNullableFilter<'User'> | Date | string | null;
      isActive?: BoolFilter<'User'> | boolean;
      isBanned?: BoolFilter<'User'> | boolean;
      accounts?: AccountListRelationFilter;
      sessions?: SessionListRelationFilter;
      apiKeys?: ApiKeyListRelationFilter;
      auditLogs?: AuditLogListRelationFilter;
      teamMemberships?: TeamMemberListRelationFilter;
      mentorProfiles?: MentorListRelationFilter;
      judgeAssignments?: JudgeListRelationFilter;
      challengeSubmissions?: ChallengeSubmissionListRelationFilter;
      comments?: CommentListRelationFilter;
      gamificationProfile?: XOR<
        GamificationProfileNullableRelationFilter,
        GamificationProfileWhereInput
      > | null;
      xpEvents?: XpEventListRelationFilter;
      notifications?: NotificationListRelationFilter;
      reports?: ReportListRelationFilter;
      uploadedFiles?: FileListRelationFilter;
      ownedChallenges?: ChallengeListRelationFilter;
    },
    'id' | 'email' | 'handle'
  >;

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder;
    email?: SortOrder;
    emailVerified?: SortOrderInput | SortOrder;
    name?: SortOrderInput | SortOrder;
    handle?: SortOrderInput | SortOrder;
    avatarUrl?: SortOrderInput | SortOrder;
    bio?: SortOrderInput | SortOrder;
    organization?: SortOrderInput | SortOrder;
    password?: SortOrderInput | SortOrder;
    roles?: SortOrder;
    totpSecret?: SortOrderInput | SortOrder;
    totpEnabled?: SortOrder;
    passwordResetToken?: SortOrderInput | SortOrder;
    passwordResetExpires?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    lastLoginAt?: SortOrderInput | SortOrder;
    isActive?: SortOrder;
    isBanned?: SortOrder;
    _count?: UserCountOrderByAggregateInput;
    _max?: UserMaxOrderByAggregateInput;
    _min?: UserMinOrderByAggregateInput;
  };

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[];
    OR?: UserScalarWhereWithAggregatesInput[];
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'User'> | string;
    email?: StringWithAggregatesFilter<'User'> | string;
    emailVerified?: DateTimeNullableWithAggregatesFilter<'User'> | Date | string | null;
    name?: StringNullableWithAggregatesFilter<'User'> | string | null;
    handle?: StringNullableWithAggregatesFilter<'User'> | string | null;
    avatarUrl?: StringNullableWithAggregatesFilter<'User'> | string | null;
    bio?: StringNullableWithAggregatesFilter<'User'> | string | null;
    organization?: StringNullableWithAggregatesFilter<'User'> | string | null;
    password?: StringNullableWithAggregatesFilter<'User'> | string | null;
    roles?: EnumRoleNullableListFilter<'User'>;
    totpSecret?: StringNullableWithAggregatesFilter<'User'> | string | null;
    totpEnabled?: BoolWithAggregatesFilter<'User'> | boolean;
    passwordResetToken?: StringNullableWithAggregatesFilter<'User'> | string | null;
    passwordResetExpires?: DateTimeNullableWithAggregatesFilter<'User'> | Date | string | null;
    createdAt?: DateTimeWithAggregatesFilter<'User'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'User'> | Date | string;
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<'User'> | Date | string | null;
    isActive?: BoolWithAggregatesFilter<'User'> | boolean;
    isBanned?: BoolWithAggregatesFilter<'User'> | boolean;
  };

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[];
    OR?: AccountWhereInput[];
    NOT?: AccountWhereInput | AccountWhereInput[];
    id?: StringFilter<'Account'> | string;
    userId?: StringFilter<'Account'> | string;
    type?: StringFilter<'Account'> | string;
    provider?: StringFilter<'Account'> | string;
    providerAccountId?: StringFilter<'Account'> | string;
    refresh_token?: StringNullableFilter<'Account'> | string | null;
    access_token?: StringNullableFilter<'Account'> | string | null;
    expires_at?: IntNullableFilter<'Account'> | number | null;
    token_type?: StringNullableFilter<'Account'> | string | null;
    scope?: StringNullableFilter<'Account'> | string | null;
    id_token?: StringNullableFilter<'Account'> | string | null;
    session_state?: StringNullableFilter<'Account'> | string | null;
    user?: XOR<UserRelationFilter, UserWhereInput>;
  };

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    type?: SortOrder;
    provider?: SortOrder;
    providerAccountId?: SortOrder;
    refresh_token?: SortOrderInput | SortOrder;
    access_token?: SortOrderInput | SortOrder;
    expires_at?: SortOrderInput | SortOrder;
    token_type?: SortOrderInput | SortOrder;
    scope?: SortOrderInput | SortOrder;
    id_token?: SortOrderInput | SortOrder;
    session_state?: SortOrderInput | SortOrder;
    user?: UserOrderByWithRelationInput;
  };

  export type AccountWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      provider_providerAccountId?: AccountProviderProviderAccountIdCompoundUniqueInput;
      AND?: AccountWhereInput | AccountWhereInput[];
      OR?: AccountWhereInput[];
      NOT?: AccountWhereInput | AccountWhereInput[];
      userId?: StringFilter<'Account'> | string;
      type?: StringFilter<'Account'> | string;
      provider?: StringFilter<'Account'> | string;
      providerAccountId?: StringFilter<'Account'> | string;
      refresh_token?: StringNullableFilter<'Account'> | string | null;
      access_token?: StringNullableFilter<'Account'> | string | null;
      expires_at?: IntNullableFilter<'Account'> | number | null;
      token_type?: StringNullableFilter<'Account'> | string | null;
      scope?: StringNullableFilter<'Account'> | string | null;
      id_token?: StringNullableFilter<'Account'> | string | null;
      session_state?: StringNullableFilter<'Account'> | string | null;
      user?: XOR<UserRelationFilter, UserWhereInput>;
    },
    'id' | 'provider_providerAccountId'
  >;

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    type?: SortOrder;
    provider?: SortOrder;
    providerAccountId?: SortOrder;
    refresh_token?: SortOrderInput | SortOrder;
    access_token?: SortOrderInput | SortOrder;
    expires_at?: SortOrderInput | SortOrder;
    token_type?: SortOrderInput | SortOrder;
    scope?: SortOrderInput | SortOrder;
    id_token?: SortOrderInput | SortOrder;
    session_state?: SortOrderInput | SortOrder;
    _count?: AccountCountOrderByAggregateInput;
    _avg?: AccountAvgOrderByAggregateInput;
    _max?: AccountMaxOrderByAggregateInput;
    _min?: AccountMinOrderByAggregateInput;
    _sum?: AccountSumOrderByAggregateInput;
  };

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[];
    OR?: AccountScalarWhereWithAggregatesInput[];
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Account'> | string;
    userId?: StringWithAggregatesFilter<'Account'> | string;
    type?: StringWithAggregatesFilter<'Account'> | string;
    provider?: StringWithAggregatesFilter<'Account'> | string;
    providerAccountId?: StringWithAggregatesFilter<'Account'> | string;
    refresh_token?: StringNullableWithAggregatesFilter<'Account'> | string | null;
    access_token?: StringNullableWithAggregatesFilter<'Account'> | string | null;
    expires_at?: IntNullableWithAggregatesFilter<'Account'> | number | null;
    token_type?: StringNullableWithAggregatesFilter<'Account'> | string | null;
    scope?: StringNullableWithAggregatesFilter<'Account'> | string | null;
    id_token?: StringNullableWithAggregatesFilter<'Account'> | string | null;
    session_state?: StringNullableWithAggregatesFilter<'Account'> | string | null;
  };

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[];
    OR?: SessionWhereInput[];
    NOT?: SessionWhereInput | SessionWhereInput[];
    id?: StringFilter<'Session'> | string;
    sessionToken?: StringFilter<'Session'> | string;
    userId?: StringFilter<'Session'> | string;
    expires?: DateTimeFilter<'Session'> | Date | string;
    user?: XOR<UserRelationFilter, UserWhereInput>;
  };

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder;
    sessionToken?: SortOrder;
    userId?: SortOrder;
    expires?: SortOrder;
    user?: UserOrderByWithRelationInput;
  };

  export type SessionWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      sessionToken?: string;
      AND?: SessionWhereInput | SessionWhereInput[];
      OR?: SessionWhereInput[];
      NOT?: SessionWhereInput | SessionWhereInput[];
      userId?: StringFilter<'Session'> | string;
      expires?: DateTimeFilter<'Session'> | Date | string;
      user?: XOR<UserRelationFilter, UserWhereInput>;
    },
    'id' | 'sessionToken'
  >;

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder;
    sessionToken?: SortOrder;
    userId?: SortOrder;
    expires?: SortOrder;
    _count?: SessionCountOrderByAggregateInput;
    _max?: SessionMaxOrderByAggregateInput;
    _min?: SessionMinOrderByAggregateInput;
  };

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[];
    OR?: SessionScalarWhereWithAggregatesInput[];
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Session'> | string;
    sessionToken?: StringWithAggregatesFilter<'Session'> | string;
    userId?: StringWithAggregatesFilter<'Session'> | string;
    expires?: DateTimeWithAggregatesFilter<'Session'> | Date | string;
  };

  export type VerificationTokenWhereInput = {
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[];
    OR?: VerificationTokenWhereInput[];
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[];
    identifier?: StringFilter<'VerificationToken'> | string;
    token?: StringFilter<'VerificationToken'> | string;
    expires?: DateTimeFilter<'VerificationToken'> | Date | string;
  };

  export type VerificationTokenOrderByWithRelationInput = {
    identifier?: SortOrder;
    token?: SortOrder;
    expires?: SortOrder;
  };

  export type VerificationTokenWhereUniqueInput = Prisma.AtLeast<
    {
      token?: string;
      identifier_token?: VerificationTokenIdentifierTokenCompoundUniqueInput;
      AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[];
      OR?: VerificationTokenWhereInput[];
      NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[];
      identifier?: StringFilter<'VerificationToken'> | string;
      expires?: DateTimeFilter<'VerificationToken'> | Date | string;
    },
    'token' | 'identifier_token'
  >;

  export type VerificationTokenOrderByWithAggregationInput = {
    identifier?: SortOrder;
    token?: SortOrder;
    expires?: SortOrder;
    _count?: VerificationTokenCountOrderByAggregateInput;
    _max?: VerificationTokenMaxOrderByAggregateInput;
    _min?: VerificationTokenMinOrderByAggregateInput;
  };

  export type VerificationTokenScalarWhereWithAggregatesInput = {
    AND?:
      | VerificationTokenScalarWhereWithAggregatesInput
      | VerificationTokenScalarWhereWithAggregatesInput[];
    OR?: VerificationTokenScalarWhereWithAggregatesInput[];
    NOT?:
      | VerificationTokenScalarWhereWithAggregatesInput
      | VerificationTokenScalarWhereWithAggregatesInput[];
    identifier?: StringWithAggregatesFilter<'VerificationToken'> | string;
    token?: StringWithAggregatesFilter<'VerificationToken'> | string;
    expires?: DateTimeWithAggregatesFilter<'VerificationToken'> | Date | string;
  };

  export type ApiKeyWhereInput = {
    AND?: ApiKeyWhereInput | ApiKeyWhereInput[];
    OR?: ApiKeyWhereInput[];
    NOT?: ApiKeyWhereInput | ApiKeyWhereInput[];
    id?: StringFilter<'ApiKey'> | string;
    userId?: StringFilter<'ApiKey'> | string;
    name?: StringFilter<'ApiKey'> | string;
    hashedKey?: StringFilter<'ApiKey'> | string;
    scopes?: StringNullableListFilter<'ApiKey'>;
    lastUsedAt?: DateTimeNullableFilter<'ApiKey'> | Date | string | null;
    expiresAt?: DateTimeNullableFilter<'ApiKey'> | Date | string | null;
    createdAt?: DateTimeFilter<'ApiKey'> | Date | string;
    isActive?: BoolFilter<'ApiKey'> | boolean;
    user?: XOR<UserRelationFilter, UserWhereInput>;
  };

  export type ApiKeyOrderByWithRelationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    name?: SortOrder;
    hashedKey?: SortOrder;
    scopes?: SortOrder;
    lastUsedAt?: SortOrderInput | SortOrder;
    expiresAt?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    isActive?: SortOrder;
    user?: UserOrderByWithRelationInput;
  };

  export type ApiKeyWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      hashedKey?: string;
      AND?: ApiKeyWhereInput | ApiKeyWhereInput[];
      OR?: ApiKeyWhereInput[];
      NOT?: ApiKeyWhereInput | ApiKeyWhereInput[];
      userId?: StringFilter<'ApiKey'> | string;
      name?: StringFilter<'ApiKey'> | string;
      scopes?: StringNullableListFilter<'ApiKey'>;
      lastUsedAt?: DateTimeNullableFilter<'ApiKey'> | Date | string | null;
      expiresAt?: DateTimeNullableFilter<'ApiKey'> | Date | string | null;
      createdAt?: DateTimeFilter<'ApiKey'> | Date | string;
      isActive?: BoolFilter<'ApiKey'> | boolean;
      user?: XOR<UserRelationFilter, UserWhereInput>;
    },
    'id' | 'hashedKey'
  >;

  export type ApiKeyOrderByWithAggregationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    name?: SortOrder;
    hashedKey?: SortOrder;
    scopes?: SortOrder;
    lastUsedAt?: SortOrderInput | SortOrder;
    expiresAt?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    isActive?: SortOrder;
    _count?: ApiKeyCountOrderByAggregateInput;
    _max?: ApiKeyMaxOrderByAggregateInput;
    _min?: ApiKeyMinOrderByAggregateInput;
  };

  export type ApiKeyScalarWhereWithAggregatesInput = {
    AND?: ApiKeyScalarWhereWithAggregatesInput | ApiKeyScalarWhereWithAggregatesInput[];
    OR?: ApiKeyScalarWhereWithAggregatesInput[];
    NOT?: ApiKeyScalarWhereWithAggregatesInput | ApiKeyScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'ApiKey'> | string;
    userId?: StringWithAggregatesFilter<'ApiKey'> | string;
    name?: StringWithAggregatesFilter<'ApiKey'> | string;
    hashedKey?: StringWithAggregatesFilter<'ApiKey'> | string;
    scopes?: StringNullableListFilter<'ApiKey'>;
    lastUsedAt?: DateTimeNullableWithAggregatesFilter<'ApiKey'> | Date | string | null;
    expiresAt?: DateTimeNullableWithAggregatesFilter<'ApiKey'> | Date | string | null;
    createdAt?: DateTimeWithAggregatesFilter<'ApiKey'> | Date | string;
    isActive?: BoolWithAggregatesFilter<'ApiKey'> | boolean;
  };

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[];
    OR?: AuditLogWhereInput[];
    NOT?: AuditLogWhereInput | AuditLogWhereInput[];
    id?: StringFilter<'AuditLog'> | string;
    actorId?: StringNullableFilter<'AuditLog'> | string | null;
    action?: StringFilter<'AuditLog'> | string;
    entityType?: StringFilter<'AuditLog'> | string;
    entityId?: StringNullableFilter<'AuditLog'> | string | null;
    metadata?: JsonNullableFilter<'AuditLog'>;
    ipAddress?: StringNullableFilter<'AuditLog'> | string | null;
    userAgent?: StringNullableFilter<'AuditLog'> | string | null;
    createdAt?: DateTimeFilter<'AuditLog'> | Date | string;
    actor?: XOR<UserNullableRelationFilter, UserWhereInput> | null;
  };

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder;
    actorId?: SortOrderInput | SortOrder;
    action?: SortOrder;
    entityType?: SortOrder;
    entityId?: SortOrderInput | SortOrder;
    metadata?: SortOrderInput | SortOrder;
    ipAddress?: SortOrderInput | SortOrder;
    userAgent?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    actor?: UserOrderByWithRelationInput;
  };

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: AuditLogWhereInput | AuditLogWhereInput[];
      OR?: AuditLogWhereInput[];
      NOT?: AuditLogWhereInput | AuditLogWhereInput[];
      actorId?: StringNullableFilter<'AuditLog'> | string | null;
      action?: StringFilter<'AuditLog'> | string;
      entityType?: StringFilter<'AuditLog'> | string;
      entityId?: StringNullableFilter<'AuditLog'> | string | null;
      metadata?: JsonNullableFilter<'AuditLog'>;
      ipAddress?: StringNullableFilter<'AuditLog'> | string | null;
      userAgent?: StringNullableFilter<'AuditLog'> | string | null;
      createdAt?: DateTimeFilter<'AuditLog'> | Date | string;
      actor?: XOR<UserNullableRelationFilter, UserWhereInput> | null;
    },
    'id'
  >;

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder;
    actorId?: SortOrderInput | SortOrder;
    action?: SortOrder;
    entityType?: SortOrder;
    entityId?: SortOrderInput | SortOrder;
    metadata?: SortOrderInput | SortOrder;
    ipAddress?: SortOrderInput | SortOrder;
    userAgent?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    _count?: AuditLogCountOrderByAggregateInput;
    _max?: AuditLogMaxOrderByAggregateInput;
    _min?: AuditLogMinOrderByAggregateInput;
  };

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[];
    OR?: AuditLogScalarWhereWithAggregatesInput[];
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'AuditLog'> | string;
    actorId?: StringNullableWithAggregatesFilter<'AuditLog'> | string | null;
    action?: StringWithAggregatesFilter<'AuditLog'> | string;
    entityType?: StringWithAggregatesFilter<'AuditLog'> | string;
    entityId?: StringNullableWithAggregatesFilter<'AuditLog'> | string | null;
    metadata?: JsonNullableWithAggregatesFilter<'AuditLog'>;
    ipAddress?: StringNullableWithAggregatesFilter<'AuditLog'> | string | null;
    userAgent?: StringNullableWithAggregatesFilter<'AuditLog'> | string | null;
    createdAt?: DateTimeWithAggregatesFilter<'AuditLog'> | Date | string;
  };

  export type HackathonWhereInput = {
    AND?: HackathonWhereInput | HackathonWhereInput[];
    OR?: HackathonWhereInput[];
    NOT?: HackathonWhereInput | HackathonWhereInput[];
    id?: StringFilter<'Hackathon'> | string;
    slug?: StringFilter<'Hackathon'> | string;
    title?: StringFilter<'Hackathon'> | string;
    description?: StringFilter<'Hackathon'> | string;
    coverImage?: StringNullableFilter<'Hackathon'> | string | null;
    status?: EnumHackathonStatusFilter<'Hackathon'> | $Enums.HackathonStatus;
    location?: EnumHackathonLocationFilter<'Hackathon'> | $Enums.HackathonLocation;
    registrationOpensAt?: DateTimeNullableFilter<'Hackathon'> | Date | string | null;
    registrationClosesAt?: DateTimeNullableFilter<'Hackathon'> | Date | string | null;
    startsAt?: DateTimeFilter<'Hackathon'> | Date | string;
    endsAt?: DateTimeFilter<'Hackathon'> | Date | string;
    judgingEndsAt?: DateTimeNullableFilter<'Hackathon'> | Date | string | null;
    prizePool?:
      | DecimalNullableFilter<'Hackathon'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    maxTeamSize?: IntFilter<'Hackathon'> | number;
    allowSoloTeams?: BoolFilter<'Hackathon'> | boolean;
    rules?: StringNullableFilter<'Hackathon'> | string | null;
    schedule?: JsonNullableFilter<'Hackathon'>;
    metadata?: JsonNullableFilter<'Hackathon'>;
    createdAt?: DateTimeFilter<'Hackathon'> | Date | string;
    updatedAt?: DateTimeFilter<'Hackathon'> | Date | string;
    tracks?: TrackListRelationFilter;
    teams?: TeamListRelationFilter;
    mentors?: MentorListRelationFilter;
    judges?: JudgeListRelationFilter;
    criteria?: CriteriaListRelationFilter;
    submissions?: SubmissionListRelationFilter;
    announcements?: AnnouncementListRelationFilter;
  };

  export type HackathonOrderByWithRelationInput = {
    id?: SortOrder;
    slug?: SortOrder;
    title?: SortOrder;
    description?: SortOrder;
    coverImage?: SortOrderInput | SortOrder;
    status?: SortOrder;
    location?: SortOrder;
    registrationOpensAt?: SortOrderInput | SortOrder;
    registrationClosesAt?: SortOrderInput | SortOrder;
    startsAt?: SortOrder;
    endsAt?: SortOrder;
    judgingEndsAt?: SortOrderInput | SortOrder;
    prizePool?: SortOrderInput | SortOrder;
    maxTeamSize?: SortOrder;
    allowSoloTeams?: SortOrder;
    rules?: SortOrderInput | SortOrder;
    schedule?: SortOrderInput | SortOrder;
    metadata?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    tracks?: TrackOrderByRelationAggregateInput;
    teams?: TeamOrderByRelationAggregateInput;
    mentors?: MentorOrderByRelationAggregateInput;
    judges?: JudgeOrderByRelationAggregateInput;
    criteria?: CriteriaOrderByRelationAggregateInput;
    submissions?: SubmissionOrderByRelationAggregateInput;
    announcements?: AnnouncementOrderByRelationAggregateInput;
  };

  export type HackathonWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      slug?: string;
      AND?: HackathonWhereInput | HackathonWhereInput[];
      OR?: HackathonWhereInput[];
      NOT?: HackathonWhereInput | HackathonWhereInput[];
      title?: StringFilter<'Hackathon'> | string;
      description?: StringFilter<'Hackathon'> | string;
      coverImage?: StringNullableFilter<'Hackathon'> | string | null;
      status?: EnumHackathonStatusFilter<'Hackathon'> | $Enums.HackathonStatus;
      location?: EnumHackathonLocationFilter<'Hackathon'> | $Enums.HackathonLocation;
      registrationOpensAt?: DateTimeNullableFilter<'Hackathon'> | Date | string | null;
      registrationClosesAt?: DateTimeNullableFilter<'Hackathon'> | Date | string | null;
      startsAt?: DateTimeFilter<'Hackathon'> | Date | string;
      endsAt?: DateTimeFilter<'Hackathon'> | Date | string;
      judgingEndsAt?: DateTimeNullableFilter<'Hackathon'> | Date | string | null;
      prizePool?:
        | DecimalNullableFilter<'Hackathon'>
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      maxTeamSize?: IntFilter<'Hackathon'> | number;
      allowSoloTeams?: BoolFilter<'Hackathon'> | boolean;
      rules?: StringNullableFilter<'Hackathon'> | string | null;
      schedule?: JsonNullableFilter<'Hackathon'>;
      metadata?: JsonNullableFilter<'Hackathon'>;
      createdAt?: DateTimeFilter<'Hackathon'> | Date | string;
      updatedAt?: DateTimeFilter<'Hackathon'> | Date | string;
      tracks?: TrackListRelationFilter;
      teams?: TeamListRelationFilter;
      mentors?: MentorListRelationFilter;
      judges?: JudgeListRelationFilter;
      criteria?: CriteriaListRelationFilter;
      submissions?: SubmissionListRelationFilter;
      announcements?: AnnouncementListRelationFilter;
    },
    'id' | 'slug'
  >;

  export type HackathonOrderByWithAggregationInput = {
    id?: SortOrder;
    slug?: SortOrder;
    title?: SortOrder;
    description?: SortOrder;
    coverImage?: SortOrderInput | SortOrder;
    status?: SortOrder;
    location?: SortOrder;
    registrationOpensAt?: SortOrderInput | SortOrder;
    registrationClosesAt?: SortOrderInput | SortOrder;
    startsAt?: SortOrder;
    endsAt?: SortOrder;
    judgingEndsAt?: SortOrderInput | SortOrder;
    prizePool?: SortOrderInput | SortOrder;
    maxTeamSize?: SortOrder;
    allowSoloTeams?: SortOrder;
    rules?: SortOrderInput | SortOrder;
    schedule?: SortOrderInput | SortOrder;
    metadata?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: HackathonCountOrderByAggregateInput;
    _avg?: HackathonAvgOrderByAggregateInput;
    _max?: HackathonMaxOrderByAggregateInput;
    _min?: HackathonMinOrderByAggregateInput;
    _sum?: HackathonSumOrderByAggregateInput;
  };

  export type HackathonScalarWhereWithAggregatesInput = {
    AND?: HackathonScalarWhereWithAggregatesInput | HackathonScalarWhereWithAggregatesInput[];
    OR?: HackathonScalarWhereWithAggregatesInput[];
    NOT?: HackathonScalarWhereWithAggregatesInput | HackathonScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Hackathon'> | string;
    slug?: StringWithAggregatesFilter<'Hackathon'> | string;
    title?: StringWithAggregatesFilter<'Hackathon'> | string;
    description?: StringWithAggregatesFilter<'Hackathon'> | string;
    coverImage?: StringNullableWithAggregatesFilter<'Hackathon'> | string | null;
    status?: EnumHackathonStatusWithAggregatesFilter<'Hackathon'> | $Enums.HackathonStatus;
    location?: EnumHackathonLocationWithAggregatesFilter<'Hackathon'> | $Enums.HackathonLocation;
    registrationOpensAt?: DateTimeNullableWithAggregatesFilter<'Hackathon'> | Date | string | null;
    registrationClosesAt?: DateTimeNullableWithAggregatesFilter<'Hackathon'> | Date | string | null;
    startsAt?: DateTimeWithAggregatesFilter<'Hackathon'> | Date | string;
    endsAt?: DateTimeWithAggregatesFilter<'Hackathon'> | Date | string;
    judgingEndsAt?: DateTimeNullableWithAggregatesFilter<'Hackathon'> | Date | string | null;
    prizePool?:
      | DecimalNullableWithAggregatesFilter<'Hackathon'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    maxTeamSize?: IntWithAggregatesFilter<'Hackathon'> | number;
    allowSoloTeams?: BoolWithAggregatesFilter<'Hackathon'> | boolean;
    rules?: StringNullableWithAggregatesFilter<'Hackathon'> | string | null;
    schedule?: JsonNullableWithAggregatesFilter<'Hackathon'>;
    metadata?: JsonNullableWithAggregatesFilter<'Hackathon'>;
    createdAt?: DateTimeWithAggregatesFilter<'Hackathon'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'Hackathon'> | Date | string;
  };

  export type TrackWhereInput = {
    AND?: TrackWhereInput | TrackWhereInput[];
    OR?: TrackWhereInput[];
    NOT?: TrackWhereInput | TrackWhereInput[];
    id?: StringFilter<'Track'> | string;
    hackathonId?: StringFilter<'Track'> | string;
    title?: StringFilter<'Track'> | string;
    description?: StringNullableFilter<'Track'> | string | null;
    order?: IntFilter<'Track'> | number;
    createdAt?: DateTimeFilter<'Track'> | Date | string;
    hackathon?: XOR<HackathonRelationFilter, HackathonWhereInput>;
    submissions?: SubmissionListRelationFilter;
  };

  export type TrackOrderByWithRelationInput = {
    id?: SortOrder;
    hackathonId?: SortOrder;
    title?: SortOrder;
    description?: SortOrderInput | SortOrder;
    order?: SortOrder;
    createdAt?: SortOrder;
    hackathon?: HackathonOrderByWithRelationInput;
    submissions?: SubmissionOrderByRelationAggregateInput;
  };

  export type TrackWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: TrackWhereInput | TrackWhereInput[];
      OR?: TrackWhereInput[];
      NOT?: TrackWhereInput | TrackWhereInput[];
      hackathonId?: StringFilter<'Track'> | string;
      title?: StringFilter<'Track'> | string;
      description?: StringNullableFilter<'Track'> | string | null;
      order?: IntFilter<'Track'> | number;
      createdAt?: DateTimeFilter<'Track'> | Date | string;
      hackathon?: XOR<HackathonRelationFilter, HackathonWhereInput>;
      submissions?: SubmissionListRelationFilter;
    },
    'id'
  >;

  export type TrackOrderByWithAggregationInput = {
    id?: SortOrder;
    hackathonId?: SortOrder;
    title?: SortOrder;
    description?: SortOrderInput | SortOrder;
    order?: SortOrder;
    createdAt?: SortOrder;
    _count?: TrackCountOrderByAggregateInput;
    _avg?: TrackAvgOrderByAggregateInput;
    _max?: TrackMaxOrderByAggregateInput;
    _min?: TrackMinOrderByAggregateInput;
    _sum?: TrackSumOrderByAggregateInput;
  };

  export type TrackScalarWhereWithAggregatesInput = {
    AND?: TrackScalarWhereWithAggregatesInput | TrackScalarWhereWithAggregatesInput[];
    OR?: TrackScalarWhereWithAggregatesInput[];
    NOT?: TrackScalarWhereWithAggregatesInput | TrackScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Track'> | string;
    hackathonId?: StringWithAggregatesFilter<'Track'> | string;
    title?: StringWithAggregatesFilter<'Track'> | string;
    description?: StringNullableWithAggregatesFilter<'Track'> | string | null;
    order?: IntWithAggregatesFilter<'Track'> | number;
    createdAt?: DateTimeWithAggregatesFilter<'Track'> | Date | string;
  };

  export type TeamWhereInput = {
    AND?: TeamWhereInput | TeamWhereInput[];
    OR?: TeamWhereInput[];
    NOT?: TeamWhereInput | TeamWhereInput[];
    id?: StringFilter<'Team'> | string;
    hackathonId?: StringFilter<'Team'> | string;
    name?: StringFilter<'Team'> | string;
    bio?: StringNullableFilter<'Team'> | string | null;
    logoUrl?: StringNullableFilter<'Team'> | string | null;
    repoUrl?: StringNullableFilter<'Team'> | string | null;
    demoUrl?: StringNullableFilter<'Team'> | string | null;
    createdAt?: DateTimeFilter<'Team'> | Date | string;
    updatedAt?: DateTimeFilter<'Team'> | Date | string;
    hackathon?: XOR<HackathonRelationFilter, HackathonWhereInput>;
    members?: TeamMemberListRelationFilter;
    submissions?: SubmissionListRelationFilter;
    challengeSubmissions?: ChallengeSubmissionListRelationFilter;
  };

  export type TeamOrderByWithRelationInput = {
    id?: SortOrder;
    hackathonId?: SortOrder;
    name?: SortOrder;
    bio?: SortOrderInput | SortOrder;
    logoUrl?: SortOrderInput | SortOrder;
    repoUrl?: SortOrderInput | SortOrder;
    demoUrl?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    hackathon?: HackathonOrderByWithRelationInput;
    members?: TeamMemberOrderByRelationAggregateInput;
    submissions?: SubmissionOrderByRelationAggregateInput;
    challengeSubmissions?: ChallengeSubmissionOrderByRelationAggregateInput;
  };

  export type TeamWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: TeamWhereInput | TeamWhereInput[];
      OR?: TeamWhereInput[];
      NOT?: TeamWhereInput | TeamWhereInput[];
      hackathonId?: StringFilter<'Team'> | string;
      name?: StringFilter<'Team'> | string;
      bio?: StringNullableFilter<'Team'> | string | null;
      logoUrl?: StringNullableFilter<'Team'> | string | null;
      repoUrl?: StringNullableFilter<'Team'> | string | null;
      demoUrl?: StringNullableFilter<'Team'> | string | null;
      createdAt?: DateTimeFilter<'Team'> | Date | string;
      updatedAt?: DateTimeFilter<'Team'> | Date | string;
      hackathon?: XOR<HackathonRelationFilter, HackathonWhereInput>;
      members?: TeamMemberListRelationFilter;
      submissions?: SubmissionListRelationFilter;
      challengeSubmissions?: ChallengeSubmissionListRelationFilter;
    },
    'id'
  >;

  export type TeamOrderByWithAggregationInput = {
    id?: SortOrder;
    hackathonId?: SortOrder;
    name?: SortOrder;
    bio?: SortOrderInput | SortOrder;
    logoUrl?: SortOrderInput | SortOrder;
    repoUrl?: SortOrderInput | SortOrder;
    demoUrl?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: TeamCountOrderByAggregateInput;
    _max?: TeamMaxOrderByAggregateInput;
    _min?: TeamMinOrderByAggregateInput;
  };

  export type TeamScalarWhereWithAggregatesInput = {
    AND?: TeamScalarWhereWithAggregatesInput | TeamScalarWhereWithAggregatesInput[];
    OR?: TeamScalarWhereWithAggregatesInput[];
    NOT?: TeamScalarWhereWithAggregatesInput | TeamScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Team'> | string;
    hackathonId?: StringWithAggregatesFilter<'Team'> | string;
    name?: StringWithAggregatesFilter<'Team'> | string;
    bio?: StringNullableWithAggregatesFilter<'Team'> | string | null;
    logoUrl?: StringNullableWithAggregatesFilter<'Team'> | string | null;
    repoUrl?: StringNullableWithAggregatesFilter<'Team'> | string | null;
    demoUrl?: StringNullableWithAggregatesFilter<'Team'> | string | null;
    createdAt?: DateTimeWithAggregatesFilter<'Team'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'Team'> | Date | string;
  };

  export type TeamMemberWhereInput = {
    AND?: TeamMemberWhereInput | TeamMemberWhereInput[];
    OR?: TeamMemberWhereInput[];
    NOT?: TeamMemberWhereInput | TeamMemberWhereInput[];
    teamId?: StringFilter<'TeamMember'> | string;
    userId?: StringFilter<'TeamMember'> | string;
    role?: EnumTeamMemberRoleFilter<'TeamMember'> | $Enums.TeamMemberRole;
    joinedAt?: DateTimeFilter<'TeamMember'> | Date | string;
    team?: XOR<TeamRelationFilter, TeamWhereInput>;
    user?: XOR<UserRelationFilter, UserWhereInput>;
  };

  export type TeamMemberOrderByWithRelationInput = {
    teamId?: SortOrder;
    userId?: SortOrder;
    role?: SortOrder;
    joinedAt?: SortOrder;
    team?: TeamOrderByWithRelationInput;
    user?: UserOrderByWithRelationInput;
  };

  export type TeamMemberWhereUniqueInput = Prisma.AtLeast<
    {
      teamId_userId?: TeamMemberTeamIdUserIdCompoundUniqueInput;
      AND?: TeamMemberWhereInput | TeamMemberWhereInput[];
      OR?: TeamMemberWhereInput[];
      NOT?: TeamMemberWhereInput | TeamMemberWhereInput[];
      teamId?: StringFilter<'TeamMember'> | string;
      userId?: StringFilter<'TeamMember'> | string;
      role?: EnumTeamMemberRoleFilter<'TeamMember'> | $Enums.TeamMemberRole;
      joinedAt?: DateTimeFilter<'TeamMember'> | Date | string;
      team?: XOR<TeamRelationFilter, TeamWhereInput>;
      user?: XOR<UserRelationFilter, UserWhereInput>;
    },
    'teamId_userId'
  >;

  export type TeamMemberOrderByWithAggregationInput = {
    teamId?: SortOrder;
    userId?: SortOrder;
    role?: SortOrder;
    joinedAt?: SortOrder;
    _count?: TeamMemberCountOrderByAggregateInput;
    _max?: TeamMemberMaxOrderByAggregateInput;
    _min?: TeamMemberMinOrderByAggregateInput;
  };

  export type TeamMemberScalarWhereWithAggregatesInput = {
    AND?: TeamMemberScalarWhereWithAggregatesInput | TeamMemberScalarWhereWithAggregatesInput[];
    OR?: TeamMemberScalarWhereWithAggregatesInput[];
    NOT?: TeamMemberScalarWhereWithAggregatesInput | TeamMemberScalarWhereWithAggregatesInput[];
    teamId?: StringWithAggregatesFilter<'TeamMember'> | string;
    userId?: StringWithAggregatesFilter<'TeamMember'> | string;
    role?: EnumTeamMemberRoleWithAggregatesFilter<'TeamMember'> | $Enums.TeamMemberRole;
    joinedAt?: DateTimeWithAggregatesFilter<'TeamMember'> | Date | string;
  };

  export type MentorWhereInput = {
    AND?: MentorWhereInput | MentorWhereInput[];
    OR?: MentorWhereInput[];
    NOT?: MentorWhereInput | MentorWhereInput[];
    id?: StringFilter<'Mentor'> | string;
    userId?: StringFilter<'Mentor'> | string;
    hackathonId?: StringFilter<'Mentor'> | string;
    bio?: StringNullableFilter<'Mentor'> | string | null;
    calendlyUrl?: StringNullableFilter<'Mentor'> | string | null;
    expertise?: StringNullableListFilter<'Mentor'>;
    createdAt?: DateTimeFilter<'Mentor'> | Date | string;
    user?: XOR<UserRelationFilter, UserWhereInput>;
    hackathon?: XOR<HackathonRelationFilter, HackathonWhereInput>;
    sessions?: MentorSessionListRelationFilter;
  };

  export type MentorOrderByWithRelationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    hackathonId?: SortOrder;
    bio?: SortOrderInput | SortOrder;
    calendlyUrl?: SortOrderInput | SortOrder;
    expertise?: SortOrder;
    createdAt?: SortOrder;
    user?: UserOrderByWithRelationInput;
    hackathon?: HackathonOrderByWithRelationInput;
    sessions?: MentorSessionOrderByRelationAggregateInput;
  };

  export type MentorWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      userId_hackathonId?: MentorUserIdHackathonIdCompoundUniqueInput;
      AND?: MentorWhereInput | MentorWhereInput[];
      OR?: MentorWhereInput[];
      NOT?: MentorWhereInput | MentorWhereInput[];
      userId?: StringFilter<'Mentor'> | string;
      hackathonId?: StringFilter<'Mentor'> | string;
      bio?: StringNullableFilter<'Mentor'> | string | null;
      calendlyUrl?: StringNullableFilter<'Mentor'> | string | null;
      expertise?: StringNullableListFilter<'Mentor'>;
      createdAt?: DateTimeFilter<'Mentor'> | Date | string;
      user?: XOR<UserRelationFilter, UserWhereInput>;
      hackathon?: XOR<HackathonRelationFilter, HackathonWhereInput>;
      sessions?: MentorSessionListRelationFilter;
    },
    'id' | 'userId_hackathonId'
  >;

  export type MentorOrderByWithAggregationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    hackathonId?: SortOrder;
    bio?: SortOrderInput | SortOrder;
    calendlyUrl?: SortOrderInput | SortOrder;
    expertise?: SortOrder;
    createdAt?: SortOrder;
    _count?: MentorCountOrderByAggregateInput;
    _max?: MentorMaxOrderByAggregateInput;
    _min?: MentorMinOrderByAggregateInput;
  };

  export type MentorScalarWhereWithAggregatesInput = {
    AND?: MentorScalarWhereWithAggregatesInput | MentorScalarWhereWithAggregatesInput[];
    OR?: MentorScalarWhereWithAggregatesInput[];
    NOT?: MentorScalarWhereWithAggregatesInput | MentorScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Mentor'> | string;
    userId?: StringWithAggregatesFilter<'Mentor'> | string;
    hackathonId?: StringWithAggregatesFilter<'Mentor'> | string;
    bio?: StringNullableWithAggregatesFilter<'Mentor'> | string | null;
    calendlyUrl?: StringNullableWithAggregatesFilter<'Mentor'> | string | null;
    expertise?: StringNullableListFilter<'Mentor'>;
    createdAt?: DateTimeWithAggregatesFilter<'Mentor'> | Date | string;
  };

  export type MentorSessionWhereInput = {
    AND?: MentorSessionWhereInput | MentorSessionWhereInput[];
    OR?: MentorSessionWhereInput[];
    NOT?: MentorSessionWhereInput | MentorSessionWhereInput[];
    id?: StringFilter<'MentorSession'> | string;
    mentorId?: StringFilter<'MentorSession'> | string;
    title?: StringNullableFilter<'MentorSession'> | string | null;
    startsAt?: DateTimeFilter<'MentorSession'> | Date | string;
    endsAt?: DateTimeFilter<'MentorSession'> | Date | string;
    capacity?: IntFilter<'MentorSession'> | number;
    booked?: IntFilter<'MentorSession'> | number;
    meetingUrl?: StringNullableFilter<'MentorSession'> | string | null;
    createdAt?: DateTimeFilter<'MentorSession'> | Date | string;
    mentor?: XOR<MentorRelationFilter, MentorWhereInput>;
  };

  export type MentorSessionOrderByWithRelationInput = {
    id?: SortOrder;
    mentorId?: SortOrder;
    title?: SortOrderInput | SortOrder;
    startsAt?: SortOrder;
    endsAt?: SortOrder;
    capacity?: SortOrder;
    booked?: SortOrder;
    meetingUrl?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    mentor?: MentorOrderByWithRelationInput;
  };

  export type MentorSessionWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: MentorSessionWhereInput | MentorSessionWhereInput[];
      OR?: MentorSessionWhereInput[];
      NOT?: MentorSessionWhereInput | MentorSessionWhereInput[];
      mentorId?: StringFilter<'MentorSession'> | string;
      title?: StringNullableFilter<'MentorSession'> | string | null;
      startsAt?: DateTimeFilter<'MentorSession'> | Date | string;
      endsAt?: DateTimeFilter<'MentorSession'> | Date | string;
      capacity?: IntFilter<'MentorSession'> | number;
      booked?: IntFilter<'MentorSession'> | number;
      meetingUrl?: StringNullableFilter<'MentorSession'> | string | null;
      createdAt?: DateTimeFilter<'MentorSession'> | Date | string;
      mentor?: XOR<MentorRelationFilter, MentorWhereInput>;
    },
    'id'
  >;

  export type MentorSessionOrderByWithAggregationInput = {
    id?: SortOrder;
    mentorId?: SortOrder;
    title?: SortOrderInput | SortOrder;
    startsAt?: SortOrder;
    endsAt?: SortOrder;
    capacity?: SortOrder;
    booked?: SortOrder;
    meetingUrl?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    _count?: MentorSessionCountOrderByAggregateInput;
    _avg?: MentorSessionAvgOrderByAggregateInput;
    _max?: MentorSessionMaxOrderByAggregateInput;
    _min?: MentorSessionMinOrderByAggregateInput;
    _sum?: MentorSessionSumOrderByAggregateInput;
  };

  export type MentorSessionScalarWhereWithAggregatesInput = {
    AND?:
      | MentorSessionScalarWhereWithAggregatesInput
      | MentorSessionScalarWhereWithAggregatesInput[];
    OR?: MentorSessionScalarWhereWithAggregatesInput[];
    NOT?:
      | MentorSessionScalarWhereWithAggregatesInput
      | MentorSessionScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'MentorSession'> | string;
    mentorId?: StringWithAggregatesFilter<'MentorSession'> | string;
    title?: StringNullableWithAggregatesFilter<'MentorSession'> | string | null;
    startsAt?: DateTimeWithAggregatesFilter<'MentorSession'> | Date | string;
    endsAt?: DateTimeWithAggregatesFilter<'MentorSession'> | Date | string;
    capacity?: IntWithAggregatesFilter<'MentorSession'> | number;
    booked?: IntWithAggregatesFilter<'MentorSession'> | number;
    meetingUrl?: StringNullableWithAggregatesFilter<'MentorSession'> | string | null;
    createdAt?: DateTimeWithAggregatesFilter<'MentorSession'> | Date | string;
  };

  export type JudgeWhereInput = {
    AND?: JudgeWhereInput | JudgeWhereInput[];
    OR?: JudgeWhereInput[];
    NOT?: JudgeWhereInput | JudgeWhereInput[];
    id?: StringFilter<'Judge'> | string;
    userId?: StringFilter<'Judge'> | string;
    hackathonId?: StringFilter<'Judge'> | string;
    bio?: StringNullableFilter<'Judge'> | string | null;
    createdAt?: DateTimeFilter<'Judge'> | Date | string;
    user?: XOR<UserRelationFilter, UserWhereInput>;
    hackathon?: XOR<HackathonRelationFilter, HackathonWhereInput>;
    scores?: ScoreListRelationFilter;
  };

  export type JudgeOrderByWithRelationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    hackathonId?: SortOrder;
    bio?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    user?: UserOrderByWithRelationInput;
    hackathon?: HackathonOrderByWithRelationInput;
    scores?: ScoreOrderByRelationAggregateInput;
  };

  export type JudgeWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      userId_hackathonId?: JudgeUserIdHackathonIdCompoundUniqueInput;
      AND?: JudgeWhereInput | JudgeWhereInput[];
      OR?: JudgeWhereInput[];
      NOT?: JudgeWhereInput | JudgeWhereInput[];
      userId?: StringFilter<'Judge'> | string;
      hackathonId?: StringFilter<'Judge'> | string;
      bio?: StringNullableFilter<'Judge'> | string | null;
      createdAt?: DateTimeFilter<'Judge'> | Date | string;
      user?: XOR<UserRelationFilter, UserWhereInput>;
      hackathon?: XOR<HackathonRelationFilter, HackathonWhereInput>;
      scores?: ScoreListRelationFilter;
    },
    'id' | 'userId_hackathonId'
  >;

  export type JudgeOrderByWithAggregationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    hackathonId?: SortOrder;
    bio?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    _count?: JudgeCountOrderByAggregateInput;
    _max?: JudgeMaxOrderByAggregateInput;
    _min?: JudgeMinOrderByAggregateInput;
  };

  export type JudgeScalarWhereWithAggregatesInput = {
    AND?: JudgeScalarWhereWithAggregatesInput | JudgeScalarWhereWithAggregatesInput[];
    OR?: JudgeScalarWhereWithAggregatesInput[];
    NOT?: JudgeScalarWhereWithAggregatesInput | JudgeScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Judge'> | string;
    userId?: StringWithAggregatesFilter<'Judge'> | string;
    hackathonId?: StringWithAggregatesFilter<'Judge'> | string;
    bio?: StringNullableWithAggregatesFilter<'Judge'> | string | null;
    createdAt?: DateTimeWithAggregatesFilter<'Judge'> | Date | string;
  };

  export type CriteriaWhereInput = {
    AND?: CriteriaWhereInput | CriteriaWhereInput[];
    OR?: CriteriaWhereInput[];
    NOT?: CriteriaWhereInput | CriteriaWhereInput[];
    id?: StringFilter<'Criteria'> | string;
    hackathonId?: StringFilter<'Criteria'> | string;
    name?: StringFilter<'Criteria'> | string;
    description?: StringNullableFilter<'Criteria'> | string | null;
    maxScore?: IntFilter<'Criteria'> | number;
    weight?: DecimalFilter<'Criteria'> | Decimal | DecimalJsLike | number | string;
    order?: IntFilter<'Criteria'> | number;
    hackathon?: XOR<HackathonRelationFilter, HackathonWhereInput>;
    scores?: ScoreListRelationFilter;
  };

  export type CriteriaOrderByWithRelationInput = {
    id?: SortOrder;
    hackathonId?: SortOrder;
    name?: SortOrder;
    description?: SortOrderInput | SortOrder;
    maxScore?: SortOrder;
    weight?: SortOrder;
    order?: SortOrder;
    hackathon?: HackathonOrderByWithRelationInput;
    scores?: ScoreOrderByRelationAggregateInput;
  };

  export type CriteriaWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: CriteriaWhereInput | CriteriaWhereInput[];
      OR?: CriteriaWhereInput[];
      NOT?: CriteriaWhereInput | CriteriaWhereInput[];
      hackathonId?: StringFilter<'Criteria'> | string;
      name?: StringFilter<'Criteria'> | string;
      description?: StringNullableFilter<'Criteria'> | string | null;
      maxScore?: IntFilter<'Criteria'> | number;
      weight?: DecimalFilter<'Criteria'> | Decimal | DecimalJsLike | number | string;
      order?: IntFilter<'Criteria'> | number;
      hackathon?: XOR<HackathonRelationFilter, HackathonWhereInput>;
      scores?: ScoreListRelationFilter;
    },
    'id'
  >;

  export type CriteriaOrderByWithAggregationInput = {
    id?: SortOrder;
    hackathonId?: SortOrder;
    name?: SortOrder;
    description?: SortOrderInput | SortOrder;
    maxScore?: SortOrder;
    weight?: SortOrder;
    order?: SortOrder;
    _count?: CriteriaCountOrderByAggregateInput;
    _avg?: CriteriaAvgOrderByAggregateInput;
    _max?: CriteriaMaxOrderByAggregateInput;
    _min?: CriteriaMinOrderByAggregateInput;
    _sum?: CriteriaSumOrderByAggregateInput;
  };

  export type CriteriaScalarWhereWithAggregatesInput = {
    AND?: CriteriaScalarWhereWithAggregatesInput | CriteriaScalarWhereWithAggregatesInput[];
    OR?: CriteriaScalarWhereWithAggregatesInput[];
    NOT?: CriteriaScalarWhereWithAggregatesInput | CriteriaScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Criteria'> | string;
    hackathonId?: StringWithAggregatesFilter<'Criteria'> | string;
    name?: StringWithAggregatesFilter<'Criteria'> | string;
    description?: StringNullableWithAggregatesFilter<'Criteria'> | string | null;
    maxScore?: IntWithAggregatesFilter<'Criteria'> | number;
    weight?: DecimalWithAggregatesFilter<'Criteria'> | Decimal | DecimalJsLike | number | string;
    order?: IntWithAggregatesFilter<'Criteria'> | number;
  };

  export type SubmissionWhereInput = {
    AND?: SubmissionWhereInput | SubmissionWhereInput[];
    OR?: SubmissionWhereInput[];
    NOT?: SubmissionWhereInput | SubmissionWhereInput[];
    id?: StringFilter<'Submission'> | string;
    hackathonId?: StringFilter<'Submission'> | string;
    teamId?: StringFilter<'Submission'> | string;
    trackId?: StringNullableFilter<'Submission'> | string | null;
    title?: StringFilter<'Submission'> | string;
    abstract?: StringFilter<'Submission'> | string;
    repoUrl?: StringNullableFilter<'Submission'> | string | null;
    demoUrl?: StringNullableFilter<'Submission'> | string | null;
    videoUrl?: StringNullableFilter<'Submission'> | string | null;
    files?: StringNullableListFilter<'Submission'>;
    submittedAt?: DateTimeNullableFilter<'Submission'> | Date | string | null;
    finalizedAt?: DateTimeNullableFilter<'Submission'> | Date | string | null;
    status?: EnumSubmissionStatusFilter<'Submission'> | $Enums.SubmissionStatus;
    scoreAggregate?:
      | DecimalNullableFilter<'Submission'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    rank?: IntNullableFilter<'Submission'> | number | null;
    createdAt?: DateTimeFilter<'Submission'> | Date | string;
    updatedAt?: DateTimeFilter<'Submission'> | Date | string;
    hackathon?: XOR<HackathonRelationFilter, HackathonWhereInput>;
    team?: XOR<TeamRelationFilter, TeamWhereInput>;
    track?: XOR<TrackNullableRelationFilter, TrackWhereInput> | null;
    scores?: ScoreListRelationFilter;
  };

  export type SubmissionOrderByWithRelationInput = {
    id?: SortOrder;
    hackathonId?: SortOrder;
    teamId?: SortOrder;
    trackId?: SortOrderInput | SortOrder;
    title?: SortOrder;
    abstract?: SortOrder;
    repoUrl?: SortOrderInput | SortOrder;
    demoUrl?: SortOrderInput | SortOrder;
    videoUrl?: SortOrderInput | SortOrder;
    files?: SortOrder;
    submittedAt?: SortOrderInput | SortOrder;
    finalizedAt?: SortOrderInput | SortOrder;
    status?: SortOrder;
    scoreAggregate?: SortOrderInput | SortOrder;
    rank?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    hackathon?: HackathonOrderByWithRelationInput;
    team?: TeamOrderByWithRelationInput;
    track?: TrackOrderByWithRelationInput;
    scores?: ScoreOrderByRelationAggregateInput;
  };

  export type SubmissionWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: SubmissionWhereInput | SubmissionWhereInput[];
      OR?: SubmissionWhereInput[];
      NOT?: SubmissionWhereInput | SubmissionWhereInput[];
      hackathonId?: StringFilter<'Submission'> | string;
      teamId?: StringFilter<'Submission'> | string;
      trackId?: StringNullableFilter<'Submission'> | string | null;
      title?: StringFilter<'Submission'> | string;
      abstract?: StringFilter<'Submission'> | string;
      repoUrl?: StringNullableFilter<'Submission'> | string | null;
      demoUrl?: StringNullableFilter<'Submission'> | string | null;
      videoUrl?: StringNullableFilter<'Submission'> | string | null;
      files?: StringNullableListFilter<'Submission'>;
      submittedAt?: DateTimeNullableFilter<'Submission'> | Date | string | null;
      finalizedAt?: DateTimeNullableFilter<'Submission'> | Date | string | null;
      status?: EnumSubmissionStatusFilter<'Submission'> | $Enums.SubmissionStatus;
      scoreAggregate?:
        | DecimalNullableFilter<'Submission'>
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      rank?: IntNullableFilter<'Submission'> | number | null;
      createdAt?: DateTimeFilter<'Submission'> | Date | string;
      updatedAt?: DateTimeFilter<'Submission'> | Date | string;
      hackathon?: XOR<HackathonRelationFilter, HackathonWhereInput>;
      team?: XOR<TeamRelationFilter, TeamWhereInput>;
      track?: XOR<TrackNullableRelationFilter, TrackWhereInput> | null;
      scores?: ScoreListRelationFilter;
    },
    'id'
  >;

  export type SubmissionOrderByWithAggregationInput = {
    id?: SortOrder;
    hackathonId?: SortOrder;
    teamId?: SortOrder;
    trackId?: SortOrderInput | SortOrder;
    title?: SortOrder;
    abstract?: SortOrder;
    repoUrl?: SortOrderInput | SortOrder;
    demoUrl?: SortOrderInput | SortOrder;
    videoUrl?: SortOrderInput | SortOrder;
    files?: SortOrder;
    submittedAt?: SortOrderInput | SortOrder;
    finalizedAt?: SortOrderInput | SortOrder;
    status?: SortOrder;
    scoreAggregate?: SortOrderInput | SortOrder;
    rank?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: SubmissionCountOrderByAggregateInput;
    _avg?: SubmissionAvgOrderByAggregateInput;
    _max?: SubmissionMaxOrderByAggregateInput;
    _min?: SubmissionMinOrderByAggregateInput;
    _sum?: SubmissionSumOrderByAggregateInput;
  };

  export type SubmissionScalarWhereWithAggregatesInput = {
    AND?: SubmissionScalarWhereWithAggregatesInput | SubmissionScalarWhereWithAggregatesInput[];
    OR?: SubmissionScalarWhereWithAggregatesInput[];
    NOT?: SubmissionScalarWhereWithAggregatesInput | SubmissionScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Submission'> | string;
    hackathonId?: StringWithAggregatesFilter<'Submission'> | string;
    teamId?: StringWithAggregatesFilter<'Submission'> | string;
    trackId?: StringNullableWithAggregatesFilter<'Submission'> | string | null;
    title?: StringWithAggregatesFilter<'Submission'> | string;
    abstract?: StringWithAggregatesFilter<'Submission'> | string;
    repoUrl?: StringNullableWithAggregatesFilter<'Submission'> | string | null;
    demoUrl?: StringNullableWithAggregatesFilter<'Submission'> | string | null;
    videoUrl?: StringNullableWithAggregatesFilter<'Submission'> | string | null;
    files?: StringNullableListFilter<'Submission'>;
    submittedAt?: DateTimeNullableWithAggregatesFilter<'Submission'> | Date | string | null;
    finalizedAt?: DateTimeNullableWithAggregatesFilter<'Submission'> | Date | string | null;
    status?: EnumSubmissionStatusWithAggregatesFilter<'Submission'> | $Enums.SubmissionStatus;
    scoreAggregate?:
      | DecimalNullableWithAggregatesFilter<'Submission'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    rank?: IntNullableWithAggregatesFilter<'Submission'> | number | null;
    createdAt?: DateTimeWithAggregatesFilter<'Submission'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'Submission'> | Date | string;
  };

  export type ScoreWhereInput = {
    AND?: ScoreWhereInput | ScoreWhereInput[];
    OR?: ScoreWhereInput[];
    NOT?: ScoreWhereInput | ScoreWhereInput[];
    id?: StringFilter<'Score'> | string;
    submissionId?: StringFilter<'Score'> | string;
    judgeId?: StringFilter<'Score'> | string;
    criterionId?: StringFilter<'Score'> | string;
    score?: IntFilter<'Score'> | number;
    feedback?: StringNullableFilter<'Score'> | string | null;
    createdAt?: DateTimeFilter<'Score'> | Date | string;
    updatedAt?: DateTimeFilter<'Score'> | Date | string;
    submission?: XOR<SubmissionRelationFilter, SubmissionWhereInput>;
    judge?: XOR<JudgeRelationFilter, JudgeWhereInput>;
    criterion?: XOR<CriteriaRelationFilter, CriteriaWhereInput>;
  };

  export type ScoreOrderByWithRelationInput = {
    id?: SortOrder;
    submissionId?: SortOrder;
    judgeId?: SortOrder;
    criterionId?: SortOrder;
    score?: SortOrder;
    feedback?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    submission?: SubmissionOrderByWithRelationInput;
    judge?: JudgeOrderByWithRelationInput;
    criterion?: CriteriaOrderByWithRelationInput;
  };

  export type ScoreWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      submissionId_judgeId_criterionId?: ScoreSubmissionIdJudgeIdCriterionIdCompoundUniqueInput;
      AND?: ScoreWhereInput | ScoreWhereInput[];
      OR?: ScoreWhereInput[];
      NOT?: ScoreWhereInput | ScoreWhereInput[];
      submissionId?: StringFilter<'Score'> | string;
      judgeId?: StringFilter<'Score'> | string;
      criterionId?: StringFilter<'Score'> | string;
      score?: IntFilter<'Score'> | number;
      feedback?: StringNullableFilter<'Score'> | string | null;
      createdAt?: DateTimeFilter<'Score'> | Date | string;
      updatedAt?: DateTimeFilter<'Score'> | Date | string;
      submission?: XOR<SubmissionRelationFilter, SubmissionWhereInput>;
      judge?: XOR<JudgeRelationFilter, JudgeWhereInput>;
      criterion?: XOR<CriteriaRelationFilter, CriteriaWhereInput>;
    },
    'id' | 'submissionId_judgeId_criterionId'
  >;

  export type ScoreOrderByWithAggregationInput = {
    id?: SortOrder;
    submissionId?: SortOrder;
    judgeId?: SortOrder;
    criterionId?: SortOrder;
    score?: SortOrder;
    feedback?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: ScoreCountOrderByAggregateInput;
    _avg?: ScoreAvgOrderByAggregateInput;
    _max?: ScoreMaxOrderByAggregateInput;
    _min?: ScoreMinOrderByAggregateInput;
    _sum?: ScoreSumOrderByAggregateInput;
  };

  export type ScoreScalarWhereWithAggregatesInput = {
    AND?: ScoreScalarWhereWithAggregatesInput | ScoreScalarWhereWithAggregatesInput[];
    OR?: ScoreScalarWhereWithAggregatesInput[];
    NOT?: ScoreScalarWhereWithAggregatesInput | ScoreScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Score'> | string;
    submissionId?: StringWithAggregatesFilter<'Score'> | string;
    judgeId?: StringWithAggregatesFilter<'Score'> | string;
    criterionId?: StringWithAggregatesFilter<'Score'> | string;
    score?: IntWithAggregatesFilter<'Score'> | number;
    feedback?: StringNullableWithAggregatesFilter<'Score'> | string | null;
    createdAt?: DateTimeWithAggregatesFilter<'Score'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'Score'> | Date | string;
  };

  export type ChallengeWhereInput = {
    AND?: ChallengeWhereInput | ChallengeWhereInput[];
    OR?: ChallengeWhereInput[];
    NOT?: ChallengeWhereInput | ChallengeWhereInput[];
    id?: StringFilter<'Challenge'> | string;
    slug?: StringFilter<'Challenge'> | string;
    title?: StringFilter<'Challenge'> | string;
    problemStatement?: StringFilter<'Challenge'> | string;
    ownerId?: StringFilter<'Challenge'> | string;
    ownerOrg?: StringNullableFilter<'Challenge'> | string | null;
    rewardType?: EnumRewardTypeNullableFilter<'Challenge'> | $Enums.RewardType | null;
    rewardValue?: StringNullableFilter<'Challenge'> | string | null;
    categories?: StringNullableListFilter<'Challenge'>;
    skills?: StringNullableListFilter<'Challenge'>;
    attachments?: StringNullableListFilter<'Challenge'>;
    status?: EnumChallengeStatusFilter<'Challenge'> | $Enums.ChallengeStatus;
    visibility?: EnumChallengeVisibilityFilter<'Challenge'> | $Enums.ChallengeVisibility;
    deadlineAt?: DateTimeNullableFilter<'Challenge'> | Date | string | null;
    createdAt?: DateTimeFilter<'Challenge'> | Date | string;
    updatedAt?: DateTimeFilter<'Challenge'> | Date | string;
    owner?: XOR<UserRelationFilter, UserWhereInput>;
    submissions?: ChallengeSubmissionListRelationFilter;
  };

  export type ChallengeOrderByWithRelationInput = {
    id?: SortOrder;
    slug?: SortOrder;
    title?: SortOrder;
    problemStatement?: SortOrder;
    ownerId?: SortOrder;
    ownerOrg?: SortOrderInput | SortOrder;
    rewardType?: SortOrderInput | SortOrder;
    rewardValue?: SortOrderInput | SortOrder;
    categories?: SortOrder;
    skills?: SortOrder;
    attachments?: SortOrder;
    status?: SortOrder;
    visibility?: SortOrder;
    deadlineAt?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    owner?: UserOrderByWithRelationInput;
    submissions?: ChallengeSubmissionOrderByRelationAggregateInput;
  };

  export type ChallengeWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      slug?: string;
      AND?: ChallengeWhereInput | ChallengeWhereInput[];
      OR?: ChallengeWhereInput[];
      NOT?: ChallengeWhereInput | ChallengeWhereInput[];
      title?: StringFilter<'Challenge'> | string;
      problemStatement?: StringFilter<'Challenge'> | string;
      ownerId?: StringFilter<'Challenge'> | string;
      ownerOrg?: StringNullableFilter<'Challenge'> | string | null;
      rewardType?: EnumRewardTypeNullableFilter<'Challenge'> | $Enums.RewardType | null;
      rewardValue?: StringNullableFilter<'Challenge'> | string | null;
      categories?: StringNullableListFilter<'Challenge'>;
      skills?: StringNullableListFilter<'Challenge'>;
      attachments?: StringNullableListFilter<'Challenge'>;
      status?: EnumChallengeStatusFilter<'Challenge'> | $Enums.ChallengeStatus;
      visibility?: EnumChallengeVisibilityFilter<'Challenge'> | $Enums.ChallengeVisibility;
      deadlineAt?: DateTimeNullableFilter<'Challenge'> | Date | string | null;
      createdAt?: DateTimeFilter<'Challenge'> | Date | string;
      updatedAt?: DateTimeFilter<'Challenge'> | Date | string;
      owner?: XOR<UserRelationFilter, UserWhereInput>;
      submissions?: ChallengeSubmissionListRelationFilter;
    },
    'id' | 'slug'
  >;

  export type ChallengeOrderByWithAggregationInput = {
    id?: SortOrder;
    slug?: SortOrder;
    title?: SortOrder;
    problemStatement?: SortOrder;
    ownerId?: SortOrder;
    ownerOrg?: SortOrderInput | SortOrder;
    rewardType?: SortOrderInput | SortOrder;
    rewardValue?: SortOrderInput | SortOrder;
    categories?: SortOrder;
    skills?: SortOrder;
    attachments?: SortOrder;
    status?: SortOrder;
    visibility?: SortOrder;
    deadlineAt?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: ChallengeCountOrderByAggregateInput;
    _max?: ChallengeMaxOrderByAggregateInput;
    _min?: ChallengeMinOrderByAggregateInput;
  };

  export type ChallengeScalarWhereWithAggregatesInput = {
    AND?: ChallengeScalarWhereWithAggregatesInput | ChallengeScalarWhereWithAggregatesInput[];
    OR?: ChallengeScalarWhereWithAggregatesInput[];
    NOT?: ChallengeScalarWhereWithAggregatesInput | ChallengeScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Challenge'> | string;
    slug?: StringWithAggregatesFilter<'Challenge'> | string;
    title?: StringWithAggregatesFilter<'Challenge'> | string;
    problemStatement?: StringWithAggregatesFilter<'Challenge'> | string;
    ownerId?: StringWithAggregatesFilter<'Challenge'> | string;
    ownerOrg?: StringNullableWithAggregatesFilter<'Challenge'> | string | null;
    rewardType?: EnumRewardTypeNullableWithAggregatesFilter<'Challenge'> | $Enums.RewardType | null;
    rewardValue?: StringNullableWithAggregatesFilter<'Challenge'> | string | null;
    categories?: StringNullableListFilter<'Challenge'>;
    skills?: StringNullableListFilter<'Challenge'>;
    attachments?: StringNullableListFilter<'Challenge'>;
    status?: EnumChallengeStatusWithAggregatesFilter<'Challenge'> | $Enums.ChallengeStatus;
    visibility?:
      | EnumChallengeVisibilityWithAggregatesFilter<'Challenge'>
      | $Enums.ChallengeVisibility;
    deadlineAt?: DateTimeNullableWithAggregatesFilter<'Challenge'> | Date | string | null;
    createdAt?: DateTimeWithAggregatesFilter<'Challenge'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'Challenge'> | Date | string;
  };

  export type ChallengeSubmissionWhereInput = {
    AND?: ChallengeSubmissionWhereInput | ChallengeSubmissionWhereInput[];
    OR?: ChallengeSubmissionWhereInput[];
    NOT?: ChallengeSubmissionWhereInput | ChallengeSubmissionWhereInput[];
    id?: StringFilter<'ChallengeSubmission'> | string;
    challengeId?: StringFilter<'ChallengeSubmission'> | string;
    userId?: StringNullableFilter<'ChallengeSubmission'> | string | null;
    teamId?: StringNullableFilter<'ChallengeSubmission'> | string | null;
    title?: StringFilter<'ChallengeSubmission'> | string;
    repoUrl?: StringNullableFilter<'ChallengeSubmission'> | string | null;
    content?: StringFilter<'ChallengeSubmission'> | string;
    files?: StringNullableListFilter<'ChallengeSubmission'>;
    status?:
      | EnumChallengeSubmissionStatusFilter<'ChallengeSubmission'>
      | $Enums.ChallengeSubmissionStatus;
    score?:
      | DecimalNullableFilter<'ChallengeSubmission'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    feedback?: StringNullableFilter<'ChallengeSubmission'> | string | null;
    createdAt?: DateTimeFilter<'ChallengeSubmission'> | Date | string;
    updatedAt?: DateTimeFilter<'ChallengeSubmission'> | Date | string;
    challenge?: XOR<ChallengeRelationFilter, ChallengeWhereInput>;
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null;
    team?: XOR<TeamNullableRelationFilter, TeamWhereInput> | null;
  };

  export type ChallengeSubmissionOrderByWithRelationInput = {
    id?: SortOrder;
    challengeId?: SortOrder;
    userId?: SortOrderInput | SortOrder;
    teamId?: SortOrderInput | SortOrder;
    title?: SortOrder;
    repoUrl?: SortOrderInput | SortOrder;
    content?: SortOrder;
    files?: SortOrder;
    status?: SortOrder;
    score?: SortOrderInput | SortOrder;
    feedback?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    challenge?: ChallengeOrderByWithRelationInput;
    user?: UserOrderByWithRelationInput;
    team?: TeamOrderByWithRelationInput;
  };

  export type ChallengeSubmissionWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: ChallengeSubmissionWhereInput | ChallengeSubmissionWhereInput[];
      OR?: ChallengeSubmissionWhereInput[];
      NOT?: ChallengeSubmissionWhereInput | ChallengeSubmissionWhereInput[];
      challengeId?: StringFilter<'ChallengeSubmission'> | string;
      userId?: StringNullableFilter<'ChallengeSubmission'> | string | null;
      teamId?: StringNullableFilter<'ChallengeSubmission'> | string | null;
      title?: StringFilter<'ChallengeSubmission'> | string;
      repoUrl?: StringNullableFilter<'ChallengeSubmission'> | string | null;
      content?: StringFilter<'ChallengeSubmission'> | string;
      files?: StringNullableListFilter<'ChallengeSubmission'>;
      status?:
        | EnumChallengeSubmissionStatusFilter<'ChallengeSubmission'>
        | $Enums.ChallengeSubmissionStatus;
      score?:
        | DecimalNullableFilter<'ChallengeSubmission'>
        | Decimal
        | DecimalJsLike
        | number
        | string
        | null;
      feedback?: StringNullableFilter<'ChallengeSubmission'> | string | null;
      createdAt?: DateTimeFilter<'ChallengeSubmission'> | Date | string;
      updatedAt?: DateTimeFilter<'ChallengeSubmission'> | Date | string;
      challenge?: XOR<ChallengeRelationFilter, ChallengeWhereInput>;
      user?: XOR<UserNullableRelationFilter, UserWhereInput> | null;
      team?: XOR<TeamNullableRelationFilter, TeamWhereInput> | null;
    },
    'id'
  >;

  export type ChallengeSubmissionOrderByWithAggregationInput = {
    id?: SortOrder;
    challengeId?: SortOrder;
    userId?: SortOrderInput | SortOrder;
    teamId?: SortOrderInput | SortOrder;
    title?: SortOrder;
    repoUrl?: SortOrderInput | SortOrder;
    content?: SortOrder;
    files?: SortOrder;
    status?: SortOrder;
    score?: SortOrderInput | SortOrder;
    feedback?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: ChallengeSubmissionCountOrderByAggregateInput;
    _avg?: ChallengeSubmissionAvgOrderByAggregateInput;
    _max?: ChallengeSubmissionMaxOrderByAggregateInput;
    _min?: ChallengeSubmissionMinOrderByAggregateInput;
    _sum?: ChallengeSubmissionSumOrderByAggregateInput;
  };

  export type ChallengeSubmissionScalarWhereWithAggregatesInput = {
    AND?:
      | ChallengeSubmissionScalarWhereWithAggregatesInput
      | ChallengeSubmissionScalarWhereWithAggregatesInput[];
    OR?: ChallengeSubmissionScalarWhereWithAggregatesInput[];
    NOT?:
      | ChallengeSubmissionScalarWhereWithAggregatesInput
      | ChallengeSubmissionScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'ChallengeSubmission'> | string;
    challengeId?: StringWithAggregatesFilter<'ChallengeSubmission'> | string;
    userId?: StringNullableWithAggregatesFilter<'ChallengeSubmission'> | string | null;
    teamId?: StringNullableWithAggregatesFilter<'ChallengeSubmission'> | string | null;
    title?: StringWithAggregatesFilter<'ChallengeSubmission'> | string;
    repoUrl?: StringNullableWithAggregatesFilter<'ChallengeSubmission'> | string | null;
    content?: StringWithAggregatesFilter<'ChallengeSubmission'> | string;
    files?: StringNullableListFilter<'ChallengeSubmission'>;
    status?:
      | EnumChallengeSubmissionStatusWithAggregatesFilter<'ChallengeSubmission'>
      | $Enums.ChallengeSubmissionStatus;
    score?:
      | DecimalNullableWithAggregatesFilter<'ChallengeSubmission'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    feedback?: StringNullableWithAggregatesFilter<'ChallengeSubmission'> | string | null;
    createdAt?: DateTimeWithAggregatesFilter<'ChallengeSubmission'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'ChallengeSubmission'> | Date | string;
  };

  export type AnnouncementWhereInput = {
    AND?: AnnouncementWhereInput | AnnouncementWhereInput[];
    OR?: AnnouncementWhereInput[];
    NOT?: AnnouncementWhereInput | AnnouncementWhereInput[];
    id?: StringFilter<'Announcement'> | string;
    scope?: EnumAnnouncementScopeFilter<'Announcement'> | $Enums.AnnouncementScope;
    scopeId?: StringNullableFilter<'Announcement'> | string | null;
    title?: StringFilter<'Announcement'> | string;
    body?: StringFilter<'Announcement'> | string;
    pinned?: BoolFilter<'Announcement'> | boolean;
    publishedAt?: DateTimeNullableFilter<'Announcement'> | Date | string | null;
    createdAt?: DateTimeFilter<'Announcement'> | Date | string;
    updatedAt?: DateTimeFilter<'Announcement'> | Date | string;
    hackathon?: XOR<HackathonNullableRelationFilter, HackathonWhereInput> | null;
  };

  export type AnnouncementOrderByWithRelationInput = {
    id?: SortOrder;
    scope?: SortOrder;
    scopeId?: SortOrderInput | SortOrder;
    title?: SortOrder;
    body?: SortOrder;
    pinned?: SortOrder;
    publishedAt?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    hackathon?: HackathonOrderByWithRelationInput;
  };

  export type AnnouncementWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: AnnouncementWhereInput | AnnouncementWhereInput[];
      OR?: AnnouncementWhereInput[];
      NOT?: AnnouncementWhereInput | AnnouncementWhereInput[];
      scope?: EnumAnnouncementScopeFilter<'Announcement'> | $Enums.AnnouncementScope;
      scopeId?: StringNullableFilter<'Announcement'> | string | null;
      title?: StringFilter<'Announcement'> | string;
      body?: StringFilter<'Announcement'> | string;
      pinned?: BoolFilter<'Announcement'> | boolean;
      publishedAt?: DateTimeNullableFilter<'Announcement'> | Date | string | null;
      createdAt?: DateTimeFilter<'Announcement'> | Date | string;
      updatedAt?: DateTimeFilter<'Announcement'> | Date | string;
      hackathon?: XOR<HackathonNullableRelationFilter, HackathonWhereInput> | null;
    },
    'id'
  >;

  export type AnnouncementOrderByWithAggregationInput = {
    id?: SortOrder;
    scope?: SortOrder;
    scopeId?: SortOrderInput | SortOrder;
    title?: SortOrder;
    body?: SortOrder;
    pinned?: SortOrder;
    publishedAt?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: AnnouncementCountOrderByAggregateInput;
    _max?: AnnouncementMaxOrderByAggregateInput;
    _min?: AnnouncementMinOrderByAggregateInput;
  };

  export type AnnouncementScalarWhereWithAggregatesInput = {
    AND?: AnnouncementScalarWhereWithAggregatesInput | AnnouncementScalarWhereWithAggregatesInput[];
    OR?: AnnouncementScalarWhereWithAggregatesInput[];
    NOT?: AnnouncementScalarWhereWithAggregatesInput | AnnouncementScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Announcement'> | string;
    scope?: EnumAnnouncementScopeWithAggregatesFilter<'Announcement'> | $Enums.AnnouncementScope;
    scopeId?: StringNullableWithAggregatesFilter<'Announcement'> | string | null;
    title?: StringWithAggregatesFilter<'Announcement'> | string;
    body?: StringWithAggregatesFilter<'Announcement'> | string;
    pinned?: BoolWithAggregatesFilter<'Announcement'> | boolean;
    publishedAt?: DateTimeNullableWithAggregatesFilter<'Announcement'> | Date | string | null;
    createdAt?: DateTimeWithAggregatesFilter<'Announcement'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'Announcement'> | Date | string;
  };

  export type CommentThreadWhereInput = {
    AND?: CommentThreadWhereInput | CommentThreadWhereInput[];
    OR?: CommentThreadWhereInput[];
    NOT?: CommentThreadWhereInput | CommentThreadWhereInput[];
    id?: StringFilter<'CommentThread'> | string;
    entityType?: EnumCommentEntityTypeFilter<'CommentThread'> | $Enums.CommentEntityType;
    entityId?: StringFilter<'CommentThread'> | string;
    createdAt?: DateTimeFilter<'CommentThread'> | Date | string;
    comments?: CommentListRelationFilter;
  };

  export type CommentThreadOrderByWithRelationInput = {
    id?: SortOrder;
    entityType?: SortOrder;
    entityId?: SortOrder;
    createdAt?: SortOrder;
    comments?: CommentOrderByRelationAggregateInput;
  };

  export type CommentThreadWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      entityType_entityId?: CommentThreadEntityTypeEntityIdCompoundUniqueInput;
      AND?: CommentThreadWhereInput | CommentThreadWhereInput[];
      OR?: CommentThreadWhereInput[];
      NOT?: CommentThreadWhereInput | CommentThreadWhereInput[];
      entityType?: EnumCommentEntityTypeFilter<'CommentThread'> | $Enums.CommentEntityType;
      entityId?: StringFilter<'CommentThread'> | string;
      createdAt?: DateTimeFilter<'CommentThread'> | Date | string;
      comments?: CommentListRelationFilter;
    },
    'id' | 'entityType_entityId'
  >;

  export type CommentThreadOrderByWithAggregationInput = {
    id?: SortOrder;
    entityType?: SortOrder;
    entityId?: SortOrder;
    createdAt?: SortOrder;
    _count?: CommentThreadCountOrderByAggregateInput;
    _max?: CommentThreadMaxOrderByAggregateInput;
    _min?: CommentThreadMinOrderByAggregateInput;
  };

  export type CommentThreadScalarWhereWithAggregatesInput = {
    AND?:
      | CommentThreadScalarWhereWithAggregatesInput
      | CommentThreadScalarWhereWithAggregatesInput[];
    OR?: CommentThreadScalarWhereWithAggregatesInput[];
    NOT?:
      | CommentThreadScalarWhereWithAggregatesInput
      | CommentThreadScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'CommentThread'> | string;
    entityType?:
      | EnumCommentEntityTypeWithAggregatesFilter<'CommentThread'>
      | $Enums.CommentEntityType;
    entityId?: StringWithAggregatesFilter<'CommentThread'> | string;
    createdAt?: DateTimeWithAggregatesFilter<'CommentThread'> | Date | string;
  };

  export type CommentWhereInput = {
    AND?: CommentWhereInput | CommentWhereInput[];
    OR?: CommentWhereInput[];
    NOT?: CommentWhereInput | CommentWhereInput[];
    id?: StringFilter<'Comment'> | string;
    threadId?: StringFilter<'Comment'> | string;
    authorId?: StringFilter<'Comment'> | string;
    parentId?: StringNullableFilter<'Comment'> | string | null;
    body?: StringFilter<'Comment'> | string;
    isFlagged?: BoolFilter<'Comment'> | boolean;
    createdAt?: DateTimeFilter<'Comment'> | Date | string;
    updatedAt?: DateTimeFilter<'Comment'> | Date | string;
    thread?: XOR<CommentThreadRelationFilter, CommentThreadWhereInput>;
    author?: XOR<UserRelationFilter, UserWhereInput>;
    parent?: XOR<CommentNullableRelationFilter, CommentWhereInput> | null;
    replies?: CommentListRelationFilter;
  };

  export type CommentOrderByWithRelationInput = {
    id?: SortOrder;
    threadId?: SortOrder;
    authorId?: SortOrder;
    parentId?: SortOrderInput | SortOrder;
    body?: SortOrder;
    isFlagged?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    thread?: CommentThreadOrderByWithRelationInput;
    author?: UserOrderByWithRelationInput;
    parent?: CommentOrderByWithRelationInput;
    replies?: CommentOrderByRelationAggregateInput;
  };

  export type CommentWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: CommentWhereInput | CommentWhereInput[];
      OR?: CommentWhereInput[];
      NOT?: CommentWhereInput | CommentWhereInput[];
      threadId?: StringFilter<'Comment'> | string;
      authorId?: StringFilter<'Comment'> | string;
      parentId?: StringNullableFilter<'Comment'> | string | null;
      body?: StringFilter<'Comment'> | string;
      isFlagged?: BoolFilter<'Comment'> | boolean;
      createdAt?: DateTimeFilter<'Comment'> | Date | string;
      updatedAt?: DateTimeFilter<'Comment'> | Date | string;
      thread?: XOR<CommentThreadRelationFilter, CommentThreadWhereInput>;
      author?: XOR<UserRelationFilter, UserWhereInput>;
      parent?: XOR<CommentNullableRelationFilter, CommentWhereInput> | null;
      replies?: CommentListRelationFilter;
    },
    'id'
  >;

  export type CommentOrderByWithAggregationInput = {
    id?: SortOrder;
    threadId?: SortOrder;
    authorId?: SortOrder;
    parentId?: SortOrderInput | SortOrder;
    body?: SortOrder;
    isFlagged?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: CommentCountOrderByAggregateInput;
    _max?: CommentMaxOrderByAggregateInput;
    _min?: CommentMinOrderByAggregateInput;
  };

  export type CommentScalarWhereWithAggregatesInput = {
    AND?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[];
    OR?: CommentScalarWhereWithAggregatesInput[];
    NOT?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Comment'> | string;
    threadId?: StringWithAggregatesFilter<'Comment'> | string;
    authorId?: StringWithAggregatesFilter<'Comment'> | string;
    parentId?: StringNullableWithAggregatesFilter<'Comment'> | string | null;
    body?: StringWithAggregatesFilter<'Comment'> | string;
    isFlagged?: BoolWithAggregatesFilter<'Comment'> | boolean;
    createdAt?: DateTimeWithAggregatesFilter<'Comment'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'Comment'> | Date | string;
  };

  export type GamificationProfileWhereInput = {
    AND?: GamificationProfileWhereInput | GamificationProfileWhereInput[];
    OR?: GamificationProfileWhereInput[];
    NOT?: GamificationProfileWhereInput | GamificationProfileWhereInput[];
    userId?: StringFilter<'GamificationProfile'> | string;
    xp?: IntFilter<'GamificationProfile'> | number;
    level?: IntFilter<'GamificationProfile'> | number;
    streakDays?: IntFilter<'GamificationProfile'> | number;
    vaultKeys?: IntFilter<'GamificationProfile'> | number;
    badges?: StringNullableListFilter<'GamificationProfile'>;
    lastActivityAt?: DateTimeNullableFilter<'GamificationProfile'> | Date | string | null;
    createdAt?: DateTimeFilter<'GamificationProfile'> | Date | string;
    updatedAt?: DateTimeFilter<'GamificationProfile'> | Date | string;
    user?: XOR<UserRelationFilter, UserWhereInput>;
  };

  export type GamificationProfileOrderByWithRelationInput = {
    userId?: SortOrder;
    xp?: SortOrder;
    level?: SortOrder;
    streakDays?: SortOrder;
    vaultKeys?: SortOrder;
    badges?: SortOrder;
    lastActivityAt?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    user?: UserOrderByWithRelationInput;
  };

  export type GamificationProfileWhereUniqueInput = Prisma.AtLeast<
    {
      userId?: string;
      AND?: GamificationProfileWhereInput | GamificationProfileWhereInput[];
      OR?: GamificationProfileWhereInput[];
      NOT?: GamificationProfileWhereInput | GamificationProfileWhereInput[];
      xp?: IntFilter<'GamificationProfile'> | number;
      level?: IntFilter<'GamificationProfile'> | number;
      streakDays?: IntFilter<'GamificationProfile'> | number;
      vaultKeys?: IntFilter<'GamificationProfile'> | number;
      badges?: StringNullableListFilter<'GamificationProfile'>;
      lastActivityAt?: DateTimeNullableFilter<'GamificationProfile'> | Date | string | null;
      createdAt?: DateTimeFilter<'GamificationProfile'> | Date | string;
      updatedAt?: DateTimeFilter<'GamificationProfile'> | Date | string;
      user?: XOR<UserRelationFilter, UserWhereInput>;
    },
    'userId'
  >;

  export type GamificationProfileOrderByWithAggregationInput = {
    userId?: SortOrder;
    xp?: SortOrder;
    level?: SortOrder;
    streakDays?: SortOrder;
    vaultKeys?: SortOrder;
    badges?: SortOrder;
    lastActivityAt?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: GamificationProfileCountOrderByAggregateInput;
    _avg?: GamificationProfileAvgOrderByAggregateInput;
    _max?: GamificationProfileMaxOrderByAggregateInput;
    _min?: GamificationProfileMinOrderByAggregateInput;
    _sum?: GamificationProfileSumOrderByAggregateInput;
  };

  export type GamificationProfileScalarWhereWithAggregatesInput = {
    AND?:
      | GamificationProfileScalarWhereWithAggregatesInput
      | GamificationProfileScalarWhereWithAggregatesInput[];
    OR?: GamificationProfileScalarWhereWithAggregatesInput[];
    NOT?:
      | GamificationProfileScalarWhereWithAggregatesInput
      | GamificationProfileScalarWhereWithAggregatesInput[];
    userId?: StringWithAggregatesFilter<'GamificationProfile'> | string;
    xp?: IntWithAggregatesFilter<'GamificationProfile'> | number;
    level?: IntWithAggregatesFilter<'GamificationProfile'> | number;
    streakDays?: IntWithAggregatesFilter<'GamificationProfile'> | number;
    vaultKeys?: IntWithAggregatesFilter<'GamificationProfile'> | number;
    badges?: StringNullableListFilter<'GamificationProfile'>;
    lastActivityAt?:
      | DateTimeNullableWithAggregatesFilter<'GamificationProfile'>
      | Date
      | string
      | null;
    createdAt?: DateTimeWithAggregatesFilter<'GamificationProfile'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'GamificationProfile'> | Date | string;
  };

  export type BadgeWhereInput = {
    AND?: BadgeWhereInput | BadgeWhereInput[];
    OR?: BadgeWhereInput[];
    NOT?: BadgeWhereInput | BadgeWhereInput[];
    id?: StringFilter<'Badge'> | string;
    slug?: StringFilter<'Badge'> | string;
    name?: StringFilter<'Badge'> | string;
    description?: StringFilter<'Badge'> | string;
    icon?: StringFilter<'Badge'> | string;
    xpRequired?: IntFilter<'Badge'> | number;
    rarity?: StringFilter<'Badge'> | string;
    createdAt?: DateTimeFilter<'Badge'> | Date | string;
  };

  export type BadgeOrderByWithRelationInput = {
    id?: SortOrder;
    slug?: SortOrder;
    name?: SortOrder;
    description?: SortOrder;
    icon?: SortOrder;
    xpRequired?: SortOrder;
    rarity?: SortOrder;
    createdAt?: SortOrder;
  };

  export type BadgeWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      slug?: string;
      AND?: BadgeWhereInput | BadgeWhereInput[];
      OR?: BadgeWhereInput[];
      NOT?: BadgeWhereInput | BadgeWhereInput[];
      name?: StringFilter<'Badge'> | string;
      description?: StringFilter<'Badge'> | string;
      icon?: StringFilter<'Badge'> | string;
      xpRequired?: IntFilter<'Badge'> | number;
      rarity?: StringFilter<'Badge'> | string;
      createdAt?: DateTimeFilter<'Badge'> | Date | string;
    },
    'id' | 'slug'
  >;

  export type BadgeOrderByWithAggregationInput = {
    id?: SortOrder;
    slug?: SortOrder;
    name?: SortOrder;
    description?: SortOrder;
    icon?: SortOrder;
    xpRequired?: SortOrder;
    rarity?: SortOrder;
    createdAt?: SortOrder;
    _count?: BadgeCountOrderByAggregateInput;
    _avg?: BadgeAvgOrderByAggregateInput;
    _max?: BadgeMaxOrderByAggregateInput;
    _min?: BadgeMinOrderByAggregateInput;
    _sum?: BadgeSumOrderByAggregateInput;
  };

  export type BadgeScalarWhereWithAggregatesInput = {
    AND?: BadgeScalarWhereWithAggregatesInput | BadgeScalarWhereWithAggregatesInput[];
    OR?: BadgeScalarWhereWithAggregatesInput[];
    NOT?: BadgeScalarWhereWithAggregatesInput | BadgeScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Badge'> | string;
    slug?: StringWithAggregatesFilter<'Badge'> | string;
    name?: StringWithAggregatesFilter<'Badge'> | string;
    description?: StringWithAggregatesFilter<'Badge'> | string;
    icon?: StringWithAggregatesFilter<'Badge'> | string;
    xpRequired?: IntWithAggregatesFilter<'Badge'> | number;
    rarity?: StringWithAggregatesFilter<'Badge'> | string;
    createdAt?: DateTimeWithAggregatesFilter<'Badge'> | Date | string;
  };

  export type XpEventWhereInput = {
    AND?: XpEventWhereInput | XpEventWhereInput[];
    OR?: XpEventWhereInput[];
    NOT?: XpEventWhereInput | XpEventWhereInput[];
    id?: StringFilter<'XpEvent'> | string;
    userId?: StringFilter<'XpEvent'> | string;
    eventType?: StringFilter<'XpEvent'> | string;
    points?: IntFilter<'XpEvent'> | number;
    refType?: StringNullableFilter<'XpEvent'> | string | null;
    refId?: StringNullableFilter<'XpEvent'> | string | null;
    metadata?: JsonNullableFilter<'XpEvent'>;
    createdAt?: DateTimeFilter<'XpEvent'> | Date | string;
    user?: XOR<UserRelationFilter, UserWhereInput>;
  };

  export type XpEventOrderByWithRelationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    eventType?: SortOrder;
    points?: SortOrder;
    refType?: SortOrderInput | SortOrder;
    refId?: SortOrderInput | SortOrder;
    metadata?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    user?: UserOrderByWithRelationInput;
  };

  export type XpEventWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: XpEventWhereInput | XpEventWhereInput[];
      OR?: XpEventWhereInput[];
      NOT?: XpEventWhereInput | XpEventWhereInput[];
      userId?: StringFilter<'XpEvent'> | string;
      eventType?: StringFilter<'XpEvent'> | string;
      points?: IntFilter<'XpEvent'> | number;
      refType?: StringNullableFilter<'XpEvent'> | string | null;
      refId?: StringNullableFilter<'XpEvent'> | string | null;
      metadata?: JsonNullableFilter<'XpEvent'>;
      createdAt?: DateTimeFilter<'XpEvent'> | Date | string;
      user?: XOR<UserRelationFilter, UserWhereInput>;
    },
    'id'
  >;

  export type XpEventOrderByWithAggregationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    eventType?: SortOrder;
    points?: SortOrder;
    refType?: SortOrderInput | SortOrder;
    refId?: SortOrderInput | SortOrder;
    metadata?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    _count?: XpEventCountOrderByAggregateInput;
    _avg?: XpEventAvgOrderByAggregateInput;
    _max?: XpEventMaxOrderByAggregateInput;
    _min?: XpEventMinOrderByAggregateInput;
    _sum?: XpEventSumOrderByAggregateInput;
  };

  export type XpEventScalarWhereWithAggregatesInput = {
    AND?: XpEventScalarWhereWithAggregatesInput | XpEventScalarWhereWithAggregatesInput[];
    OR?: XpEventScalarWhereWithAggregatesInput[];
    NOT?: XpEventScalarWhereWithAggregatesInput | XpEventScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'XpEvent'> | string;
    userId?: StringWithAggregatesFilter<'XpEvent'> | string;
    eventType?: StringWithAggregatesFilter<'XpEvent'> | string;
    points?: IntWithAggregatesFilter<'XpEvent'> | number;
    refType?: StringNullableWithAggregatesFilter<'XpEvent'> | string | null;
    refId?: StringNullableWithAggregatesFilter<'XpEvent'> | string | null;
    metadata?: JsonNullableWithAggregatesFilter<'XpEvent'>;
    createdAt?: DateTimeWithAggregatesFilter<'XpEvent'> | Date | string;
  };

  export type LeaderboardSnapshotWhereInput = {
    AND?: LeaderboardSnapshotWhereInput | LeaderboardSnapshotWhereInput[];
    OR?: LeaderboardSnapshotWhereInput[];
    NOT?: LeaderboardSnapshotWhereInput | LeaderboardSnapshotWhereInput[];
    id?: StringFilter<'LeaderboardSnapshot'> | string;
    scope?: EnumLeaderboardScopeFilter<'LeaderboardSnapshot'> | $Enums.LeaderboardScope;
    scopeId?: StringNullableFilter<'LeaderboardSnapshot'> | string | null;
    period?: EnumLeaderboardPeriodFilter<'LeaderboardSnapshot'> | $Enums.LeaderboardPeriod;
    data?: JsonFilter<'LeaderboardSnapshot'>;
    createdAt?: DateTimeFilter<'LeaderboardSnapshot'> | Date | string;
  };

  export type LeaderboardSnapshotOrderByWithRelationInput = {
    id?: SortOrder;
    scope?: SortOrder;
    scopeId?: SortOrderInput | SortOrder;
    period?: SortOrder;
    data?: SortOrder;
    createdAt?: SortOrder;
  };

  export type LeaderboardSnapshotWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: LeaderboardSnapshotWhereInput | LeaderboardSnapshotWhereInput[];
      OR?: LeaderboardSnapshotWhereInput[];
      NOT?: LeaderboardSnapshotWhereInput | LeaderboardSnapshotWhereInput[];
      scope?: EnumLeaderboardScopeFilter<'LeaderboardSnapshot'> | $Enums.LeaderboardScope;
      scopeId?: StringNullableFilter<'LeaderboardSnapshot'> | string | null;
      period?: EnumLeaderboardPeriodFilter<'LeaderboardSnapshot'> | $Enums.LeaderboardPeriod;
      data?: JsonFilter<'LeaderboardSnapshot'>;
      createdAt?: DateTimeFilter<'LeaderboardSnapshot'> | Date | string;
    },
    'id'
  >;

  export type LeaderboardSnapshotOrderByWithAggregationInput = {
    id?: SortOrder;
    scope?: SortOrder;
    scopeId?: SortOrderInput | SortOrder;
    period?: SortOrder;
    data?: SortOrder;
    createdAt?: SortOrder;
    _count?: LeaderboardSnapshotCountOrderByAggregateInput;
    _max?: LeaderboardSnapshotMaxOrderByAggregateInput;
    _min?: LeaderboardSnapshotMinOrderByAggregateInput;
  };

  export type LeaderboardSnapshotScalarWhereWithAggregatesInput = {
    AND?:
      | LeaderboardSnapshotScalarWhereWithAggregatesInput
      | LeaderboardSnapshotScalarWhereWithAggregatesInput[];
    OR?: LeaderboardSnapshotScalarWhereWithAggregatesInput[];
    NOT?:
      | LeaderboardSnapshotScalarWhereWithAggregatesInput
      | LeaderboardSnapshotScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'LeaderboardSnapshot'> | string;
    scope?:
      | EnumLeaderboardScopeWithAggregatesFilter<'LeaderboardSnapshot'>
      | $Enums.LeaderboardScope;
    scopeId?: StringNullableWithAggregatesFilter<'LeaderboardSnapshot'> | string | null;
    period?:
      | EnumLeaderboardPeriodWithAggregatesFilter<'LeaderboardSnapshot'>
      | $Enums.LeaderboardPeriod;
    data?: JsonWithAggregatesFilter<'LeaderboardSnapshot'>;
    createdAt?: DateTimeWithAggregatesFilter<'LeaderboardSnapshot'> | Date | string;
  };

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[];
    OR?: NotificationWhereInput[];
    NOT?: NotificationWhereInput | NotificationWhereInput[];
    id?: StringFilter<'Notification'> | string;
    userId?: StringFilter<'Notification'> | string;
    type?: StringFilter<'Notification'> | string;
    data?: JsonFilter<'Notification'>;
    readAt?: DateTimeNullableFilter<'Notification'> | Date | string | null;
    createdAt?: DateTimeFilter<'Notification'> | Date | string;
    user?: XOR<UserRelationFilter, UserWhereInput>;
  };

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    type?: SortOrder;
    data?: SortOrder;
    readAt?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    user?: UserOrderByWithRelationInput;
  };

  export type NotificationWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: NotificationWhereInput | NotificationWhereInput[];
      OR?: NotificationWhereInput[];
      NOT?: NotificationWhereInput | NotificationWhereInput[];
      userId?: StringFilter<'Notification'> | string;
      type?: StringFilter<'Notification'> | string;
      data?: JsonFilter<'Notification'>;
      readAt?: DateTimeNullableFilter<'Notification'> | Date | string | null;
      createdAt?: DateTimeFilter<'Notification'> | Date | string;
      user?: XOR<UserRelationFilter, UserWhereInput>;
    },
    'id'
  >;

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    type?: SortOrder;
    data?: SortOrder;
    readAt?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    _count?: NotificationCountOrderByAggregateInput;
    _max?: NotificationMaxOrderByAggregateInput;
    _min?: NotificationMinOrderByAggregateInput;
  };

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[];
    OR?: NotificationScalarWhereWithAggregatesInput[];
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Notification'> | string;
    userId?: StringWithAggregatesFilter<'Notification'> | string;
    type?: StringWithAggregatesFilter<'Notification'> | string;
    data?: JsonWithAggregatesFilter<'Notification'>;
    readAt?: DateTimeNullableWithAggregatesFilter<'Notification'> | Date | string | null;
    createdAt?: DateTimeWithAggregatesFilter<'Notification'> | Date | string;
  };

  export type ReportWhereInput = {
    AND?: ReportWhereInput | ReportWhereInput[];
    OR?: ReportWhereInput[];
    NOT?: ReportWhereInput | ReportWhereInput[];
    id?: StringFilter<'Report'> | string;
    reporterId?: StringFilter<'Report'> | string;
    entityType?: StringFilter<'Report'> | string;
    entityId?: StringFilter<'Report'> | string;
    reason?: StringFilter<'Report'> | string;
    status?: EnumReportStatusFilter<'Report'> | $Enums.ReportStatus;
    resolution?: StringNullableFilter<'Report'> | string | null;
    createdAt?: DateTimeFilter<'Report'> | Date | string;
    updatedAt?: DateTimeFilter<'Report'> | Date | string;
    reporter?: XOR<UserRelationFilter, UserWhereInput>;
  };

  export type ReportOrderByWithRelationInput = {
    id?: SortOrder;
    reporterId?: SortOrder;
    entityType?: SortOrder;
    entityId?: SortOrder;
    reason?: SortOrder;
    status?: SortOrder;
    resolution?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    reporter?: UserOrderByWithRelationInput;
  };

  export type ReportWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: ReportWhereInput | ReportWhereInput[];
      OR?: ReportWhereInput[];
      NOT?: ReportWhereInput | ReportWhereInput[];
      reporterId?: StringFilter<'Report'> | string;
      entityType?: StringFilter<'Report'> | string;
      entityId?: StringFilter<'Report'> | string;
      reason?: StringFilter<'Report'> | string;
      status?: EnumReportStatusFilter<'Report'> | $Enums.ReportStatus;
      resolution?: StringNullableFilter<'Report'> | string | null;
      createdAt?: DateTimeFilter<'Report'> | Date | string;
      updatedAt?: DateTimeFilter<'Report'> | Date | string;
      reporter?: XOR<UserRelationFilter, UserWhereInput>;
    },
    'id'
  >;

  export type ReportOrderByWithAggregationInput = {
    id?: SortOrder;
    reporterId?: SortOrder;
    entityType?: SortOrder;
    entityId?: SortOrder;
    reason?: SortOrder;
    status?: SortOrder;
    resolution?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: ReportCountOrderByAggregateInput;
    _max?: ReportMaxOrderByAggregateInput;
    _min?: ReportMinOrderByAggregateInput;
  };

  export type ReportScalarWhereWithAggregatesInput = {
    AND?: ReportScalarWhereWithAggregatesInput | ReportScalarWhereWithAggregatesInput[];
    OR?: ReportScalarWhereWithAggregatesInput[];
    NOT?: ReportScalarWhereWithAggregatesInput | ReportScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Report'> | string;
    reporterId?: StringWithAggregatesFilter<'Report'> | string;
    entityType?: StringWithAggregatesFilter<'Report'> | string;
    entityId?: StringWithAggregatesFilter<'Report'> | string;
    reason?: StringWithAggregatesFilter<'Report'> | string;
    status?: EnumReportStatusWithAggregatesFilter<'Report'> | $Enums.ReportStatus;
    resolution?: StringNullableWithAggregatesFilter<'Report'> | string | null;
    createdAt?: DateTimeWithAggregatesFilter<'Report'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'Report'> | Date | string;
  };

  export type FileWhereInput = {
    AND?: FileWhereInput | FileWhereInput[];
    OR?: FileWhereInput[];
    NOT?: FileWhereInput | FileWhereInput[];
    id?: StringFilter<'File'> | string;
    filename?: StringFilter<'File'> | string;
    mimetype?: StringFilter<'File'> | string;
    size?: IntFilter<'File'> | number;
    key?: StringFilter<'File'> | string;
    url?: StringFilter<'File'> | string;
    type?: StringFilter<'File'> | string;
    uploadedById?: StringFilter<'File'> | string;
    entityId?: StringNullableFilter<'File'> | string | null;
    entityType?: StringNullableFilter<'File'> | string | null;
    createdAt?: DateTimeFilter<'File'> | Date | string;
    updatedAt?: DateTimeFilter<'File'> | Date | string;
    deletedAt?: DateTimeNullableFilter<'File'> | Date | string | null;
    uploadedBy?: XOR<UserRelationFilter, UserWhereInput>;
  };

  export type FileOrderByWithRelationInput = {
    id?: SortOrder;
    filename?: SortOrder;
    mimetype?: SortOrder;
    size?: SortOrder;
    key?: SortOrder;
    url?: SortOrder;
    type?: SortOrder;
    uploadedById?: SortOrder;
    entityId?: SortOrderInput | SortOrder;
    entityType?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    deletedAt?: SortOrderInput | SortOrder;
    uploadedBy?: UserOrderByWithRelationInput;
  };

  export type FileWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: FileWhereInput | FileWhereInput[];
      OR?: FileWhereInput[];
      NOT?: FileWhereInput | FileWhereInput[];
      filename?: StringFilter<'File'> | string;
      mimetype?: StringFilter<'File'> | string;
      size?: IntFilter<'File'> | number;
      key?: StringFilter<'File'> | string;
      url?: StringFilter<'File'> | string;
      type?: StringFilter<'File'> | string;
      uploadedById?: StringFilter<'File'> | string;
      entityId?: StringNullableFilter<'File'> | string | null;
      entityType?: StringNullableFilter<'File'> | string | null;
      createdAt?: DateTimeFilter<'File'> | Date | string;
      updatedAt?: DateTimeFilter<'File'> | Date | string;
      deletedAt?: DateTimeNullableFilter<'File'> | Date | string | null;
      uploadedBy?: XOR<UserRelationFilter, UserWhereInput>;
    },
    'id'
  >;

  export type FileOrderByWithAggregationInput = {
    id?: SortOrder;
    filename?: SortOrder;
    mimetype?: SortOrder;
    size?: SortOrder;
    key?: SortOrder;
    url?: SortOrder;
    type?: SortOrder;
    uploadedById?: SortOrder;
    entityId?: SortOrderInput | SortOrder;
    entityType?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    deletedAt?: SortOrderInput | SortOrder;
    _count?: FileCountOrderByAggregateInput;
    _avg?: FileAvgOrderByAggregateInput;
    _max?: FileMaxOrderByAggregateInput;
    _min?: FileMinOrderByAggregateInput;
    _sum?: FileSumOrderByAggregateInput;
  };

  export type FileScalarWhereWithAggregatesInput = {
    AND?: FileScalarWhereWithAggregatesInput | FileScalarWhereWithAggregatesInput[];
    OR?: FileScalarWhereWithAggregatesInput[];
    NOT?: FileScalarWhereWithAggregatesInput | FileScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'File'> | string;
    filename?: StringWithAggregatesFilter<'File'> | string;
    mimetype?: StringWithAggregatesFilter<'File'> | string;
    size?: IntWithAggregatesFilter<'File'> | number;
    key?: StringWithAggregatesFilter<'File'> | string;
    url?: StringWithAggregatesFilter<'File'> | string;
    type?: StringWithAggregatesFilter<'File'> | string;
    uploadedById?: StringWithAggregatesFilter<'File'> | string;
    entityId?: StringNullableWithAggregatesFilter<'File'> | string | null;
    entityType?: StringNullableWithAggregatesFilter<'File'> | string | null;
    createdAt?: DateTimeWithAggregatesFilter<'File'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'File'> | Date | string;
    deletedAt?: DateTimeNullableWithAggregatesFilter<'File'> | Date | string | null;
  };

  export type UserCreateInput = {
    id?: string;
    email: string;
    emailVerified?: Date | string | null;
    name?: string | null;
    handle?: string | null;
    avatarUrl?: string | null;
    bio?: string | null;
    organization?: string | null;
    password?: string | null;
    roles?: UserCreaterolesInput | $Enums.Role[];
    totpSecret?: string | null;
    totpEnabled?: boolean;
    passwordResetToken?: string | null;
    passwordResetExpires?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastLoginAt?: Date | string | null;
    isActive?: boolean;
    isBanned?: boolean;
    accounts?: AccountCreateNestedManyWithoutUserInput;
    sessions?: SessionCreateNestedManyWithoutUserInput;
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput;
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput;
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput;
    mentorProfiles?: MentorCreateNestedManyWithoutUserInput;
    judgeAssignments?: JudgeCreateNestedManyWithoutUserInput;
    challengeSubmissions?: ChallengeSubmissionCreateNestedManyWithoutUserInput;
    comments?: CommentCreateNestedManyWithoutAuthorInput;
    gamificationProfile?: GamificationProfileCreateNestedOneWithoutUserInput;
    xpEvents?: XpEventCreateNestedManyWithoutUserInput;
    notifications?: NotificationCreateNestedManyWithoutUserInput;
    reports?: ReportCreateNestedManyWithoutReporterInput;
    uploadedFiles?: FileCreateNestedManyWithoutUploadedByInput;
    ownedChallenges?: ChallengeCreateNestedManyWithoutOwnerInput;
  };

  export type UserUncheckedCreateInput = {
    id?: string;
    email: string;
    emailVerified?: Date | string | null;
    name?: string | null;
    handle?: string | null;
    avatarUrl?: string | null;
    bio?: string | null;
    organization?: string | null;
    password?: string | null;
    roles?: UserCreaterolesInput | $Enums.Role[];
    totpSecret?: string | null;
    totpEnabled?: boolean;
    passwordResetToken?: string | null;
    passwordResetExpires?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastLoginAt?: Date | string | null;
    isActive?: boolean;
    isBanned?: boolean;
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput;
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput;
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput;
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput;
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput;
    mentorProfiles?: MentorUncheckedCreateNestedManyWithoutUserInput;
    judgeAssignments?: JudgeUncheckedCreateNestedManyWithoutUserInput;
    challengeSubmissions?: ChallengeSubmissionUncheckedCreateNestedManyWithoutUserInput;
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput;
    gamificationProfile?: GamificationProfileUncheckedCreateNestedOneWithoutUserInput;
    xpEvents?: XpEventUncheckedCreateNestedManyWithoutUserInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    reports?: ReportUncheckedCreateNestedManyWithoutReporterInput;
    uploadedFiles?: FileUncheckedCreateNestedManyWithoutUploadedByInput;
    ownedChallenges?: ChallengeUncheckedCreateNestedManyWithoutOwnerInput;
  };

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    handle?: NullableStringFieldUpdateOperationsInput | string | null;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    organization?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    roles?: UserUpdaterolesInput | $Enums.Role[];
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    totpEnabled?: BoolFieldUpdateOperationsInput | boolean;
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    isBanned?: BoolFieldUpdateOperationsInput | boolean;
    accounts?: AccountUpdateManyWithoutUserNestedInput;
    sessions?: SessionUpdateManyWithoutUserNestedInput;
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput;
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput;
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput;
    mentorProfiles?: MentorUpdateManyWithoutUserNestedInput;
    judgeAssignments?: JudgeUpdateManyWithoutUserNestedInput;
    challengeSubmissions?: ChallengeSubmissionUpdateManyWithoutUserNestedInput;
    comments?: CommentUpdateManyWithoutAuthorNestedInput;
    gamificationProfile?: GamificationProfileUpdateOneWithoutUserNestedInput;
    xpEvents?: XpEventUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUpdateManyWithoutUserNestedInput;
    reports?: ReportUpdateManyWithoutReporterNestedInput;
    uploadedFiles?: FileUpdateManyWithoutUploadedByNestedInput;
    ownedChallenges?: ChallengeUpdateManyWithoutOwnerNestedInput;
  };

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    handle?: NullableStringFieldUpdateOperationsInput | string | null;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    organization?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    roles?: UserUpdaterolesInput | $Enums.Role[];
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    totpEnabled?: BoolFieldUpdateOperationsInput | boolean;
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    isBanned?: BoolFieldUpdateOperationsInput | boolean;
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput;
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput;
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput;
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput;
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput;
    mentorProfiles?: MentorUncheckedUpdateManyWithoutUserNestedInput;
    judgeAssignments?: JudgeUncheckedUpdateManyWithoutUserNestedInput;
    challengeSubmissions?: ChallengeSubmissionUncheckedUpdateManyWithoutUserNestedInput;
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput;
    gamificationProfile?: GamificationProfileUncheckedUpdateOneWithoutUserNestedInput;
    xpEvents?: XpEventUncheckedUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    reports?: ReportUncheckedUpdateManyWithoutReporterNestedInput;
    uploadedFiles?: FileUncheckedUpdateManyWithoutUploadedByNestedInput;
    ownedChallenges?: ChallengeUncheckedUpdateManyWithoutOwnerNestedInput;
  };

  export type UserCreateManyInput = {
    id?: string;
    email: string;
    emailVerified?: Date | string | null;
    name?: string | null;
    handle?: string | null;
    avatarUrl?: string | null;
    bio?: string | null;
    organization?: string | null;
    password?: string | null;
    roles?: UserCreaterolesInput | $Enums.Role[];
    totpSecret?: string | null;
    totpEnabled?: boolean;
    passwordResetToken?: string | null;
    passwordResetExpires?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastLoginAt?: Date | string | null;
    isActive?: boolean;
    isBanned?: boolean;
  };

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    handle?: NullableStringFieldUpdateOperationsInput | string | null;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    organization?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    roles?: UserUpdaterolesInput | $Enums.Role[];
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    totpEnabled?: BoolFieldUpdateOperationsInput | boolean;
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    isBanned?: BoolFieldUpdateOperationsInput | boolean;
  };

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    handle?: NullableStringFieldUpdateOperationsInput | string | null;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    organization?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    roles?: UserUpdaterolesInput | $Enums.Role[];
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    totpEnabled?: BoolFieldUpdateOperationsInput | boolean;
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    isBanned?: BoolFieldUpdateOperationsInput | boolean;
  };

  export type AccountCreateInput = {
    id?: string;
    type: string;
    provider: string;
    providerAccountId: string;
    refresh_token?: string | null;
    access_token?: string | null;
    expires_at?: number | null;
    token_type?: string | null;
    scope?: string | null;
    id_token?: string | null;
    session_state?: string | null;
    user: UserCreateNestedOneWithoutAccountsInput;
  };

  export type AccountUncheckedCreateInput = {
    id?: string;
    userId: string;
    type: string;
    provider: string;
    providerAccountId: string;
    refresh_token?: string | null;
    access_token?: string | null;
    expires_at?: number | null;
    token_type?: string | null;
    scope?: string | null;
    id_token?: string | null;
    session_state?: string | null;
  };

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    provider?: StringFieldUpdateOperationsInput | string;
    providerAccountId?: StringFieldUpdateOperationsInput | string;
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null;
    access_token?: NullableStringFieldUpdateOperationsInput | string | null;
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null;
    token_type?: NullableStringFieldUpdateOperationsInput | string | null;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    id_token?: NullableStringFieldUpdateOperationsInput | string | null;
    session_state?: NullableStringFieldUpdateOperationsInput | string | null;
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput;
  };

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    provider?: StringFieldUpdateOperationsInput | string;
    providerAccountId?: StringFieldUpdateOperationsInput | string;
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null;
    access_token?: NullableStringFieldUpdateOperationsInput | string | null;
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null;
    token_type?: NullableStringFieldUpdateOperationsInput | string | null;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    id_token?: NullableStringFieldUpdateOperationsInput | string | null;
    session_state?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type AccountCreateManyInput = {
    id?: string;
    userId: string;
    type: string;
    provider: string;
    providerAccountId: string;
    refresh_token?: string | null;
    access_token?: string | null;
    expires_at?: number | null;
    token_type?: string | null;
    scope?: string | null;
    id_token?: string | null;
    session_state?: string | null;
  };

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    provider?: StringFieldUpdateOperationsInput | string;
    providerAccountId?: StringFieldUpdateOperationsInput | string;
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null;
    access_token?: NullableStringFieldUpdateOperationsInput | string | null;
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null;
    token_type?: NullableStringFieldUpdateOperationsInput | string | null;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    id_token?: NullableStringFieldUpdateOperationsInput | string | null;
    session_state?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    provider?: StringFieldUpdateOperationsInput | string;
    providerAccountId?: StringFieldUpdateOperationsInput | string;
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null;
    access_token?: NullableStringFieldUpdateOperationsInput | string | null;
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null;
    token_type?: NullableStringFieldUpdateOperationsInput | string | null;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    id_token?: NullableStringFieldUpdateOperationsInput | string | null;
    session_state?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type SessionCreateInput = {
    id?: string;
    sessionToken: string;
    expires: Date | string;
    user: UserCreateNestedOneWithoutSessionsInput;
  };

  export type SessionUncheckedCreateInput = {
    id?: string;
    sessionToken: string;
    userId: string;
    expires: Date | string;
  };

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    sessionToken?: StringFieldUpdateOperationsInput | string;
    expires?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput;
  };

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    sessionToken?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    expires?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type SessionCreateManyInput = {
    id?: string;
    sessionToken: string;
    userId: string;
    expires: Date | string;
  };

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    sessionToken?: StringFieldUpdateOperationsInput | string;
    expires?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    sessionToken?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    expires?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type VerificationTokenCreateInput = {
    identifier: string;
    token: string;
    expires: Date | string;
  };

  export type VerificationTokenUncheckedCreateInput = {
    identifier: string;
    token: string;
    expires: Date | string;
  };

  export type VerificationTokenUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string;
    token?: StringFieldUpdateOperationsInput | string;
    expires?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type VerificationTokenUncheckedUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string;
    token?: StringFieldUpdateOperationsInput | string;
    expires?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type VerificationTokenCreateManyInput = {
    identifier: string;
    token: string;
    expires: Date | string;
  };

  export type VerificationTokenUpdateManyMutationInput = {
    identifier?: StringFieldUpdateOperationsInput | string;
    token?: StringFieldUpdateOperationsInput | string;
    expires?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type VerificationTokenUncheckedUpdateManyInput = {
    identifier?: StringFieldUpdateOperationsInput | string;
    token?: StringFieldUpdateOperationsInput | string;
    expires?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ApiKeyCreateInput = {
    id?: string;
    name: string;
    hashedKey: string;
    scopes?: ApiKeyCreatescopesInput | string[];
    lastUsedAt?: Date | string | null;
    expiresAt?: Date | string | null;
    createdAt?: Date | string;
    isActive?: boolean;
    user: UserCreateNestedOneWithoutApiKeysInput;
  };

  export type ApiKeyUncheckedCreateInput = {
    id?: string;
    userId: string;
    name: string;
    hashedKey: string;
    scopes?: ApiKeyCreatescopesInput | string[];
    lastUsedAt?: Date | string | null;
    expiresAt?: Date | string | null;
    createdAt?: Date | string;
    isActive?: boolean;
  };

  export type ApiKeyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    hashedKey?: StringFieldUpdateOperationsInput | string;
    scopes?: ApiKeyUpdatescopesInput | string[];
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    user?: UserUpdateOneRequiredWithoutApiKeysNestedInput;
  };

  export type ApiKeyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    hashedKey?: StringFieldUpdateOperationsInput | string;
    scopes?: ApiKeyUpdatescopesInput | string[];
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
  };

  export type ApiKeyCreateManyInput = {
    id?: string;
    userId: string;
    name: string;
    hashedKey: string;
    scopes?: ApiKeyCreatescopesInput | string[];
    lastUsedAt?: Date | string | null;
    expiresAt?: Date | string | null;
    createdAt?: Date | string;
    isActive?: boolean;
  };

  export type ApiKeyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    hashedKey?: StringFieldUpdateOperationsInput | string;
    scopes?: ApiKeyUpdatescopesInput | string[];
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
  };

  export type ApiKeyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    hashedKey?: StringFieldUpdateOperationsInput | string;
    scopes?: ApiKeyUpdatescopesInput | string[];
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
  };

  export type AuditLogCreateInput = {
    id?: string;
    action: string;
    entityType: string;
    entityId?: string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    ipAddress?: string | null;
    userAgent?: string | null;
    createdAt?: Date | string;
    actor?: UserCreateNestedOneWithoutAuditLogsInput;
  };

  export type AuditLogUncheckedCreateInput = {
    id?: string;
    actorId?: string | null;
    action: string;
    entityType: string;
    entityId?: string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    ipAddress?: string | null;
    userAgent?: string | null;
    createdAt?: Date | string;
  };

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    action?: StringFieldUpdateOperationsInput | string;
    entityType?: StringFieldUpdateOperationsInput | string;
    entityId?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    actor?: UserUpdateOneWithoutAuditLogsNestedInput;
  };

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    actorId?: NullableStringFieldUpdateOperationsInput | string | null;
    action?: StringFieldUpdateOperationsInput | string;
    entityType?: StringFieldUpdateOperationsInput | string;
    entityId?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AuditLogCreateManyInput = {
    id?: string;
    actorId?: string | null;
    action: string;
    entityType: string;
    entityId?: string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    ipAddress?: string | null;
    userAgent?: string | null;
    createdAt?: Date | string;
  };

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    action?: StringFieldUpdateOperationsInput | string;
    entityType?: StringFieldUpdateOperationsInput | string;
    entityId?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    actorId?: NullableStringFieldUpdateOperationsInput | string | null;
    action?: StringFieldUpdateOperationsInput | string;
    entityType?: StringFieldUpdateOperationsInput | string;
    entityId?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type HackathonCreateInput = {
    id?: string;
    slug: string;
    title: string;
    description: string;
    coverImage?: string | null;
    status?: $Enums.HackathonStatus;
    location?: $Enums.HackathonLocation;
    registrationOpensAt?: Date | string | null;
    registrationClosesAt?: Date | string | null;
    startsAt: Date | string;
    endsAt: Date | string;
    judgingEndsAt?: Date | string | null;
    prizePool?: Decimal | DecimalJsLike | number | string | null;
    maxTeamSize?: number;
    allowSoloTeams?: boolean;
    rules?: string | null;
    schedule?: NullableJsonNullValueInput | InputJsonValue;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    tracks?: TrackCreateNestedManyWithoutHackathonInput;
    teams?: TeamCreateNestedManyWithoutHackathonInput;
    mentors?: MentorCreateNestedManyWithoutHackathonInput;
    judges?: JudgeCreateNestedManyWithoutHackathonInput;
    criteria?: CriteriaCreateNestedManyWithoutHackathonInput;
    submissions?: SubmissionCreateNestedManyWithoutHackathonInput;
    announcements?: AnnouncementCreateNestedManyWithoutHackathonInput;
  };

  export type HackathonUncheckedCreateInput = {
    id?: string;
    slug: string;
    title: string;
    description: string;
    coverImage?: string | null;
    status?: $Enums.HackathonStatus;
    location?: $Enums.HackathonLocation;
    registrationOpensAt?: Date | string | null;
    registrationClosesAt?: Date | string | null;
    startsAt: Date | string;
    endsAt: Date | string;
    judgingEndsAt?: Date | string | null;
    prizePool?: Decimal | DecimalJsLike | number | string | null;
    maxTeamSize?: number;
    allowSoloTeams?: boolean;
    rules?: string | null;
    schedule?: NullableJsonNullValueInput | InputJsonValue;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    tracks?: TrackUncheckedCreateNestedManyWithoutHackathonInput;
    teams?: TeamUncheckedCreateNestedManyWithoutHackathonInput;
    mentors?: MentorUncheckedCreateNestedManyWithoutHackathonInput;
    judges?: JudgeUncheckedCreateNestedManyWithoutHackathonInput;
    criteria?: CriteriaUncheckedCreateNestedManyWithoutHackathonInput;
    submissions?: SubmissionUncheckedCreateNestedManyWithoutHackathonInput;
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutHackathonInput;
  };

  export type HackathonUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumHackathonStatusFieldUpdateOperationsInput | $Enums.HackathonStatus;
    location?: EnumHackathonLocationFieldUpdateOperationsInput | $Enums.HackathonLocation;
    registrationOpensAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    registrationClosesAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    judgingEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    prizePool?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    maxTeamSize?: IntFieldUpdateOperationsInput | number;
    allowSoloTeams?: BoolFieldUpdateOperationsInput | boolean;
    rules?: NullableStringFieldUpdateOperationsInput | string | null;
    schedule?: NullableJsonNullValueInput | InputJsonValue;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    tracks?: TrackUpdateManyWithoutHackathonNestedInput;
    teams?: TeamUpdateManyWithoutHackathonNestedInput;
    mentors?: MentorUpdateManyWithoutHackathonNestedInput;
    judges?: JudgeUpdateManyWithoutHackathonNestedInput;
    criteria?: CriteriaUpdateManyWithoutHackathonNestedInput;
    submissions?: SubmissionUpdateManyWithoutHackathonNestedInput;
    announcements?: AnnouncementUpdateManyWithoutHackathonNestedInput;
  };

  export type HackathonUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumHackathonStatusFieldUpdateOperationsInput | $Enums.HackathonStatus;
    location?: EnumHackathonLocationFieldUpdateOperationsInput | $Enums.HackathonLocation;
    registrationOpensAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    registrationClosesAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    judgingEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    prizePool?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    maxTeamSize?: IntFieldUpdateOperationsInput | number;
    allowSoloTeams?: BoolFieldUpdateOperationsInput | boolean;
    rules?: NullableStringFieldUpdateOperationsInput | string | null;
    schedule?: NullableJsonNullValueInput | InputJsonValue;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    tracks?: TrackUncheckedUpdateManyWithoutHackathonNestedInput;
    teams?: TeamUncheckedUpdateManyWithoutHackathonNestedInput;
    mentors?: MentorUncheckedUpdateManyWithoutHackathonNestedInput;
    judges?: JudgeUncheckedUpdateManyWithoutHackathonNestedInput;
    criteria?: CriteriaUncheckedUpdateManyWithoutHackathonNestedInput;
    submissions?: SubmissionUncheckedUpdateManyWithoutHackathonNestedInput;
    announcements?: AnnouncementUncheckedUpdateManyWithoutHackathonNestedInput;
  };

  export type HackathonCreateManyInput = {
    id?: string;
    slug: string;
    title: string;
    description: string;
    coverImage?: string | null;
    status?: $Enums.HackathonStatus;
    location?: $Enums.HackathonLocation;
    registrationOpensAt?: Date | string | null;
    registrationClosesAt?: Date | string | null;
    startsAt: Date | string;
    endsAt: Date | string;
    judgingEndsAt?: Date | string | null;
    prizePool?: Decimal | DecimalJsLike | number | string | null;
    maxTeamSize?: number;
    allowSoloTeams?: boolean;
    rules?: string | null;
    schedule?: NullableJsonNullValueInput | InputJsonValue;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type HackathonUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumHackathonStatusFieldUpdateOperationsInput | $Enums.HackathonStatus;
    location?: EnumHackathonLocationFieldUpdateOperationsInput | $Enums.HackathonLocation;
    registrationOpensAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    registrationClosesAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    judgingEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    prizePool?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    maxTeamSize?: IntFieldUpdateOperationsInput | number;
    allowSoloTeams?: BoolFieldUpdateOperationsInput | boolean;
    rules?: NullableStringFieldUpdateOperationsInput | string | null;
    schedule?: NullableJsonNullValueInput | InputJsonValue;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type HackathonUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumHackathonStatusFieldUpdateOperationsInput | $Enums.HackathonStatus;
    location?: EnumHackathonLocationFieldUpdateOperationsInput | $Enums.HackathonLocation;
    registrationOpensAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    registrationClosesAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    judgingEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    prizePool?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    maxTeamSize?: IntFieldUpdateOperationsInput | number;
    allowSoloTeams?: BoolFieldUpdateOperationsInput | boolean;
    rules?: NullableStringFieldUpdateOperationsInput | string | null;
    schedule?: NullableJsonNullValueInput | InputJsonValue;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type TrackCreateInput = {
    id?: string;
    title: string;
    description?: string | null;
    order?: number;
    createdAt?: Date | string;
    hackathon: HackathonCreateNestedOneWithoutTracksInput;
    submissions?: SubmissionCreateNestedManyWithoutTrackInput;
  };

  export type TrackUncheckedCreateInput = {
    id?: string;
    hackathonId: string;
    title: string;
    description?: string | null;
    order?: number;
    createdAt?: Date | string;
    submissions?: SubmissionUncheckedCreateNestedManyWithoutTrackInput;
  };

  export type TrackUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    order?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    hackathon?: HackathonUpdateOneRequiredWithoutTracksNestedInput;
    submissions?: SubmissionUpdateManyWithoutTrackNestedInput;
  };

  export type TrackUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    hackathonId?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    order?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    submissions?: SubmissionUncheckedUpdateManyWithoutTrackNestedInput;
  };

  export type TrackCreateManyInput = {
    id?: string;
    hackathonId: string;
    title: string;
    description?: string | null;
    order?: number;
    createdAt?: Date | string;
  };

  export type TrackUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    order?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type TrackUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    hackathonId?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    order?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type TeamCreateInput = {
    id?: string;
    name: string;
    bio?: string | null;
    logoUrl?: string | null;
    repoUrl?: string | null;
    demoUrl?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    hackathon: HackathonCreateNestedOneWithoutTeamsInput;
    members?: TeamMemberCreateNestedManyWithoutTeamInput;
    submissions?: SubmissionCreateNestedManyWithoutTeamInput;
    challengeSubmissions?: ChallengeSubmissionCreateNestedManyWithoutTeamInput;
  };

  export type TeamUncheckedCreateInput = {
    id?: string;
    hackathonId: string;
    name: string;
    bio?: string | null;
    logoUrl?: string | null;
    repoUrl?: string | null;
    demoUrl?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    members?: TeamMemberUncheckedCreateNestedManyWithoutTeamInput;
    submissions?: SubmissionUncheckedCreateNestedManyWithoutTeamInput;
    challengeSubmissions?: ChallengeSubmissionUncheckedCreateNestedManyWithoutTeamInput;
  };

  export type TeamUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    repoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    demoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    hackathon?: HackathonUpdateOneRequiredWithoutTeamsNestedInput;
    members?: TeamMemberUpdateManyWithoutTeamNestedInput;
    submissions?: SubmissionUpdateManyWithoutTeamNestedInput;
    challengeSubmissions?: ChallengeSubmissionUpdateManyWithoutTeamNestedInput;
  };

  export type TeamUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    hackathonId?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    repoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    demoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    members?: TeamMemberUncheckedUpdateManyWithoutTeamNestedInput;
    submissions?: SubmissionUncheckedUpdateManyWithoutTeamNestedInput;
    challengeSubmissions?: ChallengeSubmissionUncheckedUpdateManyWithoutTeamNestedInput;
  };

  export type TeamCreateManyInput = {
    id?: string;
    hackathonId: string;
    name: string;
    bio?: string | null;
    logoUrl?: string | null;
    repoUrl?: string | null;
    demoUrl?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type TeamUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    repoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    demoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type TeamUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    hackathonId?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    repoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    demoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type TeamMemberCreateInput = {
    role?: $Enums.TeamMemberRole;
    joinedAt?: Date | string;
    team: TeamCreateNestedOneWithoutMembersInput;
    user: UserCreateNestedOneWithoutTeamMembershipsInput;
  };

  export type TeamMemberUncheckedCreateInput = {
    teamId: string;
    userId: string;
    role?: $Enums.TeamMemberRole;
    joinedAt?: Date | string;
  };

  export type TeamMemberUpdateInput = {
    role?: EnumTeamMemberRoleFieldUpdateOperationsInput | $Enums.TeamMemberRole;
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    team?: TeamUpdateOneRequiredWithoutMembersNestedInput;
    user?: UserUpdateOneRequiredWithoutTeamMembershipsNestedInput;
  };

  export type TeamMemberUncheckedUpdateInput = {
    teamId?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    role?: EnumTeamMemberRoleFieldUpdateOperationsInput | $Enums.TeamMemberRole;
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type TeamMemberCreateManyInput = {
    teamId: string;
    userId: string;
    role?: $Enums.TeamMemberRole;
    joinedAt?: Date | string;
  };

  export type TeamMemberUpdateManyMutationInput = {
    role?: EnumTeamMemberRoleFieldUpdateOperationsInput | $Enums.TeamMemberRole;
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type TeamMemberUncheckedUpdateManyInput = {
    teamId?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    role?: EnumTeamMemberRoleFieldUpdateOperationsInput | $Enums.TeamMemberRole;
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type MentorCreateInput = {
    id?: string;
    bio?: string | null;
    calendlyUrl?: string | null;
    expertise?: MentorCreateexpertiseInput | string[];
    createdAt?: Date | string;
    user: UserCreateNestedOneWithoutMentorProfilesInput;
    hackathon: HackathonCreateNestedOneWithoutMentorsInput;
    sessions?: MentorSessionCreateNestedManyWithoutMentorInput;
  };

  export type MentorUncheckedCreateInput = {
    id?: string;
    userId: string;
    hackathonId: string;
    bio?: string | null;
    calendlyUrl?: string | null;
    expertise?: MentorCreateexpertiseInput | string[];
    createdAt?: Date | string;
    sessions?: MentorSessionUncheckedCreateNestedManyWithoutMentorInput;
  };

  export type MentorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    calendlyUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    expertise?: MentorUpdateexpertiseInput | string[];
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutMentorProfilesNestedInput;
    hackathon?: HackathonUpdateOneRequiredWithoutMentorsNestedInput;
    sessions?: MentorSessionUpdateManyWithoutMentorNestedInput;
  };

  export type MentorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    hackathonId?: StringFieldUpdateOperationsInput | string;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    calendlyUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    expertise?: MentorUpdateexpertiseInput | string[];
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    sessions?: MentorSessionUncheckedUpdateManyWithoutMentorNestedInput;
  };

  export type MentorCreateManyInput = {
    id?: string;
    userId: string;
    hackathonId: string;
    bio?: string | null;
    calendlyUrl?: string | null;
    expertise?: MentorCreateexpertiseInput | string[];
    createdAt?: Date | string;
  };

  export type MentorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    calendlyUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    expertise?: MentorUpdateexpertiseInput | string[];
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type MentorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    hackathonId?: StringFieldUpdateOperationsInput | string;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    calendlyUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    expertise?: MentorUpdateexpertiseInput | string[];
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type MentorSessionCreateInput = {
    id?: string;
    title?: string | null;
    startsAt: Date | string;
    endsAt: Date | string;
    capacity?: number;
    booked?: number;
    meetingUrl?: string | null;
    createdAt?: Date | string;
    mentor: MentorCreateNestedOneWithoutSessionsInput;
  };

  export type MentorSessionUncheckedCreateInput = {
    id?: string;
    mentorId: string;
    title?: string | null;
    startsAt: Date | string;
    endsAt: Date | string;
    capacity?: number;
    booked?: number;
    meetingUrl?: string | null;
    createdAt?: Date | string;
  };

  export type MentorSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: NullableStringFieldUpdateOperationsInput | string | null;
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    capacity?: IntFieldUpdateOperationsInput | number;
    booked?: IntFieldUpdateOperationsInput | number;
    meetingUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    mentor?: MentorUpdateOneRequiredWithoutSessionsNestedInput;
  };

  export type MentorSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    mentorId?: StringFieldUpdateOperationsInput | string;
    title?: NullableStringFieldUpdateOperationsInput | string | null;
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    capacity?: IntFieldUpdateOperationsInput | number;
    booked?: IntFieldUpdateOperationsInput | number;
    meetingUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type MentorSessionCreateManyInput = {
    id?: string;
    mentorId: string;
    title?: string | null;
    startsAt: Date | string;
    endsAt: Date | string;
    capacity?: number;
    booked?: number;
    meetingUrl?: string | null;
    createdAt?: Date | string;
  };

  export type MentorSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: NullableStringFieldUpdateOperationsInput | string | null;
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    capacity?: IntFieldUpdateOperationsInput | number;
    booked?: IntFieldUpdateOperationsInput | number;
    meetingUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type MentorSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    mentorId?: StringFieldUpdateOperationsInput | string;
    title?: NullableStringFieldUpdateOperationsInput | string | null;
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    capacity?: IntFieldUpdateOperationsInput | number;
    booked?: IntFieldUpdateOperationsInput | number;
    meetingUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type JudgeCreateInput = {
    id?: string;
    bio?: string | null;
    createdAt?: Date | string;
    user: UserCreateNestedOneWithoutJudgeAssignmentsInput;
    hackathon: HackathonCreateNestedOneWithoutJudgesInput;
    scores?: ScoreCreateNestedManyWithoutJudgeInput;
  };

  export type JudgeUncheckedCreateInput = {
    id?: string;
    userId: string;
    hackathonId: string;
    bio?: string | null;
    createdAt?: Date | string;
    scores?: ScoreUncheckedCreateNestedManyWithoutJudgeInput;
  };

  export type JudgeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutJudgeAssignmentsNestedInput;
    hackathon?: HackathonUpdateOneRequiredWithoutJudgesNestedInput;
    scores?: ScoreUpdateManyWithoutJudgeNestedInput;
  };

  export type JudgeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    hackathonId?: StringFieldUpdateOperationsInput | string;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    scores?: ScoreUncheckedUpdateManyWithoutJudgeNestedInput;
  };

  export type JudgeCreateManyInput = {
    id?: string;
    userId: string;
    hackathonId: string;
    bio?: string | null;
    createdAt?: Date | string;
  };

  export type JudgeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type JudgeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    hackathonId?: StringFieldUpdateOperationsInput | string;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type CriteriaCreateInput = {
    id?: string;
    name: string;
    description?: string | null;
    maxScore?: number;
    weight?: Decimal | DecimalJsLike | number | string;
    order?: number;
    hackathon: HackathonCreateNestedOneWithoutCriteriaInput;
    scores?: ScoreCreateNestedManyWithoutCriterionInput;
  };

  export type CriteriaUncheckedCreateInput = {
    id?: string;
    hackathonId: string;
    name: string;
    description?: string | null;
    maxScore?: number;
    weight?: Decimal | DecimalJsLike | number | string;
    order?: number;
    scores?: ScoreUncheckedCreateNestedManyWithoutCriterionInput;
  };

  export type CriteriaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    maxScore?: IntFieldUpdateOperationsInput | number;
    weight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    order?: IntFieldUpdateOperationsInput | number;
    hackathon?: HackathonUpdateOneRequiredWithoutCriteriaNestedInput;
    scores?: ScoreUpdateManyWithoutCriterionNestedInput;
  };

  export type CriteriaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    hackathonId?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    maxScore?: IntFieldUpdateOperationsInput | number;
    weight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    order?: IntFieldUpdateOperationsInput | number;
    scores?: ScoreUncheckedUpdateManyWithoutCriterionNestedInput;
  };

  export type CriteriaCreateManyInput = {
    id?: string;
    hackathonId: string;
    name: string;
    description?: string | null;
    maxScore?: number;
    weight?: Decimal | DecimalJsLike | number | string;
    order?: number;
  };

  export type CriteriaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    maxScore?: IntFieldUpdateOperationsInput | number;
    weight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    order?: IntFieldUpdateOperationsInput | number;
  };

  export type CriteriaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    hackathonId?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    maxScore?: IntFieldUpdateOperationsInput | number;
    weight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    order?: IntFieldUpdateOperationsInput | number;
  };

  export type SubmissionCreateInput = {
    id?: string;
    title: string;
    abstract: string;
    repoUrl?: string | null;
    demoUrl?: string | null;
    videoUrl?: string | null;
    files?: SubmissionCreatefilesInput | string[];
    submittedAt?: Date | string | null;
    finalizedAt?: Date | string | null;
    status?: $Enums.SubmissionStatus;
    scoreAggregate?: Decimal | DecimalJsLike | number | string | null;
    rank?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    hackathon: HackathonCreateNestedOneWithoutSubmissionsInput;
    team: TeamCreateNestedOneWithoutSubmissionsInput;
    track?: TrackCreateNestedOneWithoutSubmissionsInput;
    scores?: ScoreCreateNestedManyWithoutSubmissionInput;
  };

  export type SubmissionUncheckedCreateInput = {
    id?: string;
    hackathonId: string;
    teamId: string;
    trackId?: string | null;
    title: string;
    abstract: string;
    repoUrl?: string | null;
    demoUrl?: string | null;
    videoUrl?: string | null;
    files?: SubmissionCreatefilesInput | string[];
    submittedAt?: Date | string | null;
    finalizedAt?: Date | string | null;
    status?: $Enums.SubmissionStatus;
    scoreAggregate?: Decimal | DecimalJsLike | number | string | null;
    rank?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    scores?: ScoreUncheckedCreateNestedManyWithoutSubmissionInput;
  };

  export type SubmissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    abstract?: StringFieldUpdateOperationsInput | string;
    repoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    demoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    files?: SubmissionUpdatefilesInput | string[];
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    status?: EnumSubmissionStatusFieldUpdateOperationsInput | $Enums.SubmissionStatus;
    scoreAggregate?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    rank?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    hackathon?: HackathonUpdateOneRequiredWithoutSubmissionsNestedInput;
    team?: TeamUpdateOneRequiredWithoutSubmissionsNestedInput;
    track?: TrackUpdateOneWithoutSubmissionsNestedInput;
    scores?: ScoreUpdateManyWithoutSubmissionNestedInput;
  };

  export type SubmissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    hackathonId?: StringFieldUpdateOperationsInput | string;
    teamId?: StringFieldUpdateOperationsInput | string;
    trackId?: NullableStringFieldUpdateOperationsInput | string | null;
    title?: StringFieldUpdateOperationsInput | string;
    abstract?: StringFieldUpdateOperationsInput | string;
    repoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    demoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    files?: SubmissionUpdatefilesInput | string[];
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    status?: EnumSubmissionStatusFieldUpdateOperationsInput | $Enums.SubmissionStatus;
    scoreAggregate?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    rank?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    scores?: ScoreUncheckedUpdateManyWithoutSubmissionNestedInput;
  };

  export type SubmissionCreateManyInput = {
    id?: string;
    hackathonId: string;
    teamId: string;
    trackId?: string | null;
    title: string;
    abstract: string;
    repoUrl?: string | null;
    demoUrl?: string | null;
    videoUrl?: string | null;
    files?: SubmissionCreatefilesInput | string[];
    submittedAt?: Date | string | null;
    finalizedAt?: Date | string | null;
    status?: $Enums.SubmissionStatus;
    scoreAggregate?: Decimal | DecimalJsLike | number | string | null;
    rank?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type SubmissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    abstract?: StringFieldUpdateOperationsInput | string;
    repoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    demoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    files?: SubmissionUpdatefilesInput | string[];
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    status?: EnumSubmissionStatusFieldUpdateOperationsInput | $Enums.SubmissionStatus;
    scoreAggregate?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    rank?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type SubmissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    hackathonId?: StringFieldUpdateOperationsInput | string;
    teamId?: StringFieldUpdateOperationsInput | string;
    trackId?: NullableStringFieldUpdateOperationsInput | string | null;
    title?: StringFieldUpdateOperationsInput | string;
    abstract?: StringFieldUpdateOperationsInput | string;
    repoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    demoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    files?: SubmissionUpdatefilesInput | string[];
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    status?: EnumSubmissionStatusFieldUpdateOperationsInput | $Enums.SubmissionStatus;
    scoreAggregate?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    rank?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ScoreCreateInput = {
    id?: string;
    score: number;
    feedback?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    submission: SubmissionCreateNestedOneWithoutScoresInput;
    judge: JudgeCreateNestedOneWithoutScoresInput;
    criterion: CriteriaCreateNestedOneWithoutScoresInput;
  };

  export type ScoreUncheckedCreateInput = {
    id?: string;
    submissionId: string;
    judgeId: string;
    criterionId: string;
    score: number;
    feedback?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ScoreUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    score?: IntFieldUpdateOperationsInput | number;
    feedback?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    submission?: SubmissionUpdateOneRequiredWithoutScoresNestedInput;
    judge?: JudgeUpdateOneRequiredWithoutScoresNestedInput;
    criterion?: CriteriaUpdateOneRequiredWithoutScoresNestedInput;
  };

  export type ScoreUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    submissionId?: StringFieldUpdateOperationsInput | string;
    judgeId?: StringFieldUpdateOperationsInput | string;
    criterionId?: StringFieldUpdateOperationsInput | string;
    score?: IntFieldUpdateOperationsInput | number;
    feedback?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ScoreCreateManyInput = {
    id?: string;
    submissionId: string;
    judgeId: string;
    criterionId: string;
    score: number;
    feedback?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ScoreUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    score?: IntFieldUpdateOperationsInput | number;
    feedback?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ScoreUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    submissionId?: StringFieldUpdateOperationsInput | string;
    judgeId?: StringFieldUpdateOperationsInput | string;
    criterionId?: StringFieldUpdateOperationsInput | string;
    score?: IntFieldUpdateOperationsInput | number;
    feedback?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ChallengeCreateInput = {
    id?: string;
    slug: string;
    title: string;
    problemStatement: string;
    ownerOrg?: string | null;
    rewardType?: $Enums.RewardType | null;
    rewardValue?: string | null;
    categories?: ChallengeCreatecategoriesInput | string[];
    skills?: ChallengeCreateskillsInput | string[];
    attachments?: ChallengeCreateattachmentsInput | string[];
    status?: $Enums.ChallengeStatus;
    visibility?: $Enums.ChallengeVisibility;
    deadlineAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    owner: UserCreateNestedOneWithoutOwnedChallengesInput;
    submissions?: ChallengeSubmissionCreateNestedManyWithoutChallengeInput;
  };

  export type ChallengeUncheckedCreateInput = {
    id?: string;
    slug: string;
    title: string;
    problemStatement: string;
    ownerId: string;
    ownerOrg?: string | null;
    rewardType?: $Enums.RewardType | null;
    rewardValue?: string | null;
    categories?: ChallengeCreatecategoriesInput | string[];
    skills?: ChallengeCreateskillsInput | string[];
    attachments?: ChallengeCreateattachmentsInput | string[];
    status?: $Enums.ChallengeStatus;
    visibility?: $Enums.ChallengeVisibility;
    deadlineAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    submissions?: ChallengeSubmissionUncheckedCreateNestedManyWithoutChallengeInput;
  };

  export type ChallengeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    problemStatement?: StringFieldUpdateOperationsInput | string;
    ownerOrg?: NullableStringFieldUpdateOperationsInput | string | null;
    rewardType?: NullableEnumRewardTypeFieldUpdateOperationsInput | $Enums.RewardType | null;
    rewardValue?: NullableStringFieldUpdateOperationsInput | string | null;
    categories?: ChallengeUpdatecategoriesInput | string[];
    skills?: ChallengeUpdateskillsInput | string[];
    attachments?: ChallengeUpdateattachmentsInput | string[];
    status?: EnumChallengeStatusFieldUpdateOperationsInput | $Enums.ChallengeStatus;
    visibility?: EnumChallengeVisibilityFieldUpdateOperationsInput | $Enums.ChallengeVisibility;
    deadlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    owner?: UserUpdateOneRequiredWithoutOwnedChallengesNestedInput;
    submissions?: ChallengeSubmissionUpdateManyWithoutChallengeNestedInput;
  };

  export type ChallengeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    problemStatement?: StringFieldUpdateOperationsInput | string;
    ownerId?: StringFieldUpdateOperationsInput | string;
    ownerOrg?: NullableStringFieldUpdateOperationsInput | string | null;
    rewardType?: NullableEnumRewardTypeFieldUpdateOperationsInput | $Enums.RewardType | null;
    rewardValue?: NullableStringFieldUpdateOperationsInput | string | null;
    categories?: ChallengeUpdatecategoriesInput | string[];
    skills?: ChallengeUpdateskillsInput | string[];
    attachments?: ChallengeUpdateattachmentsInput | string[];
    status?: EnumChallengeStatusFieldUpdateOperationsInput | $Enums.ChallengeStatus;
    visibility?: EnumChallengeVisibilityFieldUpdateOperationsInput | $Enums.ChallengeVisibility;
    deadlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    submissions?: ChallengeSubmissionUncheckedUpdateManyWithoutChallengeNestedInput;
  };

  export type ChallengeCreateManyInput = {
    id?: string;
    slug: string;
    title: string;
    problemStatement: string;
    ownerId: string;
    ownerOrg?: string | null;
    rewardType?: $Enums.RewardType | null;
    rewardValue?: string | null;
    categories?: ChallengeCreatecategoriesInput | string[];
    skills?: ChallengeCreateskillsInput | string[];
    attachments?: ChallengeCreateattachmentsInput | string[];
    status?: $Enums.ChallengeStatus;
    visibility?: $Enums.ChallengeVisibility;
    deadlineAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ChallengeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    problemStatement?: StringFieldUpdateOperationsInput | string;
    ownerOrg?: NullableStringFieldUpdateOperationsInput | string | null;
    rewardType?: NullableEnumRewardTypeFieldUpdateOperationsInput | $Enums.RewardType | null;
    rewardValue?: NullableStringFieldUpdateOperationsInput | string | null;
    categories?: ChallengeUpdatecategoriesInput | string[];
    skills?: ChallengeUpdateskillsInput | string[];
    attachments?: ChallengeUpdateattachmentsInput | string[];
    status?: EnumChallengeStatusFieldUpdateOperationsInput | $Enums.ChallengeStatus;
    visibility?: EnumChallengeVisibilityFieldUpdateOperationsInput | $Enums.ChallengeVisibility;
    deadlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ChallengeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    problemStatement?: StringFieldUpdateOperationsInput | string;
    ownerId?: StringFieldUpdateOperationsInput | string;
    ownerOrg?: NullableStringFieldUpdateOperationsInput | string | null;
    rewardType?: NullableEnumRewardTypeFieldUpdateOperationsInput | $Enums.RewardType | null;
    rewardValue?: NullableStringFieldUpdateOperationsInput | string | null;
    categories?: ChallengeUpdatecategoriesInput | string[];
    skills?: ChallengeUpdateskillsInput | string[];
    attachments?: ChallengeUpdateattachmentsInput | string[];
    status?: EnumChallengeStatusFieldUpdateOperationsInput | $Enums.ChallengeStatus;
    visibility?: EnumChallengeVisibilityFieldUpdateOperationsInput | $Enums.ChallengeVisibility;
    deadlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ChallengeSubmissionCreateInput = {
    id?: string;
    title: string;
    repoUrl?: string | null;
    content: string;
    files?: ChallengeSubmissionCreatefilesInput | string[];
    status?: $Enums.ChallengeSubmissionStatus;
    score?: Decimal | DecimalJsLike | number | string | null;
    feedback?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    challenge: ChallengeCreateNestedOneWithoutSubmissionsInput;
    user?: UserCreateNestedOneWithoutChallengeSubmissionsInput;
    team?: TeamCreateNestedOneWithoutChallengeSubmissionsInput;
  };

  export type ChallengeSubmissionUncheckedCreateInput = {
    id?: string;
    challengeId: string;
    userId?: string | null;
    teamId?: string | null;
    title: string;
    repoUrl?: string | null;
    content: string;
    files?: ChallengeSubmissionCreatefilesInput | string[];
    status?: $Enums.ChallengeSubmissionStatus;
    score?: Decimal | DecimalJsLike | number | string | null;
    feedback?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ChallengeSubmissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    repoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    content?: StringFieldUpdateOperationsInput | string;
    files?: ChallengeSubmissionUpdatefilesInput | string[];
    status?:
      | EnumChallengeSubmissionStatusFieldUpdateOperationsInput
      | $Enums.ChallengeSubmissionStatus;
    score?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    feedback?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    challenge?: ChallengeUpdateOneRequiredWithoutSubmissionsNestedInput;
    user?: UserUpdateOneWithoutChallengeSubmissionsNestedInput;
    team?: TeamUpdateOneWithoutChallengeSubmissionsNestedInput;
  };

  export type ChallengeSubmissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    challengeId?: StringFieldUpdateOperationsInput | string;
    userId?: NullableStringFieldUpdateOperationsInput | string | null;
    teamId?: NullableStringFieldUpdateOperationsInput | string | null;
    title?: StringFieldUpdateOperationsInput | string;
    repoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    content?: StringFieldUpdateOperationsInput | string;
    files?: ChallengeSubmissionUpdatefilesInput | string[];
    status?:
      | EnumChallengeSubmissionStatusFieldUpdateOperationsInput
      | $Enums.ChallengeSubmissionStatus;
    score?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    feedback?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ChallengeSubmissionCreateManyInput = {
    id?: string;
    challengeId: string;
    userId?: string | null;
    teamId?: string | null;
    title: string;
    repoUrl?: string | null;
    content: string;
    files?: ChallengeSubmissionCreatefilesInput | string[];
    status?: $Enums.ChallengeSubmissionStatus;
    score?: Decimal | DecimalJsLike | number | string | null;
    feedback?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ChallengeSubmissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    repoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    content?: StringFieldUpdateOperationsInput | string;
    files?: ChallengeSubmissionUpdatefilesInput | string[];
    status?:
      | EnumChallengeSubmissionStatusFieldUpdateOperationsInput
      | $Enums.ChallengeSubmissionStatus;
    score?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    feedback?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ChallengeSubmissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    challengeId?: StringFieldUpdateOperationsInput | string;
    userId?: NullableStringFieldUpdateOperationsInput | string | null;
    teamId?: NullableStringFieldUpdateOperationsInput | string | null;
    title?: StringFieldUpdateOperationsInput | string;
    repoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    content?: StringFieldUpdateOperationsInput | string;
    files?: ChallengeSubmissionUpdatefilesInput | string[];
    status?:
      | EnumChallengeSubmissionStatusFieldUpdateOperationsInput
      | $Enums.ChallengeSubmissionStatus;
    score?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    feedback?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AnnouncementCreateInput = {
    id?: string;
    scope: $Enums.AnnouncementScope;
    title: string;
    body: string;
    pinned?: boolean;
    publishedAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    hackathon?: HackathonCreateNestedOneWithoutAnnouncementsInput;
  };

  export type AnnouncementUncheckedCreateInput = {
    id?: string;
    scope: $Enums.AnnouncementScope;
    scopeId?: string | null;
    title: string;
    body: string;
    pinned?: boolean;
    publishedAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type AnnouncementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    scope?: EnumAnnouncementScopeFieldUpdateOperationsInput | $Enums.AnnouncementScope;
    title?: StringFieldUpdateOperationsInput | string;
    body?: StringFieldUpdateOperationsInput | string;
    pinned?: BoolFieldUpdateOperationsInput | boolean;
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    hackathon?: HackathonUpdateOneWithoutAnnouncementsNestedInput;
  };

  export type AnnouncementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    scope?: EnumAnnouncementScopeFieldUpdateOperationsInput | $Enums.AnnouncementScope;
    scopeId?: NullableStringFieldUpdateOperationsInput | string | null;
    title?: StringFieldUpdateOperationsInput | string;
    body?: StringFieldUpdateOperationsInput | string;
    pinned?: BoolFieldUpdateOperationsInput | boolean;
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AnnouncementCreateManyInput = {
    id?: string;
    scope: $Enums.AnnouncementScope;
    scopeId?: string | null;
    title: string;
    body: string;
    pinned?: boolean;
    publishedAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type AnnouncementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    scope?: EnumAnnouncementScopeFieldUpdateOperationsInput | $Enums.AnnouncementScope;
    title?: StringFieldUpdateOperationsInput | string;
    body?: StringFieldUpdateOperationsInput | string;
    pinned?: BoolFieldUpdateOperationsInput | boolean;
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AnnouncementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    scope?: EnumAnnouncementScopeFieldUpdateOperationsInput | $Enums.AnnouncementScope;
    scopeId?: NullableStringFieldUpdateOperationsInput | string | null;
    title?: StringFieldUpdateOperationsInput | string;
    body?: StringFieldUpdateOperationsInput | string;
    pinned?: BoolFieldUpdateOperationsInput | boolean;
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type CommentThreadCreateInput = {
    id?: string;
    entityType: $Enums.CommentEntityType;
    entityId: string;
    createdAt?: Date | string;
    comments?: CommentCreateNestedManyWithoutThreadInput;
  };

  export type CommentThreadUncheckedCreateInput = {
    id?: string;
    entityType: $Enums.CommentEntityType;
    entityId: string;
    createdAt?: Date | string;
    comments?: CommentUncheckedCreateNestedManyWithoutThreadInput;
  };

  export type CommentThreadUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    entityType?: EnumCommentEntityTypeFieldUpdateOperationsInput | $Enums.CommentEntityType;
    entityId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    comments?: CommentUpdateManyWithoutThreadNestedInput;
  };

  export type CommentThreadUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    entityType?: EnumCommentEntityTypeFieldUpdateOperationsInput | $Enums.CommentEntityType;
    entityId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    comments?: CommentUncheckedUpdateManyWithoutThreadNestedInput;
  };

  export type CommentThreadCreateManyInput = {
    id?: string;
    entityType: $Enums.CommentEntityType;
    entityId: string;
    createdAt?: Date | string;
  };

  export type CommentThreadUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    entityType?: EnumCommentEntityTypeFieldUpdateOperationsInput | $Enums.CommentEntityType;
    entityId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type CommentThreadUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    entityType?: EnumCommentEntityTypeFieldUpdateOperationsInput | $Enums.CommentEntityType;
    entityId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type CommentCreateInput = {
    id?: string;
    body: string;
    isFlagged?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    thread: CommentThreadCreateNestedOneWithoutCommentsInput;
    author: UserCreateNestedOneWithoutCommentsInput;
    parent?: CommentCreateNestedOneWithoutRepliesInput;
    replies?: CommentCreateNestedManyWithoutParentInput;
  };

  export type CommentUncheckedCreateInput = {
    id?: string;
    threadId: string;
    authorId: string;
    parentId?: string | null;
    body: string;
    isFlagged?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    replies?: CommentUncheckedCreateNestedManyWithoutParentInput;
  };

  export type CommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    body?: StringFieldUpdateOperationsInput | string;
    isFlagged?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    thread?: CommentThreadUpdateOneRequiredWithoutCommentsNestedInput;
    author?: UserUpdateOneRequiredWithoutCommentsNestedInput;
    parent?: CommentUpdateOneWithoutRepliesNestedInput;
    replies?: CommentUpdateManyWithoutParentNestedInput;
  };

  export type CommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    threadId?: StringFieldUpdateOperationsInput | string;
    authorId?: StringFieldUpdateOperationsInput | string;
    parentId?: NullableStringFieldUpdateOperationsInput | string | null;
    body?: StringFieldUpdateOperationsInput | string;
    isFlagged?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    replies?: CommentUncheckedUpdateManyWithoutParentNestedInput;
  };

  export type CommentCreateManyInput = {
    id?: string;
    threadId: string;
    authorId: string;
    parentId?: string | null;
    body: string;
    isFlagged?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type CommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    body?: StringFieldUpdateOperationsInput | string;
    isFlagged?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type CommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    threadId?: StringFieldUpdateOperationsInput | string;
    authorId?: StringFieldUpdateOperationsInput | string;
    parentId?: NullableStringFieldUpdateOperationsInput | string | null;
    body?: StringFieldUpdateOperationsInput | string;
    isFlagged?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type GamificationProfileCreateInput = {
    xp?: number;
    level?: number;
    streakDays?: number;
    vaultKeys?: number;
    badges?: GamificationProfileCreatebadgesInput | string[];
    lastActivityAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    user: UserCreateNestedOneWithoutGamificationProfileInput;
  };

  export type GamificationProfileUncheckedCreateInput = {
    userId: string;
    xp?: number;
    level?: number;
    streakDays?: number;
    vaultKeys?: number;
    badges?: GamificationProfileCreatebadgesInput | string[];
    lastActivityAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type GamificationProfileUpdateInput = {
    xp?: IntFieldUpdateOperationsInput | number;
    level?: IntFieldUpdateOperationsInput | number;
    streakDays?: IntFieldUpdateOperationsInput | number;
    vaultKeys?: IntFieldUpdateOperationsInput | number;
    badges?: GamificationProfileUpdatebadgesInput | string[];
    lastActivityAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutGamificationProfileNestedInput;
  };

  export type GamificationProfileUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string;
    xp?: IntFieldUpdateOperationsInput | number;
    level?: IntFieldUpdateOperationsInput | number;
    streakDays?: IntFieldUpdateOperationsInput | number;
    vaultKeys?: IntFieldUpdateOperationsInput | number;
    badges?: GamificationProfileUpdatebadgesInput | string[];
    lastActivityAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type GamificationProfileCreateManyInput = {
    userId: string;
    xp?: number;
    level?: number;
    streakDays?: number;
    vaultKeys?: number;
    badges?: GamificationProfileCreatebadgesInput | string[];
    lastActivityAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type GamificationProfileUpdateManyMutationInput = {
    xp?: IntFieldUpdateOperationsInput | number;
    level?: IntFieldUpdateOperationsInput | number;
    streakDays?: IntFieldUpdateOperationsInput | number;
    vaultKeys?: IntFieldUpdateOperationsInput | number;
    badges?: GamificationProfileUpdatebadgesInput | string[];
    lastActivityAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type GamificationProfileUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string;
    xp?: IntFieldUpdateOperationsInput | number;
    level?: IntFieldUpdateOperationsInput | number;
    streakDays?: IntFieldUpdateOperationsInput | number;
    vaultKeys?: IntFieldUpdateOperationsInput | number;
    badges?: GamificationProfileUpdatebadgesInput | string[];
    lastActivityAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type BadgeCreateInput = {
    id?: string;
    slug: string;
    name: string;
    description: string;
    icon: string;
    xpRequired?: number;
    rarity?: string;
    createdAt?: Date | string;
  };

  export type BadgeUncheckedCreateInput = {
    id?: string;
    slug: string;
    name: string;
    description: string;
    icon: string;
    xpRequired?: number;
    rarity?: string;
    createdAt?: Date | string;
  };

  export type BadgeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    icon?: StringFieldUpdateOperationsInput | string;
    xpRequired?: IntFieldUpdateOperationsInput | number;
    rarity?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type BadgeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    icon?: StringFieldUpdateOperationsInput | string;
    xpRequired?: IntFieldUpdateOperationsInput | number;
    rarity?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type BadgeCreateManyInput = {
    id?: string;
    slug: string;
    name: string;
    description: string;
    icon: string;
    xpRequired?: number;
    rarity?: string;
    createdAt?: Date | string;
  };

  export type BadgeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    icon?: StringFieldUpdateOperationsInput | string;
    xpRequired?: IntFieldUpdateOperationsInput | number;
    rarity?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type BadgeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    icon?: StringFieldUpdateOperationsInput | string;
    xpRequired?: IntFieldUpdateOperationsInput | number;
    rarity?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type XpEventCreateInput = {
    id?: string;
    eventType: string;
    points: number;
    refType?: string | null;
    refId?: string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    user: UserCreateNestedOneWithoutXpEventsInput;
  };

  export type XpEventUncheckedCreateInput = {
    id?: string;
    userId: string;
    eventType: string;
    points: number;
    refType?: string | null;
    refId?: string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
  };

  export type XpEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventType?: StringFieldUpdateOperationsInput | string;
    points?: IntFieldUpdateOperationsInput | number;
    refType?: NullableStringFieldUpdateOperationsInput | string | null;
    refId?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutXpEventsNestedInput;
  };

  export type XpEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    eventType?: StringFieldUpdateOperationsInput | string;
    points?: IntFieldUpdateOperationsInput | number;
    refType?: NullableStringFieldUpdateOperationsInput | string | null;
    refId?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type XpEventCreateManyInput = {
    id?: string;
    userId: string;
    eventType: string;
    points: number;
    refType?: string | null;
    refId?: string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
  };

  export type XpEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventType?: StringFieldUpdateOperationsInput | string;
    points?: IntFieldUpdateOperationsInput | number;
    refType?: NullableStringFieldUpdateOperationsInput | string | null;
    refId?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type XpEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    eventType?: StringFieldUpdateOperationsInput | string;
    points?: IntFieldUpdateOperationsInput | number;
    refType?: NullableStringFieldUpdateOperationsInput | string | null;
    refId?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type LeaderboardSnapshotCreateInput = {
    id?: string;
    scope: $Enums.LeaderboardScope;
    scopeId?: string | null;
    period: $Enums.LeaderboardPeriod;
    data: JsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
  };

  export type LeaderboardSnapshotUncheckedCreateInput = {
    id?: string;
    scope: $Enums.LeaderboardScope;
    scopeId?: string | null;
    period: $Enums.LeaderboardPeriod;
    data: JsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
  };

  export type LeaderboardSnapshotUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    scope?: EnumLeaderboardScopeFieldUpdateOperationsInput | $Enums.LeaderboardScope;
    scopeId?: NullableStringFieldUpdateOperationsInput | string | null;
    period?: EnumLeaderboardPeriodFieldUpdateOperationsInput | $Enums.LeaderboardPeriod;
    data?: JsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type LeaderboardSnapshotUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    scope?: EnumLeaderboardScopeFieldUpdateOperationsInput | $Enums.LeaderboardScope;
    scopeId?: NullableStringFieldUpdateOperationsInput | string | null;
    period?: EnumLeaderboardPeriodFieldUpdateOperationsInput | $Enums.LeaderboardPeriod;
    data?: JsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type LeaderboardSnapshotCreateManyInput = {
    id?: string;
    scope: $Enums.LeaderboardScope;
    scopeId?: string | null;
    period: $Enums.LeaderboardPeriod;
    data: JsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
  };

  export type LeaderboardSnapshotUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    scope?: EnumLeaderboardScopeFieldUpdateOperationsInput | $Enums.LeaderboardScope;
    scopeId?: NullableStringFieldUpdateOperationsInput | string | null;
    period?: EnumLeaderboardPeriodFieldUpdateOperationsInput | $Enums.LeaderboardPeriod;
    data?: JsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type LeaderboardSnapshotUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    scope?: EnumLeaderboardScopeFieldUpdateOperationsInput | $Enums.LeaderboardScope;
    scopeId?: NullableStringFieldUpdateOperationsInput | string | null;
    period?: EnumLeaderboardPeriodFieldUpdateOperationsInput | $Enums.LeaderboardPeriod;
    data?: JsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type NotificationCreateInput = {
    id?: string;
    type: string;
    data: JsonNullValueInput | InputJsonValue;
    readAt?: Date | string | null;
    createdAt?: Date | string;
    user: UserCreateNestedOneWithoutNotificationsInput;
  };

  export type NotificationUncheckedCreateInput = {
    id?: string;
    userId: string;
    type: string;
    data: JsonNullValueInput | InputJsonValue;
    readAt?: Date | string | null;
    createdAt?: Date | string;
  };

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    data?: JsonNullValueInput | InputJsonValue;
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput;
  };

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    data?: JsonNullValueInput | InputJsonValue;
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type NotificationCreateManyInput = {
    id?: string;
    userId: string;
    type: string;
    data: JsonNullValueInput | InputJsonValue;
    readAt?: Date | string | null;
    createdAt?: Date | string;
  };

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    data?: JsonNullValueInput | InputJsonValue;
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    data?: JsonNullValueInput | InputJsonValue;
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ReportCreateInput = {
    id?: string;
    entityType: string;
    entityId: string;
    reason: string;
    status?: $Enums.ReportStatus;
    resolution?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    reporter: UserCreateNestedOneWithoutReportsInput;
  };

  export type ReportUncheckedCreateInput = {
    id?: string;
    reporterId: string;
    entityType: string;
    entityId: string;
    reason: string;
    status?: $Enums.ReportStatus;
    resolution?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ReportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    entityType?: StringFieldUpdateOperationsInput | string;
    entityId?: StringFieldUpdateOperationsInput | string;
    reason?: StringFieldUpdateOperationsInput | string;
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus;
    resolution?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    reporter?: UserUpdateOneRequiredWithoutReportsNestedInput;
  };

  export type ReportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    reporterId?: StringFieldUpdateOperationsInput | string;
    entityType?: StringFieldUpdateOperationsInput | string;
    entityId?: StringFieldUpdateOperationsInput | string;
    reason?: StringFieldUpdateOperationsInput | string;
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus;
    resolution?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ReportCreateManyInput = {
    id?: string;
    reporterId: string;
    entityType: string;
    entityId: string;
    reason: string;
    status?: $Enums.ReportStatus;
    resolution?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ReportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    entityType?: StringFieldUpdateOperationsInput | string;
    entityId?: StringFieldUpdateOperationsInput | string;
    reason?: StringFieldUpdateOperationsInput | string;
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus;
    resolution?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ReportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    reporterId?: StringFieldUpdateOperationsInput | string;
    entityType?: StringFieldUpdateOperationsInput | string;
    entityId?: StringFieldUpdateOperationsInput | string;
    reason?: StringFieldUpdateOperationsInput | string;
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus;
    resolution?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type FileCreateInput = {
    id?: string;
    filename: string;
    mimetype: string;
    size: number;
    key: string;
    url: string;
    type: string;
    entityId?: string | null;
    entityType?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    uploadedBy: UserCreateNestedOneWithoutUploadedFilesInput;
  };

  export type FileUncheckedCreateInput = {
    id?: string;
    filename: string;
    mimetype: string;
    size: number;
    key: string;
    url: string;
    type: string;
    uploadedById: string;
    entityId?: string | null;
    entityType?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
  };

  export type FileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    filename?: StringFieldUpdateOperationsInput | string;
    mimetype?: StringFieldUpdateOperationsInput | string;
    size?: IntFieldUpdateOperationsInput | number;
    key?: StringFieldUpdateOperationsInput | string;
    url?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    entityId?: NullableStringFieldUpdateOperationsInput | string | null;
    entityType?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    uploadedBy?: UserUpdateOneRequiredWithoutUploadedFilesNestedInput;
  };

  export type FileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    filename?: StringFieldUpdateOperationsInput | string;
    mimetype?: StringFieldUpdateOperationsInput | string;
    size?: IntFieldUpdateOperationsInput | number;
    key?: StringFieldUpdateOperationsInput | string;
    url?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    uploadedById?: StringFieldUpdateOperationsInput | string;
    entityId?: NullableStringFieldUpdateOperationsInput | string | null;
    entityType?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
  };

  export type FileCreateManyInput = {
    id?: string;
    filename: string;
    mimetype: string;
    size: number;
    key: string;
    url: string;
    type: string;
    uploadedById: string;
    entityId?: string | null;
    entityType?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
  };

  export type FileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    filename?: StringFieldUpdateOperationsInput | string;
    mimetype?: StringFieldUpdateOperationsInput | string;
    size?: IntFieldUpdateOperationsInput | number;
    key?: StringFieldUpdateOperationsInput | string;
    url?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    entityId?: NullableStringFieldUpdateOperationsInput | string | null;
    entityType?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
  };

  export type FileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    filename?: StringFieldUpdateOperationsInput | string;
    mimetype?: StringFieldUpdateOperationsInput | string;
    size?: IntFieldUpdateOperationsInput | number;
    key?: StringFieldUpdateOperationsInput | string;
    url?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    uploadedById?: StringFieldUpdateOperationsInput | string;
    entityId?: NullableStringFieldUpdateOperationsInput | string | null;
    entityType?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
  };

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedStringFilter<$PrismaModel> | string;
  };

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null;
  };

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedStringNullableFilter<$PrismaModel> | string | null;
  };

  export type EnumRoleNullableListFilter<$PrismaModel = never> = {
    equals?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null;
    has?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel> | null;
    hasEvery?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>;
    hasSome?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>;
    isEmpty?: boolean;
  };

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolFilter<$PrismaModel> | boolean;
  };

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string;
  };

  export type AccountListRelationFilter = {
    every?: AccountWhereInput;
    some?: AccountWhereInput;
    none?: AccountWhereInput;
  };

  export type SessionListRelationFilter = {
    every?: SessionWhereInput;
    some?: SessionWhereInput;
    none?: SessionWhereInput;
  };

  export type ApiKeyListRelationFilter = {
    every?: ApiKeyWhereInput;
    some?: ApiKeyWhereInput;
    none?: ApiKeyWhereInput;
  };

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput;
    some?: AuditLogWhereInput;
    none?: AuditLogWhereInput;
  };

  export type TeamMemberListRelationFilter = {
    every?: TeamMemberWhereInput;
    some?: TeamMemberWhereInput;
    none?: TeamMemberWhereInput;
  };

  export type MentorListRelationFilter = {
    every?: MentorWhereInput;
    some?: MentorWhereInput;
    none?: MentorWhereInput;
  };

  export type JudgeListRelationFilter = {
    every?: JudgeWhereInput;
    some?: JudgeWhereInput;
    none?: JudgeWhereInput;
  };

  export type ChallengeSubmissionListRelationFilter = {
    every?: ChallengeSubmissionWhereInput;
    some?: ChallengeSubmissionWhereInput;
    none?: ChallengeSubmissionWhereInput;
  };

  export type CommentListRelationFilter = {
    every?: CommentWhereInput;
    some?: CommentWhereInput;
    none?: CommentWhereInput;
  };

  export type GamificationProfileNullableRelationFilter = {
    is?: GamificationProfileWhereInput | null;
    isNot?: GamificationProfileWhereInput | null;
  };

  export type XpEventListRelationFilter = {
    every?: XpEventWhereInput;
    some?: XpEventWhereInput;
    none?: XpEventWhereInput;
  };

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput;
    some?: NotificationWhereInput;
    none?: NotificationWhereInput;
  };

  export type ReportListRelationFilter = {
    every?: ReportWhereInput;
    some?: ReportWhereInput;
    none?: ReportWhereInput;
  };

  export type FileListRelationFilter = {
    every?: FileWhereInput;
    some?: FileWhereInput;
    none?: FileWhereInput;
  };

  export type ChallengeListRelationFilter = {
    every?: ChallengeWhereInput;
    some?: ChallengeWhereInput;
    none?: ChallengeWhereInput;
  };

  export type SortOrderInput = {
    sort: SortOrder;
    nulls?: NullsOrder;
  };

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type ApiKeyOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type TeamMemberOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type MentorOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type JudgeOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type ChallengeSubmissionOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type CommentOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type XpEventOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type ReportOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type FileOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type ChallengeOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder;
    email?: SortOrder;
    emailVerified?: SortOrder;
    name?: SortOrder;
    handle?: SortOrder;
    avatarUrl?: SortOrder;
    bio?: SortOrder;
    organization?: SortOrder;
    password?: SortOrder;
    roles?: SortOrder;
    totpSecret?: SortOrder;
    totpEnabled?: SortOrder;
    passwordResetToken?: SortOrder;
    passwordResetExpires?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    lastLoginAt?: SortOrder;
    isActive?: SortOrder;
    isBanned?: SortOrder;
  };

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder;
    email?: SortOrder;
    emailVerified?: SortOrder;
    name?: SortOrder;
    handle?: SortOrder;
    avatarUrl?: SortOrder;
    bio?: SortOrder;
    organization?: SortOrder;
    password?: SortOrder;
    totpSecret?: SortOrder;
    totpEnabled?: SortOrder;
    passwordResetToken?: SortOrder;
    passwordResetExpires?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    lastLoginAt?: SortOrder;
    isActive?: SortOrder;
    isBanned?: SortOrder;
  };

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder;
    email?: SortOrder;
    emailVerified?: SortOrder;
    name?: SortOrder;
    handle?: SortOrder;
    avatarUrl?: SortOrder;
    bio?: SortOrder;
    organization?: SortOrder;
    password?: SortOrder;
    totpSecret?: SortOrder;
    totpEnabled?: SortOrder;
    passwordResetToken?: SortOrder;
    passwordResetExpires?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    lastLoginAt?: SortOrder;
    isActive?: SortOrder;
    isBanned?: SortOrder;
  };

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedStringFilter<$PrismaModel>;
    _max?: NestedStringFilter<$PrismaModel>;
  };

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedDateTimeNullableFilter<$PrismaModel>;
    _max?: NestedDateTimeNullableFilter<$PrismaModel>;
  };

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedStringNullableFilter<$PrismaModel>;
    _max?: NestedStringNullableFilter<$PrismaModel>;
  };

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedBoolFilter<$PrismaModel>;
    _max?: NestedBoolFilter<$PrismaModel>;
  };

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedDateTimeFilter<$PrismaModel>;
    _max?: NestedDateTimeFilter<$PrismaModel>;
  };

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableFilter<$PrismaModel> | number | null;
  };

  export type UserRelationFilter = {
    is?: UserWhereInput;
    isNot?: UserWhereInput;
  };

  export type AccountProviderProviderAccountIdCompoundUniqueInput = {
    provider: string;
    providerAccountId: string;
  };

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    type?: SortOrder;
    provider?: SortOrder;
    providerAccountId?: SortOrder;
    refresh_token?: SortOrder;
    access_token?: SortOrder;
    expires_at?: SortOrder;
    token_type?: SortOrder;
    scope?: SortOrder;
    id_token?: SortOrder;
    session_state?: SortOrder;
  };

  export type AccountAvgOrderByAggregateInput = {
    expires_at?: SortOrder;
  };

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    type?: SortOrder;
    provider?: SortOrder;
    providerAccountId?: SortOrder;
    refresh_token?: SortOrder;
    access_token?: SortOrder;
    expires_at?: SortOrder;
    token_type?: SortOrder;
    scope?: SortOrder;
    id_token?: SortOrder;
    session_state?: SortOrder;
  };

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    type?: SortOrder;
    provider?: SortOrder;
    providerAccountId?: SortOrder;
    refresh_token?: SortOrder;
    access_token?: SortOrder;
    expires_at?: SortOrder;
    token_type?: SortOrder;
    scope?: SortOrder;
    id_token?: SortOrder;
    session_state?: SortOrder;
  };

  export type AccountSumOrderByAggregateInput = {
    expires_at?: SortOrder;
  };

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedFloatNullableFilter<$PrismaModel>;
    _sum?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedIntNullableFilter<$PrismaModel>;
    _max?: NestedIntNullableFilter<$PrismaModel>;
  };

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder;
    sessionToken?: SortOrder;
    userId?: SortOrder;
    expires?: SortOrder;
  };

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder;
    sessionToken?: SortOrder;
    userId?: SortOrder;
    expires?: SortOrder;
  };

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder;
    sessionToken?: SortOrder;
    userId?: SortOrder;
    expires?: SortOrder;
  };

  export type VerificationTokenIdentifierTokenCompoundUniqueInput = {
    identifier: string;
    token: string;
  };

  export type VerificationTokenCountOrderByAggregateInput = {
    identifier?: SortOrder;
    token?: SortOrder;
    expires?: SortOrder;
  };

  export type VerificationTokenMaxOrderByAggregateInput = {
    identifier?: SortOrder;
    token?: SortOrder;
    expires?: SortOrder;
  };

  export type VerificationTokenMinOrderByAggregateInput = {
    identifier?: SortOrder;
    token?: SortOrder;
    expires?: SortOrder;
  };

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    has?: string | StringFieldRefInput<$PrismaModel> | null;
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>;
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>;
    isEmpty?: boolean;
  };

  export type ApiKeyCountOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    name?: SortOrder;
    hashedKey?: SortOrder;
    scopes?: SortOrder;
    lastUsedAt?: SortOrder;
    expiresAt?: SortOrder;
    createdAt?: SortOrder;
    isActive?: SortOrder;
  };

  export type ApiKeyMaxOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    name?: SortOrder;
    hashedKey?: SortOrder;
    lastUsedAt?: SortOrder;
    expiresAt?: SortOrder;
    createdAt?: SortOrder;
    isActive?: SortOrder;
  };

  export type ApiKeyMinOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    name?: SortOrder;
    hashedKey?: SortOrder;
    lastUsedAt?: SortOrder;
    expiresAt?: SortOrder;
    createdAt?: SortOrder;
    isActive?: SortOrder;
  };
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<JsonNullableFilterBase<$PrismaModel>>,
          Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>
        >,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>;

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter;
    path?: string[];
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter;
  };

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null;
    isNot?: UserWhereInput | null;
  };

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder;
    actorId?: SortOrder;
    action?: SortOrder;
    entityType?: SortOrder;
    entityId?: SortOrder;
    metadata?: SortOrder;
    ipAddress?: SortOrder;
    userAgent?: SortOrder;
    createdAt?: SortOrder;
  };

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder;
    actorId?: SortOrder;
    action?: SortOrder;
    entityType?: SortOrder;
    entityId?: SortOrder;
    ipAddress?: SortOrder;
    userAgent?: SortOrder;
    createdAt?: SortOrder;
  };

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder;
    actorId?: SortOrder;
    action?: SortOrder;
    entityType?: SortOrder;
    entityId?: SortOrder;
    ipAddress?: SortOrder;
    userAgent?: SortOrder;
    createdAt?: SortOrder;
  };
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>,
          Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>
        >,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>;

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter;
    path?: string[];
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedJsonNullableFilter<$PrismaModel>;
    _max?: NestedJsonNullableFilter<$PrismaModel>;
  };

  export type EnumHackathonStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.HackathonStatus | EnumHackathonStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.HackathonStatus[] | ListEnumHackathonStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.HackathonStatus[] | ListEnumHackathonStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumHackathonStatusFilter<$PrismaModel> | $Enums.HackathonStatus;
  };

  export type EnumHackathonLocationFilter<$PrismaModel = never> = {
    equals?: $Enums.HackathonLocation | EnumHackathonLocationFieldRefInput<$PrismaModel>;
    in?: $Enums.HackathonLocation[] | ListEnumHackathonLocationFieldRefInput<$PrismaModel>;
    notIn?: $Enums.HackathonLocation[] | ListEnumHackathonLocationFieldRefInput<$PrismaModel>;
    not?: NestedEnumHackathonLocationFilter<$PrismaModel> | $Enums.HackathonLocation;
  };

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null;
    in?:
      | Decimal[]
      | DecimalJsLike[]
      | number[]
      | string[]
      | ListDecimalFieldRefInput<$PrismaModel>
      | null;
    notIn?:
      | Decimal[]
      | DecimalJsLike[]
      | number[]
      | string[]
      | ListDecimalFieldRefInput<$PrismaModel>
      | null;
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    not?:
      | NestedDecimalNullableFilter<$PrismaModel>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
  };

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntFilter<$PrismaModel> | number;
  };

  export type TrackListRelationFilter = {
    every?: TrackWhereInput;
    some?: TrackWhereInput;
    none?: TrackWhereInput;
  };

  export type TeamListRelationFilter = {
    every?: TeamWhereInput;
    some?: TeamWhereInput;
    none?: TeamWhereInput;
  };

  export type CriteriaListRelationFilter = {
    every?: CriteriaWhereInput;
    some?: CriteriaWhereInput;
    none?: CriteriaWhereInput;
  };

  export type SubmissionListRelationFilter = {
    every?: SubmissionWhereInput;
    some?: SubmissionWhereInput;
    none?: SubmissionWhereInput;
  };

  export type AnnouncementListRelationFilter = {
    every?: AnnouncementWhereInput;
    some?: AnnouncementWhereInput;
    none?: AnnouncementWhereInput;
  };

  export type TrackOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type TeamOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type CriteriaOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type SubmissionOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type AnnouncementOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type HackathonCountOrderByAggregateInput = {
    id?: SortOrder;
    slug?: SortOrder;
    title?: SortOrder;
    description?: SortOrder;
    coverImage?: SortOrder;
    status?: SortOrder;
    location?: SortOrder;
    registrationOpensAt?: SortOrder;
    registrationClosesAt?: SortOrder;
    startsAt?: SortOrder;
    endsAt?: SortOrder;
    judgingEndsAt?: SortOrder;
    prizePool?: SortOrder;
    maxTeamSize?: SortOrder;
    allowSoloTeams?: SortOrder;
    rules?: SortOrder;
    schedule?: SortOrder;
    metadata?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type HackathonAvgOrderByAggregateInput = {
    prizePool?: SortOrder;
    maxTeamSize?: SortOrder;
  };

  export type HackathonMaxOrderByAggregateInput = {
    id?: SortOrder;
    slug?: SortOrder;
    title?: SortOrder;
    description?: SortOrder;
    coverImage?: SortOrder;
    status?: SortOrder;
    location?: SortOrder;
    registrationOpensAt?: SortOrder;
    registrationClosesAt?: SortOrder;
    startsAt?: SortOrder;
    endsAt?: SortOrder;
    judgingEndsAt?: SortOrder;
    prizePool?: SortOrder;
    maxTeamSize?: SortOrder;
    allowSoloTeams?: SortOrder;
    rules?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type HackathonMinOrderByAggregateInput = {
    id?: SortOrder;
    slug?: SortOrder;
    title?: SortOrder;
    description?: SortOrder;
    coverImage?: SortOrder;
    status?: SortOrder;
    location?: SortOrder;
    registrationOpensAt?: SortOrder;
    registrationClosesAt?: SortOrder;
    startsAt?: SortOrder;
    endsAt?: SortOrder;
    judgingEndsAt?: SortOrder;
    prizePool?: SortOrder;
    maxTeamSize?: SortOrder;
    allowSoloTeams?: SortOrder;
    rules?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type HackathonSumOrderByAggregateInput = {
    prizePool?: SortOrder;
    maxTeamSize?: SortOrder;
  };

  export type EnumHackathonStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.HackathonStatus | EnumHackathonStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.HackathonStatus[] | ListEnumHackathonStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.HackathonStatus[] | ListEnumHackathonStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumHackathonStatusWithAggregatesFilter<$PrismaModel> | $Enums.HackathonStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumHackathonStatusFilter<$PrismaModel>;
    _max?: NestedEnumHackathonStatusFilter<$PrismaModel>;
  };

  export type EnumHackathonLocationWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.HackathonLocation | EnumHackathonLocationFieldRefInput<$PrismaModel>;
    in?: $Enums.HackathonLocation[] | ListEnumHackathonLocationFieldRefInput<$PrismaModel>;
    notIn?: $Enums.HackathonLocation[] | ListEnumHackathonLocationFieldRefInput<$PrismaModel>;
    not?: NestedEnumHackathonLocationWithAggregatesFilter<$PrismaModel> | $Enums.HackathonLocation;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumHackathonLocationFilter<$PrismaModel>;
    _max?: NestedEnumHackathonLocationFilter<$PrismaModel>;
  };

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null;
    in?:
      | Decimal[]
      | DecimalJsLike[]
      | number[]
      | string[]
      | ListDecimalFieldRefInput<$PrismaModel>
      | null;
    notIn?:
      | Decimal[]
      | DecimalJsLike[]
      | number[]
      | string[]
      | ListDecimalFieldRefInput<$PrismaModel>
      | null;
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    not?:
      | NestedDecimalNullableWithAggregatesFilter<$PrismaModel>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedDecimalNullableFilter<$PrismaModel>;
    _sum?: NestedDecimalNullableFilter<$PrismaModel>;
    _min?: NestedDecimalNullableFilter<$PrismaModel>;
    _max?: NestedDecimalNullableFilter<$PrismaModel>;
  };

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedIntFilter<$PrismaModel>;
    _min?: NestedIntFilter<$PrismaModel>;
    _max?: NestedIntFilter<$PrismaModel>;
  };

  export type HackathonRelationFilter = {
    is?: HackathonWhereInput;
    isNot?: HackathonWhereInput;
  };

  export type TrackCountOrderByAggregateInput = {
    id?: SortOrder;
    hackathonId?: SortOrder;
    title?: SortOrder;
    description?: SortOrder;
    order?: SortOrder;
    createdAt?: SortOrder;
  };

  export type TrackAvgOrderByAggregateInput = {
    order?: SortOrder;
  };

  export type TrackMaxOrderByAggregateInput = {
    id?: SortOrder;
    hackathonId?: SortOrder;
    title?: SortOrder;
    description?: SortOrder;
    order?: SortOrder;
    createdAt?: SortOrder;
  };

  export type TrackMinOrderByAggregateInput = {
    id?: SortOrder;
    hackathonId?: SortOrder;
    title?: SortOrder;
    description?: SortOrder;
    order?: SortOrder;
    createdAt?: SortOrder;
  };

  export type TrackSumOrderByAggregateInput = {
    order?: SortOrder;
  };

  export type TeamCountOrderByAggregateInput = {
    id?: SortOrder;
    hackathonId?: SortOrder;
    name?: SortOrder;
    bio?: SortOrder;
    logoUrl?: SortOrder;
    repoUrl?: SortOrder;
    demoUrl?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type TeamMaxOrderByAggregateInput = {
    id?: SortOrder;
    hackathonId?: SortOrder;
    name?: SortOrder;
    bio?: SortOrder;
    logoUrl?: SortOrder;
    repoUrl?: SortOrder;
    demoUrl?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type TeamMinOrderByAggregateInput = {
    id?: SortOrder;
    hackathonId?: SortOrder;
    name?: SortOrder;
    bio?: SortOrder;
    logoUrl?: SortOrder;
    repoUrl?: SortOrder;
    demoUrl?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type EnumTeamMemberRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.TeamMemberRole | EnumTeamMemberRoleFieldRefInput<$PrismaModel>;
    in?: $Enums.TeamMemberRole[] | ListEnumTeamMemberRoleFieldRefInput<$PrismaModel>;
    notIn?: $Enums.TeamMemberRole[] | ListEnumTeamMemberRoleFieldRefInput<$PrismaModel>;
    not?: NestedEnumTeamMemberRoleFilter<$PrismaModel> | $Enums.TeamMemberRole;
  };

  export type TeamRelationFilter = {
    is?: TeamWhereInput;
    isNot?: TeamWhereInput;
  };

  export type TeamMemberTeamIdUserIdCompoundUniqueInput = {
    teamId: string;
    userId: string;
  };

  export type TeamMemberCountOrderByAggregateInput = {
    teamId?: SortOrder;
    userId?: SortOrder;
    role?: SortOrder;
    joinedAt?: SortOrder;
  };

  export type TeamMemberMaxOrderByAggregateInput = {
    teamId?: SortOrder;
    userId?: SortOrder;
    role?: SortOrder;
    joinedAt?: SortOrder;
  };

  export type TeamMemberMinOrderByAggregateInput = {
    teamId?: SortOrder;
    userId?: SortOrder;
    role?: SortOrder;
    joinedAt?: SortOrder;
  };

  export type EnumTeamMemberRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TeamMemberRole | EnumTeamMemberRoleFieldRefInput<$PrismaModel>;
    in?: $Enums.TeamMemberRole[] | ListEnumTeamMemberRoleFieldRefInput<$PrismaModel>;
    notIn?: $Enums.TeamMemberRole[] | ListEnumTeamMemberRoleFieldRefInput<$PrismaModel>;
    not?: NestedEnumTeamMemberRoleWithAggregatesFilter<$PrismaModel> | $Enums.TeamMemberRole;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumTeamMemberRoleFilter<$PrismaModel>;
    _max?: NestedEnumTeamMemberRoleFilter<$PrismaModel>;
  };

  export type MentorSessionListRelationFilter = {
    every?: MentorSessionWhereInput;
    some?: MentorSessionWhereInput;
    none?: MentorSessionWhereInput;
  };

  export type MentorSessionOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type MentorUserIdHackathonIdCompoundUniqueInput = {
    userId: string;
    hackathonId: string;
  };

  export type MentorCountOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    hackathonId?: SortOrder;
    bio?: SortOrder;
    calendlyUrl?: SortOrder;
    expertise?: SortOrder;
    createdAt?: SortOrder;
  };

  export type MentorMaxOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    hackathonId?: SortOrder;
    bio?: SortOrder;
    calendlyUrl?: SortOrder;
    createdAt?: SortOrder;
  };

  export type MentorMinOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    hackathonId?: SortOrder;
    bio?: SortOrder;
    calendlyUrl?: SortOrder;
    createdAt?: SortOrder;
  };

  export type MentorRelationFilter = {
    is?: MentorWhereInput;
    isNot?: MentorWhereInput;
  };

  export type MentorSessionCountOrderByAggregateInput = {
    id?: SortOrder;
    mentorId?: SortOrder;
    title?: SortOrder;
    startsAt?: SortOrder;
    endsAt?: SortOrder;
    capacity?: SortOrder;
    booked?: SortOrder;
    meetingUrl?: SortOrder;
    createdAt?: SortOrder;
  };

  export type MentorSessionAvgOrderByAggregateInput = {
    capacity?: SortOrder;
    booked?: SortOrder;
  };

  export type MentorSessionMaxOrderByAggregateInput = {
    id?: SortOrder;
    mentorId?: SortOrder;
    title?: SortOrder;
    startsAt?: SortOrder;
    endsAt?: SortOrder;
    capacity?: SortOrder;
    booked?: SortOrder;
    meetingUrl?: SortOrder;
    createdAt?: SortOrder;
  };

  export type MentorSessionMinOrderByAggregateInput = {
    id?: SortOrder;
    mentorId?: SortOrder;
    title?: SortOrder;
    startsAt?: SortOrder;
    endsAt?: SortOrder;
    capacity?: SortOrder;
    booked?: SortOrder;
    meetingUrl?: SortOrder;
    createdAt?: SortOrder;
  };

  export type MentorSessionSumOrderByAggregateInput = {
    capacity?: SortOrder;
    booked?: SortOrder;
  };

  export type ScoreListRelationFilter = {
    every?: ScoreWhereInput;
    some?: ScoreWhereInput;
    none?: ScoreWhereInput;
  };

  export type ScoreOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type JudgeUserIdHackathonIdCompoundUniqueInput = {
    userId: string;
    hackathonId: string;
  };

  export type JudgeCountOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    hackathonId?: SortOrder;
    bio?: SortOrder;
    createdAt?: SortOrder;
  };

  export type JudgeMaxOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    hackathonId?: SortOrder;
    bio?: SortOrder;
    createdAt?: SortOrder;
  };

  export type JudgeMinOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    hackathonId?: SortOrder;
    bio?: SortOrder;
    createdAt?: SortOrder;
  };

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>;
    notIn?:
      | Decimal[]
      | DecimalJsLike[]
      | number[]
      | string[]
      | ListDecimalFieldRefInput<$PrismaModel>;
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string;
  };

  export type CriteriaCountOrderByAggregateInput = {
    id?: SortOrder;
    hackathonId?: SortOrder;
    name?: SortOrder;
    description?: SortOrder;
    maxScore?: SortOrder;
    weight?: SortOrder;
    order?: SortOrder;
  };

  export type CriteriaAvgOrderByAggregateInput = {
    maxScore?: SortOrder;
    weight?: SortOrder;
    order?: SortOrder;
  };

  export type CriteriaMaxOrderByAggregateInput = {
    id?: SortOrder;
    hackathonId?: SortOrder;
    name?: SortOrder;
    description?: SortOrder;
    maxScore?: SortOrder;
    weight?: SortOrder;
    order?: SortOrder;
  };

  export type CriteriaMinOrderByAggregateInput = {
    id?: SortOrder;
    hackathonId?: SortOrder;
    name?: SortOrder;
    description?: SortOrder;
    maxScore?: SortOrder;
    weight?: SortOrder;
    order?: SortOrder;
  };

  export type CriteriaSumOrderByAggregateInput = {
    maxScore?: SortOrder;
    weight?: SortOrder;
    order?: SortOrder;
  };

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>;
    notIn?:
      | Decimal[]
      | DecimalJsLike[]
      | number[]
      | string[]
      | ListDecimalFieldRefInput<$PrismaModel>;
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    not?:
      | NestedDecimalWithAggregatesFilter<$PrismaModel>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedDecimalFilter<$PrismaModel>;
    _sum?: NestedDecimalFilter<$PrismaModel>;
    _min?: NestedDecimalFilter<$PrismaModel>;
    _max?: NestedDecimalFilter<$PrismaModel>;
  };

  export type EnumSubmissionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubmissionStatus | EnumSubmissionStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.SubmissionStatus[] | ListEnumSubmissionStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.SubmissionStatus[] | ListEnumSubmissionStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumSubmissionStatusFilter<$PrismaModel> | $Enums.SubmissionStatus;
  };

  export type TrackNullableRelationFilter = {
    is?: TrackWhereInput | null;
    isNot?: TrackWhereInput | null;
  };

  export type SubmissionCountOrderByAggregateInput = {
    id?: SortOrder;
    hackathonId?: SortOrder;
    teamId?: SortOrder;
    trackId?: SortOrder;
    title?: SortOrder;
    abstract?: SortOrder;
    repoUrl?: SortOrder;
    demoUrl?: SortOrder;
    videoUrl?: SortOrder;
    files?: SortOrder;
    submittedAt?: SortOrder;
    finalizedAt?: SortOrder;
    status?: SortOrder;
    scoreAggregate?: SortOrder;
    rank?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type SubmissionAvgOrderByAggregateInput = {
    scoreAggregate?: SortOrder;
    rank?: SortOrder;
  };

  export type SubmissionMaxOrderByAggregateInput = {
    id?: SortOrder;
    hackathonId?: SortOrder;
    teamId?: SortOrder;
    trackId?: SortOrder;
    title?: SortOrder;
    abstract?: SortOrder;
    repoUrl?: SortOrder;
    demoUrl?: SortOrder;
    videoUrl?: SortOrder;
    submittedAt?: SortOrder;
    finalizedAt?: SortOrder;
    status?: SortOrder;
    scoreAggregate?: SortOrder;
    rank?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type SubmissionMinOrderByAggregateInput = {
    id?: SortOrder;
    hackathonId?: SortOrder;
    teamId?: SortOrder;
    trackId?: SortOrder;
    title?: SortOrder;
    abstract?: SortOrder;
    repoUrl?: SortOrder;
    demoUrl?: SortOrder;
    videoUrl?: SortOrder;
    submittedAt?: SortOrder;
    finalizedAt?: SortOrder;
    status?: SortOrder;
    scoreAggregate?: SortOrder;
    rank?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type SubmissionSumOrderByAggregateInput = {
    scoreAggregate?: SortOrder;
    rank?: SortOrder;
  };

  export type EnumSubmissionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubmissionStatus | EnumSubmissionStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.SubmissionStatus[] | ListEnumSubmissionStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.SubmissionStatus[] | ListEnumSubmissionStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumSubmissionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubmissionStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumSubmissionStatusFilter<$PrismaModel>;
    _max?: NestedEnumSubmissionStatusFilter<$PrismaModel>;
  };

  export type SubmissionRelationFilter = {
    is?: SubmissionWhereInput;
    isNot?: SubmissionWhereInput;
  };

  export type JudgeRelationFilter = {
    is?: JudgeWhereInput;
    isNot?: JudgeWhereInput;
  };

  export type CriteriaRelationFilter = {
    is?: CriteriaWhereInput;
    isNot?: CriteriaWhereInput;
  };

  export type ScoreSubmissionIdJudgeIdCriterionIdCompoundUniqueInput = {
    submissionId: string;
    judgeId: string;
    criterionId: string;
  };

  export type ScoreCountOrderByAggregateInput = {
    id?: SortOrder;
    submissionId?: SortOrder;
    judgeId?: SortOrder;
    criterionId?: SortOrder;
    score?: SortOrder;
    feedback?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type ScoreAvgOrderByAggregateInput = {
    score?: SortOrder;
  };

  export type ScoreMaxOrderByAggregateInput = {
    id?: SortOrder;
    submissionId?: SortOrder;
    judgeId?: SortOrder;
    criterionId?: SortOrder;
    score?: SortOrder;
    feedback?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type ScoreMinOrderByAggregateInput = {
    id?: SortOrder;
    submissionId?: SortOrder;
    judgeId?: SortOrder;
    criterionId?: SortOrder;
    score?: SortOrder;
    feedback?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type ScoreSumOrderByAggregateInput = {
    score?: SortOrder;
  };

  export type EnumRewardTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.RewardType | EnumRewardTypeFieldRefInput<$PrismaModel> | null;
    in?: $Enums.RewardType[] | ListEnumRewardTypeFieldRefInput<$PrismaModel> | null;
    notIn?: $Enums.RewardType[] | ListEnumRewardTypeFieldRefInput<$PrismaModel> | null;
    not?: NestedEnumRewardTypeNullableFilter<$PrismaModel> | $Enums.RewardType | null;
  };

  export type EnumChallengeStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ChallengeStatus | EnumChallengeStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.ChallengeStatus[] | ListEnumChallengeStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.ChallengeStatus[] | ListEnumChallengeStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumChallengeStatusFilter<$PrismaModel> | $Enums.ChallengeStatus;
  };

  export type EnumChallengeVisibilityFilter<$PrismaModel = never> = {
    equals?: $Enums.ChallengeVisibility | EnumChallengeVisibilityFieldRefInput<$PrismaModel>;
    in?: $Enums.ChallengeVisibility[] | ListEnumChallengeVisibilityFieldRefInput<$PrismaModel>;
    notIn?: $Enums.ChallengeVisibility[] | ListEnumChallengeVisibilityFieldRefInput<$PrismaModel>;
    not?: NestedEnumChallengeVisibilityFilter<$PrismaModel> | $Enums.ChallengeVisibility;
  };

  export type ChallengeCountOrderByAggregateInput = {
    id?: SortOrder;
    slug?: SortOrder;
    title?: SortOrder;
    problemStatement?: SortOrder;
    ownerId?: SortOrder;
    ownerOrg?: SortOrder;
    rewardType?: SortOrder;
    rewardValue?: SortOrder;
    categories?: SortOrder;
    skills?: SortOrder;
    attachments?: SortOrder;
    status?: SortOrder;
    visibility?: SortOrder;
    deadlineAt?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type ChallengeMaxOrderByAggregateInput = {
    id?: SortOrder;
    slug?: SortOrder;
    title?: SortOrder;
    problemStatement?: SortOrder;
    ownerId?: SortOrder;
    ownerOrg?: SortOrder;
    rewardType?: SortOrder;
    rewardValue?: SortOrder;
    status?: SortOrder;
    visibility?: SortOrder;
    deadlineAt?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type ChallengeMinOrderByAggregateInput = {
    id?: SortOrder;
    slug?: SortOrder;
    title?: SortOrder;
    problemStatement?: SortOrder;
    ownerId?: SortOrder;
    ownerOrg?: SortOrder;
    rewardType?: SortOrder;
    rewardValue?: SortOrder;
    status?: SortOrder;
    visibility?: SortOrder;
    deadlineAt?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type EnumRewardTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RewardType | EnumRewardTypeFieldRefInput<$PrismaModel> | null;
    in?: $Enums.RewardType[] | ListEnumRewardTypeFieldRefInput<$PrismaModel> | null;
    notIn?: $Enums.RewardType[] | ListEnumRewardTypeFieldRefInput<$PrismaModel> | null;
    not?: NestedEnumRewardTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.RewardType | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedEnumRewardTypeNullableFilter<$PrismaModel>;
    _max?: NestedEnumRewardTypeNullableFilter<$PrismaModel>;
  };

  export type EnumChallengeStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChallengeStatus | EnumChallengeStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.ChallengeStatus[] | ListEnumChallengeStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.ChallengeStatus[] | ListEnumChallengeStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumChallengeStatusWithAggregatesFilter<$PrismaModel> | $Enums.ChallengeStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumChallengeStatusFilter<$PrismaModel>;
    _max?: NestedEnumChallengeStatusFilter<$PrismaModel>;
  };

  export type EnumChallengeVisibilityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChallengeVisibility | EnumChallengeVisibilityFieldRefInput<$PrismaModel>;
    in?: $Enums.ChallengeVisibility[] | ListEnumChallengeVisibilityFieldRefInput<$PrismaModel>;
    notIn?: $Enums.ChallengeVisibility[] | ListEnumChallengeVisibilityFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumChallengeVisibilityWithAggregatesFilter<$PrismaModel>
      | $Enums.ChallengeVisibility;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumChallengeVisibilityFilter<$PrismaModel>;
    _max?: NestedEnumChallengeVisibilityFilter<$PrismaModel>;
  };

  export type EnumChallengeSubmissionStatusFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.ChallengeSubmissionStatus
      | EnumChallengeSubmissionStatusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.ChallengeSubmissionStatus[]
      | ListEnumChallengeSubmissionStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.ChallengeSubmissionStatus[]
      | ListEnumChallengeSubmissionStatusFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumChallengeSubmissionStatusFilter<$PrismaModel>
      | $Enums.ChallengeSubmissionStatus;
  };

  export type ChallengeRelationFilter = {
    is?: ChallengeWhereInput;
    isNot?: ChallengeWhereInput;
  };

  export type TeamNullableRelationFilter = {
    is?: TeamWhereInput | null;
    isNot?: TeamWhereInput | null;
  };

  export type ChallengeSubmissionCountOrderByAggregateInput = {
    id?: SortOrder;
    challengeId?: SortOrder;
    userId?: SortOrder;
    teamId?: SortOrder;
    title?: SortOrder;
    repoUrl?: SortOrder;
    content?: SortOrder;
    files?: SortOrder;
    status?: SortOrder;
    score?: SortOrder;
    feedback?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type ChallengeSubmissionAvgOrderByAggregateInput = {
    score?: SortOrder;
  };

  export type ChallengeSubmissionMaxOrderByAggregateInput = {
    id?: SortOrder;
    challengeId?: SortOrder;
    userId?: SortOrder;
    teamId?: SortOrder;
    title?: SortOrder;
    repoUrl?: SortOrder;
    content?: SortOrder;
    status?: SortOrder;
    score?: SortOrder;
    feedback?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type ChallengeSubmissionMinOrderByAggregateInput = {
    id?: SortOrder;
    challengeId?: SortOrder;
    userId?: SortOrder;
    teamId?: SortOrder;
    title?: SortOrder;
    repoUrl?: SortOrder;
    content?: SortOrder;
    status?: SortOrder;
    score?: SortOrder;
    feedback?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type ChallengeSubmissionSumOrderByAggregateInput = {
    score?: SortOrder;
  };

  export type EnumChallengeSubmissionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.ChallengeSubmissionStatus
      | EnumChallengeSubmissionStatusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.ChallengeSubmissionStatus[]
      | ListEnumChallengeSubmissionStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.ChallengeSubmissionStatus[]
      | ListEnumChallengeSubmissionStatusFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumChallengeSubmissionStatusWithAggregatesFilter<$PrismaModel>
      | $Enums.ChallengeSubmissionStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumChallengeSubmissionStatusFilter<$PrismaModel>;
    _max?: NestedEnumChallengeSubmissionStatusFilter<$PrismaModel>;
  };

  export type EnumAnnouncementScopeFilter<$PrismaModel = never> = {
    equals?: $Enums.AnnouncementScope | EnumAnnouncementScopeFieldRefInput<$PrismaModel>;
    in?: $Enums.AnnouncementScope[] | ListEnumAnnouncementScopeFieldRefInput<$PrismaModel>;
    notIn?: $Enums.AnnouncementScope[] | ListEnumAnnouncementScopeFieldRefInput<$PrismaModel>;
    not?: NestedEnumAnnouncementScopeFilter<$PrismaModel> | $Enums.AnnouncementScope;
  };

  export type HackathonNullableRelationFilter = {
    is?: HackathonWhereInput | null;
    isNot?: HackathonWhereInput | null;
  };

  export type AnnouncementCountOrderByAggregateInput = {
    id?: SortOrder;
    scope?: SortOrder;
    scopeId?: SortOrder;
    title?: SortOrder;
    body?: SortOrder;
    pinned?: SortOrder;
    publishedAt?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type AnnouncementMaxOrderByAggregateInput = {
    id?: SortOrder;
    scope?: SortOrder;
    scopeId?: SortOrder;
    title?: SortOrder;
    body?: SortOrder;
    pinned?: SortOrder;
    publishedAt?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type AnnouncementMinOrderByAggregateInput = {
    id?: SortOrder;
    scope?: SortOrder;
    scopeId?: SortOrder;
    title?: SortOrder;
    body?: SortOrder;
    pinned?: SortOrder;
    publishedAt?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type EnumAnnouncementScopeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AnnouncementScope | EnumAnnouncementScopeFieldRefInput<$PrismaModel>;
    in?: $Enums.AnnouncementScope[] | ListEnumAnnouncementScopeFieldRefInput<$PrismaModel>;
    notIn?: $Enums.AnnouncementScope[] | ListEnumAnnouncementScopeFieldRefInput<$PrismaModel>;
    not?: NestedEnumAnnouncementScopeWithAggregatesFilter<$PrismaModel> | $Enums.AnnouncementScope;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumAnnouncementScopeFilter<$PrismaModel>;
    _max?: NestedEnumAnnouncementScopeFilter<$PrismaModel>;
  };

  export type EnumCommentEntityTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CommentEntityType | EnumCommentEntityTypeFieldRefInput<$PrismaModel>;
    in?: $Enums.CommentEntityType[] | ListEnumCommentEntityTypeFieldRefInput<$PrismaModel>;
    notIn?: $Enums.CommentEntityType[] | ListEnumCommentEntityTypeFieldRefInput<$PrismaModel>;
    not?: NestedEnumCommentEntityTypeFilter<$PrismaModel> | $Enums.CommentEntityType;
  };

  export type CommentThreadEntityTypeEntityIdCompoundUniqueInput = {
    entityType: $Enums.CommentEntityType;
    entityId: string;
  };

  export type CommentThreadCountOrderByAggregateInput = {
    id?: SortOrder;
    entityType?: SortOrder;
    entityId?: SortOrder;
    createdAt?: SortOrder;
  };

  export type CommentThreadMaxOrderByAggregateInput = {
    id?: SortOrder;
    entityType?: SortOrder;
    entityId?: SortOrder;
    createdAt?: SortOrder;
  };

  export type CommentThreadMinOrderByAggregateInput = {
    id?: SortOrder;
    entityType?: SortOrder;
    entityId?: SortOrder;
    createdAt?: SortOrder;
  };

  export type EnumCommentEntityTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CommentEntityType | EnumCommentEntityTypeFieldRefInput<$PrismaModel>;
    in?: $Enums.CommentEntityType[] | ListEnumCommentEntityTypeFieldRefInput<$PrismaModel>;
    notIn?: $Enums.CommentEntityType[] | ListEnumCommentEntityTypeFieldRefInput<$PrismaModel>;
    not?: NestedEnumCommentEntityTypeWithAggregatesFilter<$PrismaModel> | $Enums.CommentEntityType;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumCommentEntityTypeFilter<$PrismaModel>;
    _max?: NestedEnumCommentEntityTypeFilter<$PrismaModel>;
  };

  export type CommentThreadRelationFilter = {
    is?: CommentThreadWhereInput;
    isNot?: CommentThreadWhereInput;
  };

  export type CommentNullableRelationFilter = {
    is?: CommentWhereInput | null;
    isNot?: CommentWhereInput | null;
  };

  export type CommentCountOrderByAggregateInput = {
    id?: SortOrder;
    threadId?: SortOrder;
    authorId?: SortOrder;
    parentId?: SortOrder;
    body?: SortOrder;
    isFlagged?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type CommentMaxOrderByAggregateInput = {
    id?: SortOrder;
    threadId?: SortOrder;
    authorId?: SortOrder;
    parentId?: SortOrder;
    body?: SortOrder;
    isFlagged?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type CommentMinOrderByAggregateInput = {
    id?: SortOrder;
    threadId?: SortOrder;
    authorId?: SortOrder;
    parentId?: SortOrder;
    body?: SortOrder;
    isFlagged?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type GamificationProfileCountOrderByAggregateInput = {
    userId?: SortOrder;
    xp?: SortOrder;
    level?: SortOrder;
    streakDays?: SortOrder;
    vaultKeys?: SortOrder;
    badges?: SortOrder;
    lastActivityAt?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type GamificationProfileAvgOrderByAggregateInput = {
    xp?: SortOrder;
    level?: SortOrder;
    streakDays?: SortOrder;
    vaultKeys?: SortOrder;
  };

  export type GamificationProfileMaxOrderByAggregateInput = {
    userId?: SortOrder;
    xp?: SortOrder;
    level?: SortOrder;
    streakDays?: SortOrder;
    vaultKeys?: SortOrder;
    lastActivityAt?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type GamificationProfileMinOrderByAggregateInput = {
    userId?: SortOrder;
    xp?: SortOrder;
    level?: SortOrder;
    streakDays?: SortOrder;
    vaultKeys?: SortOrder;
    lastActivityAt?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type GamificationProfileSumOrderByAggregateInput = {
    xp?: SortOrder;
    level?: SortOrder;
    streakDays?: SortOrder;
    vaultKeys?: SortOrder;
  };

  export type BadgeCountOrderByAggregateInput = {
    id?: SortOrder;
    slug?: SortOrder;
    name?: SortOrder;
    description?: SortOrder;
    icon?: SortOrder;
    xpRequired?: SortOrder;
    rarity?: SortOrder;
    createdAt?: SortOrder;
  };

  export type BadgeAvgOrderByAggregateInput = {
    xpRequired?: SortOrder;
  };

  export type BadgeMaxOrderByAggregateInput = {
    id?: SortOrder;
    slug?: SortOrder;
    name?: SortOrder;
    description?: SortOrder;
    icon?: SortOrder;
    xpRequired?: SortOrder;
    rarity?: SortOrder;
    createdAt?: SortOrder;
  };

  export type BadgeMinOrderByAggregateInput = {
    id?: SortOrder;
    slug?: SortOrder;
    name?: SortOrder;
    description?: SortOrder;
    icon?: SortOrder;
    xpRequired?: SortOrder;
    rarity?: SortOrder;
    createdAt?: SortOrder;
  };

  export type BadgeSumOrderByAggregateInput = {
    xpRequired?: SortOrder;
  };

  export type XpEventCountOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    eventType?: SortOrder;
    points?: SortOrder;
    refType?: SortOrder;
    refId?: SortOrder;
    metadata?: SortOrder;
    createdAt?: SortOrder;
  };

  export type XpEventAvgOrderByAggregateInput = {
    points?: SortOrder;
  };

  export type XpEventMaxOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    eventType?: SortOrder;
    points?: SortOrder;
    refType?: SortOrder;
    refId?: SortOrder;
    createdAt?: SortOrder;
  };

  export type XpEventMinOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    eventType?: SortOrder;
    points?: SortOrder;
    refType?: SortOrder;
    refId?: SortOrder;
    createdAt?: SortOrder;
  };

  export type XpEventSumOrderByAggregateInput = {
    points?: SortOrder;
  };

  export type EnumLeaderboardScopeFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaderboardScope | EnumLeaderboardScopeFieldRefInput<$PrismaModel>;
    in?: $Enums.LeaderboardScope[] | ListEnumLeaderboardScopeFieldRefInput<$PrismaModel>;
    notIn?: $Enums.LeaderboardScope[] | ListEnumLeaderboardScopeFieldRefInput<$PrismaModel>;
    not?: NestedEnumLeaderboardScopeFilter<$PrismaModel> | $Enums.LeaderboardScope;
  };

  export type EnumLeaderboardPeriodFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaderboardPeriod | EnumLeaderboardPeriodFieldRefInput<$PrismaModel>;
    in?: $Enums.LeaderboardPeriod[] | ListEnumLeaderboardPeriodFieldRefInput<$PrismaModel>;
    notIn?: $Enums.LeaderboardPeriod[] | ListEnumLeaderboardPeriodFieldRefInput<$PrismaModel>;
    not?: NestedEnumLeaderboardPeriodFilter<$PrismaModel> | $Enums.LeaderboardPeriod;
  };
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<JsonFilterBase<$PrismaModel>>,
          Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>
        >,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>;

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter;
    path?: string[];
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter;
  };

  export type LeaderboardSnapshotCountOrderByAggregateInput = {
    id?: SortOrder;
    scope?: SortOrder;
    scopeId?: SortOrder;
    period?: SortOrder;
    data?: SortOrder;
    createdAt?: SortOrder;
  };

  export type LeaderboardSnapshotMaxOrderByAggregateInput = {
    id?: SortOrder;
    scope?: SortOrder;
    scopeId?: SortOrder;
    period?: SortOrder;
    createdAt?: SortOrder;
  };

  export type LeaderboardSnapshotMinOrderByAggregateInput = {
    id?: SortOrder;
    scope?: SortOrder;
    scopeId?: SortOrder;
    period?: SortOrder;
    createdAt?: SortOrder;
  };

  export type EnumLeaderboardScopeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaderboardScope | EnumLeaderboardScopeFieldRefInput<$PrismaModel>;
    in?: $Enums.LeaderboardScope[] | ListEnumLeaderboardScopeFieldRefInput<$PrismaModel>;
    notIn?: $Enums.LeaderboardScope[] | ListEnumLeaderboardScopeFieldRefInput<$PrismaModel>;
    not?: NestedEnumLeaderboardScopeWithAggregatesFilter<$PrismaModel> | $Enums.LeaderboardScope;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumLeaderboardScopeFilter<$PrismaModel>;
    _max?: NestedEnumLeaderboardScopeFilter<$PrismaModel>;
  };

  export type EnumLeaderboardPeriodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaderboardPeriod | EnumLeaderboardPeriodFieldRefInput<$PrismaModel>;
    in?: $Enums.LeaderboardPeriod[] | ListEnumLeaderboardPeriodFieldRefInput<$PrismaModel>;
    notIn?: $Enums.LeaderboardPeriod[] | ListEnumLeaderboardPeriodFieldRefInput<$PrismaModel>;
    not?: NestedEnumLeaderboardPeriodWithAggregatesFilter<$PrismaModel> | $Enums.LeaderboardPeriod;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumLeaderboardPeriodFilter<$PrismaModel>;
    _max?: NestedEnumLeaderboardPeriodFilter<$PrismaModel>;
  };
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<JsonWithAggregatesFilterBase<$PrismaModel>>,
          Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>
        >,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>;

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter;
    path?: string[];
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedJsonFilter<$PrismaModel>;
    _max?: NestedJsonFilter<$PrismaModel>;
  };

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    type?: SortOrder;
    data?: SortOrder;
    readAt?: SortOrder;
    createdAt?: SortOrder;
  };

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    type?: SortOrder;
    readAt?: SortOrder;
    createdAt?: SortOrder;
  };

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    type?: SortOrder;
    readAt?: SortOrder;
    createdAt?: SortOrder;
  };

  export type EnumReportStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportStatus | EnumReportStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumReportStatusFilter<$PrismaModel> | $Enums.ReportStatus;
  };

  export type ReportCountOrderByAggregateInput = {
    id?: SortOrder;
    reporterId?: SortOrder;
    entityType?: SortOrder;
    entityId?: SortOrder;
    reason?: SortOrder;
    status?: SortOrder;
    resolution?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type ReportMaxOrderByAggregateInput = {
    id?: SortOrder;
    reporterId?: SortOrder;
    entityType?: SortOrder;
    entityId?: SortOrder;
    reason?: SortOrder;
    status?: SortOrder;
    resolution?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type ReportMinOrderByAggregateInput = {
    id?: SortOrder;
    reporterId?: SortOrder;
    entityType?: SortOrder;
    entityId?: SortOrder;
    reason?: SortOrder;
    status?: SortOrder;
    resolution?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type EnumReportStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportStatus | EnumReportStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumReportStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReportStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumReportStatusFilter<$PrismaModel>;
    _max?: NestedEnumReportStatusFilter<$PrismaModel>;
  };

  export type FileCountOrderByAggregateInput = {
    id?: SortOrder;
    filename?: SortOrder;
    mimetype?: SortOrder;
    size?: SortOrder;
    key?: SortOrder;
    url?: SortOrder;
    type?: SortOrder;
    uploadedById?: SortOrder;
    entityId?: SortOrder;
    entityType?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    deletedAt?: SortOrder;
  };

  export type FileAvgOrderByAggregateInput = {
    size?: SortOrder;
  };

  export type FileMaxOrderByAggregateInput = {
    id?: SortOrder;
    filename?: SortOrder;
    mimetype?: SortOrder;
    size?: SortOrder;
    key?: SortOrder;
    url?: SortOrder;
    type?: SortOrder;
    uploadedById?: SortOrder;
    entityId?: SortOrder;
    entityType?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    deletedAt?: SortOrder;
  };

  export type FileMinOrderByAggregateInput = {
    id?: SortOrder;
    filename?: SortOrder;
    mimetype?: SortOrder;
    size?: SortOrder;
    key?: SortOrder;
    url?: SortOrder;
    type?: SortOrder;
    uploadedById?: SortOrder;
    entityId?: SortOrder;
    entityType?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    deletedAt?: SortOrder;
  };

  export type FileSumOrderByAggregateInput = {
    size?: SortOrder;
  };

  export type UserCreaterolesInput = {
    set: $Enums.Role[];
  };

  export type AccountCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
      | AccountCreateWithoutUserInput[]
      | AccountUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | AccountCreateOrConnectWithoutUserInput
      | AccountCreateOrConnectWithoutUserInput[];
    createMany?: AccountCreateManyUserInputEnvelope;
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[];
  };

  export type SessionCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
      | SessionCreateWithoutUserInput[]
      | SessionUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | SessionCreateOrConnectWithoutUserInput
      | SessionCreateOrConnectWithoutUserInput[];
    createMany?: SessionCreateManyUserInputEnvelope;
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
  };

  export type ApiKeyCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<ApiKeyCreateWithoutUserInput, ApiKeyUncheckedCreateWithoutUserInput>
      | ApiKeyCreateWithoutUserInput[]
      | ApiKeyUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | ApiKeyCreateOrConnectWithoutUserInput
      | ApiKeyCreateOrConnectWithoutUserInput[];
    createMany?: ApiKeyCreateManyUserInputEnvelope;
    connect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[];
  };

  export type AuditLogCreateNestedManyWithoutActorInput = {
    create?:
      | XOR<AuditLogCreateWithoutActorInput, AuditLogUncheckedCreateWithoutActorInput>
      | AuditLogCreateWithoutActorInput[]
      | AuditLogUncheckedCreateWithoutActorInput[];
    connectOrCreate?:
      | AuditLogCreateOrConnectWithoutActorInput
      | AuditLogCreateOrConnectWithoutActorInput[];
    createMany?: AuditLogCreateManyActorInputEnvelope;
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
  };

  export type TeamMemberCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput>
      | TeamMemberCreateWithoutUserInput[]
      | TeamMemberUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | TeamMemberCreateOrConnectWithoutUserInput
      | TeamMemberCreateOrConnectWithoutUserInput[];
    createMany?: TeamMemberCreateManyUserInputEnvelope;
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[];
  };

  export type MentorCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<MentorCreateWithoutUserInput, MentorUncheckedCreateWithoutUserInput>
      | MentorCreateWithoutUserInput[]
      | MentorUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | MentorCreateOrConnectWithoutUserInput
      | MentorCreateOrConnectWithoutUserInput[];
    createMany?: MentorCreateManyUserInputEnvelope;
    connect?: MentorWhereUniqueInput | MentorWhereUniqueInput[];
  };

  export type JudgeCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<JudgeCreateWithoutUserInput, JudgeUncheckedCreateWithoutUserInput>
      | JudgeCreateWithoutUserInput[]
      | JudgeUncheckedCreateWithoutUserInput[];
    connectOrCreate?: JudgeCreateOrConnectWithoutUserInput | JudgeCreateOrConnectWithoutUserInput[];
    createMany?: JudgeCreateManyUserInputEnvelope;
    connect?: JudgeWhereUniqueInput | JudgeWhereUniqueInput[];
  };

  export type ChallengeSubmissionCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          ChallengeSubmissionCreateWithoutUserInput,
          ChallengeSubmissionUncheckedCreateWithoutUserInput
        >
      | ChallengeSubmissionCreateWithoutUserInput[]
      | ChallengeSubmissionUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | ChallengeSubmissionCreateOrConnectWithoutUserInput
      | ChallengeSubmissionCreateOrConnectWithoutUserInput[];
    createMany?: ChallengeSubmissionCreateManyUserInputEnvelope;
    connect?: ChallengeSubmissionWhereUniqueInput | ChallengeSubmissionWhereUniqueInput[];
  };

  export type CommentCreateNestedManyWithoutAuthorInput = {
    create?:
      | XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput>
      | CommentCreateWithoutAuthorInput[]
      | CommentUncheckedCreateWithoutAuthorInput[];
    connectOrCreate?:
      | CommentCreateOrConnectWithoutAuthorInput
      | CommentCreateOrConnectWithoutAuthorInput[];
    createMany?: CommentCreateManyAuthorInputEnvelope;
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
  };

  export type GamificationProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<
      GamificationProfileCreateWithoutUserInput,
      GamificationProfileUncheckedCreateWithoutUserInput
    >;
    connectOrCreate?: GamificationProfileCreateOrConnectWithoutUserInput;
    connect?: GamificationProfileWhereUniqueInput;
  };

  export type XpEventCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<XpEventCreateWithoutUserInput, XpEventUncheckedCreateWithoutUserInput>
      | XpEventCreateWithoutUserInput[]
      | XpEventUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | XpEventCreateOrConnectWithoutUserInput
      | XpEventCreateOrConnectWithoutUserInput[];
    createMany?: XpEventCreateManyUserInputEnvelope;
    connect?: XpEventWhereUniqueInput | XpEventWhereUniqueInput[];
  };

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
      | NotificationCreateWithoutUserInput[]
      | NotificationUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | NotificationCreateOrConnectWithoutUserInput
      | NotificationCreateOrConnectWithoutUserInput[];
    createMany?: NotificationCreateManyUserInputEnvelope;
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
  };

  export type ReportCreateNestedManyWithoutReporterInput = {
    create?:
      | XOR<ReportCreateWithoutReporterInput, ReportUncheckedCreateWithoutReporterInput>
      | ReportCreateWithoutReporterInput[]
      | ReportUncheckedCreateWithoutReporterInput[];
    connectOrCreate?:
      | ReportCreateOrConnectWithoutReporterInput
      | ReportCreateOrConnectWithoutReporterInput[];
    createMany?: ReportCreateManyReporterInputEnvelope;
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[];
  };

  export type FileCreateNestedManyWithoutUploadedByInput = {
    create?:
      | XOR<FileCreateWithoutUploadedByInput, FileUncheckedCreateWithoutUploadedByInput>
      | FileCreateWithoutUploadedByInput[]
      | FileUncheckedCreateWithoutUploadedByInput[];
    connectOrCreate?:
      | FileCreateOrConnectWithoutUploadedByInput
      | FileCreateOrConnectWithoutUploadedByInput[];
    createMany?: FileCreateManyUploadedByInputEnvelope;
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[];
  };

  export type ChallengeCreateNestedManyWithoutOwnerInput = {
    create?:
      | XOR<ChallengeCreateWithoutOwnerInput, ChallengeUncheckedCreateWithoutOwnerInput>
      | ChallengeCreateWithoutOwnerInput[]
      | ChallengeUncheckedCreateWithoutOwnerInput[];
    connectOrCreate?:
      | ChallengeCreateOrConnectWithoutOwnerInput
      | ChallengeCreateOrConnectWithoutOwnerInput[];
    createMany?: ChallengeCreateManyOwnerInputEnvelope;
    connect?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[];
  };

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
      | AccountCreateWithoutUserInput[]
      | AccountUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | AccountCreateOrConnectWithoutUserInput
      | AccountCreateOrConnectWithoutUserInput[];
    createMany?: AccountCreateManyUserInputEnvelope;
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[];
  };

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
      | SessionCreateWithoutUserInput[]
      | SessionUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | SessionCreateOrConnectWithoutUserInput
      | SessionCreateOrConnectWithoutUserInput[];
    createMany?: SessionCreateManyUserInputEnvelope;
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
  };

  export type ApiKeyUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<ApiKeyCreateWithoutUserInput, ApiKeyUncheckedCreateWithoutUserInput>
      | ApiKeyCreateWithoutUserInput[]
      | ApiKeyUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | ApiKeyCreateOrConnectWithoutUserInput
      | ApiKeyCreateOrConnectWithoutUserInput[];
    createMany?: ApiKeyCreateManyUserInputEnvelope;
    connect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[];
  };

  export type AuditLogUncheckedCreateNestedManyWithoutActorInput = {
    create?:
      | XOR<AuditLogCreateWithoutActorInput, AuditLogUncheckedCreateWithoutActorInput>
      | AuditLogCreateWithoutActorInput[]
      | AuditLogUncheckedCreateWithoutActorInput[];
    connectOrCreate?:
      | AuditLogCreateOrConnectWithoutActorInput
      | AuditLogCreateOrConnectWithoutActorInput[];
    createMany?: AuditLogCreateManyActorInputEnvelope;
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
  };

  export type TeamMemberUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput>
      | TeamMemberCreateWithoutUserInput[]
      | TeamMemberUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | TeamMemberCreateOrConnectWithoutUserInput
      | TeamMemberCreateOrConnectWithoutUserInput[];
    createMany?: TeamMemberCreateManyUserInputEnvelope;
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[];
  };

  export type MentorUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<MentorCreateWithoutUserInput, MentorUncheckedCreateWithoutUserInput>
      | MentorCreateWithoutUserInput[]
      | MentorUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | MentorCreateOrConnectWithoutUserInput
      | MentorCreateOrConnectWithoutUserInput[];
    createMany?: MentorCreateManyUserInputEnvelope;
    connect?: MentorWhereUniqueInput | MentorWhereUniqueInput[];
  };

  export type JudgeUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<JudgeCreateWithoutUserInput, JudgeUncheckedCreateWithoutUserInput>
      | JudgeCreateWithoutUserInput[]
      | JudgeUncheckedCreateWithoutUserInput[];
    connectOrCreate?: JudgeCreateOrConnectWithoutUserInput | JudgeCreateOrConnectWithoutUserInput[];
    createMany?: JudgeCreateManyUserInputEnvelope;
    connect?: JudgeWhereUniqueInput | JudgeWhereUniqueInput[];
  };

  export type ChallengeSubmissionUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          ChallengeSubmissionCreateWithoutUserInput,
          ChallengeSubmissionUncheckedCreateWithoutUserInput
        >
      | ChallengeSubmissionCreateWithoutUserInput[]
      | ChallengeSubmissionUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | ChallengeSubmissionCreateOrConnectWithoutUserInput
      | ChallengeSubmissionCreateOrConnectWithoutUserInput[];
    createMany?: ChallengeSubmissionCreateManyUserInputEnvelope;
    connect?: ChallengeSubmissionWhereUniqueInput | ChallengeSubmissionWhereUniqueInput[];
  };

  export type CommentUncheckedCreateNestedManyWithoutAuthorInput = {
    create?:
      | XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput>
      | CommentCreateWithoutAuthorInput[]
      | CommentUncheckedCreateWithoutAuthorInput[];
    connectOrCreate?:
      | CommentCreateOrConnectWithoutAuthorInput
      | CommentCreateOrConnectWithoutAuthorInput[];
    createMany?: CommentCreateManyAuthorInputEnvelope;
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
  };

  export type GamificationProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<
      GamificationProfileCreateWithoutUserInput,
      GamificationProfileUncheckedCreateWithoutUserInput
    >;
    connectOrCreate?: GamificationProfileCreateOrConnectWithoutUserInput;
    connect?: GamificationProfileWhereUniqueInput;
  };

  export type XpEventUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<XpEventCreateWithoutUserInput, XpEventUncheckedCreateWithoutUserInput>
      | XpEventCreateWithoutUserInput[]
      | XpEventUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | XpEventCreateOrConnectWithoutUserInput
      | XpEventCreateOrConnectWithoutUserInput[];
    createMany?: XpEventCreateManyUserInputEnvelope;
    connect?: XpEventWhereUniqueInput | XpEventWhereUniqueInput[];
  };

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
      | NotificationCreateWithoutUserInput[]
      | NotificationUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | NotificationCreateOrConnectWithoutUserInput
      | NotificationCreateOrConnectWithoutUserInput[];
    createMany?: NotificationCreateManyUserInputEnvelope;
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
  };

  export type ReportUncheckedCreateNestedManyWithoutReporterInput = {
    create?:
      | XOR<ReportCreateWithoutReporterInput, ReportUncheckedCreateWithoutReporterInput>
      | ReportCreateWithoutReporterInput[]
      | ReportUncheckedCreateWithoutReporterInput[];
    connectOrCreate?:
      | ReportCreateOrConnectWithoutReporterInput
      | ReportCreateOrConnectWithoutReporterInput[];
    createMany?: ReportCreateManyReporterInputEnvelope;
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[];
  };

  export type FileUncheckedCreateNestedManyWithoutUploadedByInput = {
    create?:
      | XOR<FileCreateWithoutUploadedByInput, FileUncheckedCreateWithoutUploadedByInput>
      | FileCreateWithoutUploadedByInput[]
      | FileUncheckedCreateWithoutUploadedByInput[];
    connectOrCreate?:
      | FileCreateOrConnectWithoutUploadedByInput
      | FileCreateOrConnectWithoutUploadedByInput[];
    createMany?: FileCreateManyUploadedByInputEnvelope;
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[];
  };

  export type ChallengeUncheckedCreateNestedManyWithoutOwnerInput = {
    create?:
      | XOR<ChallengeCreateWithoutOwnerInput, ChallengeUncheckedCreateWithoutOwnerInput>
      | ChallengeCreateWithoutOwnerInput[]
      | ChallengeUncheckedCreateWithoutOwnerInput[];
    connectOrCreate?:
      | ChallengeCreateOrConnectWithoutOwnerInput
      | ChallengeCreateOrConnectWithoutOwnerInput[];
    createMany?: ChallengeCreateManyOwnerInputEnvelope;
    connect?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[];
  };

  export type StringFieldUpdateOperationsInput = {
    set?: string;
  };

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null;
  };

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null;
  };

  export type UserUpdaterolesInput = {
    set?: $Enums.Role[];
    push?: $Enums.Role | $Enums.Role[];
  };

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean;
  };

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string;
  };

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
      | AccountCreateWithoutUserInput[]
      | AccountUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | AccountCreateOrConnectWithoutUserInput
      | AccountCreateOrConnectWithoutUserInput[];
    upsert?:
      | AccountUpsertWithWhereUniqueWithoutUserInput
      | AccountUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: AccountCreateManyUserInputEnvelope;
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[];
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[];
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[];
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[];
    update?:
      | AccountUpdateWithWhereUniqueWithoutUserInput
      | AccountUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | AccountUpdateManyWithWhereWithoutUserInput
      | AccountUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[];
  };

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
      | SessionCreateWithoutUserInput[]
      | SessionUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | SessionCreateOrConnectWithoutUserInput
      | SessionCreateOrConnectWithoutUserInput[];
    upsert?:
      | SessionUpsertWithWhereUniqueWithoutUserInput
      | SessionUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: SessionCreateManyUserInputEnvelope;
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
    update?:
      | SessionUpdateWithWhereUniqueWithoutUserInput
      | SessionUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | SessionUpdateManyWithWhereWithoutUserInput
      | SessionUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[];
  };

  export type ApiKeyUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<ApiKeyCreateWithoutUserInput, ApiKeyUncheckedCreateWithoutUserInput>
      | ApiKeyCreateWithoutUserInput[]
      | ApiKeyUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | ApiKeyCreateOrConnectWithoutUserInput
      | ApiKeyCreateOrConnectWithoutUserInput[];
    upsert?:
      | ApiKeyUpsertWithWhereUniqueWithoutUserInput
      | ApiKeyUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: ApiKeyCreateManyUserInputEnvelope;
    set?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[];
    disconnect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[];
    delete?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[];
    connect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[];
    update?:
      | ApiKeyUpdateWithWhereUniqueWithoutUserInput
      | ApiKeyUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | ApiKeyUpdateManyWithWhereWithoutUserInput
      | ApiKeyUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: ApiKeyScalarWhereInput | ApiKeyScalarWhereInput[];
  };

  export type AuditLogUpdateManyWithoutActorNestedInput = {
    create?:
      | XOR<AuditLogCreateWithoutActorInput, AuditLogUncheckedCreateWithoutActorInput>
      | AuditLogCreateWithoutActorInput[]
      | AuditLogUncheckedCreateWithoutActorInput[];
    connectOrCreate?:
      | AuditLogCreateOrConnectWithoutActorInput
      | AuditLogCreateOrConnectWithoutActorInput[];
    upsert?:
      | AuditLogUpsertWithWhereUniqueWithoutActorInput
      | AuditLogUpsertWithWhereUniqueWithoutActorInput[];
    createMany?: AuditLogCreateManyActorInputEnvelope;
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
    update?:
      | AuditLogUpdateWithWhereUniqueWithoutActorInput
      | AuditLogUpdateWithWhereUniqueWithoutActorInput[];
    updateMany?:
      | AuditLogUpdateManyWithWhereWithoutActorInput
      | AuditLogUpdateManyWithWhereWithoutActorInput[];
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[];
  };

  export type TeamMemberUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput>
      | TeamMemberCreateWithoutUserInput[]
      | TeamMemberUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | TeamMemberCreateOrConnectWithoutUserInput
      | TeamMemberCreateOrConnectWithoutUserInput[];
    upsert?:
      | TeamMemberUpsertWithWhereUniqueWithoutUserInput
      | TeamMemberUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: TeamMemberCreateManyUserInputEnvelope;
    set?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[];
    disconnect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[];
    delete?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[];
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[];
    update?:
      | TeamMemberUpdateWithWhereUniqueWithoutUserInput
      | TeamMemberUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | TeamMemberUpdateManyWithWhereWithoutUserInput
      | TeamMemberUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[];
  };

  export type MentorUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<MentorCreateWithoutUserInput, MentorUncheckedCreateWithoutUserInput>
      | MentorCreateWithoutUserInput[]
      | MentorUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | MentorCreateOrConnectWithoutUserInput
      | MentorCreateOrConnectWithoutUserInput[];
    upsert?:
      | MentorUpsertWithWhereUniqueWithoutUserInput
      | MentorUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: MentorCreateManyUserInputEnvelope;
    set?: MentorWhereUniqueInput | MentorWhereUniqueInput[];
    disconnect?: MentorWhereUniqueInput | MentorWhereUniqueInput[];
    delete?: MentorWhereUniqueInput | MentorWhereUniqueInput[];
    connect?: MentorWhereUniqueInput | MentorWhereUniqueInput[];
    update?:
      | MentorUpdateWithWhereUniqueWithoutUserInput
      | MentorUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | MentorUpdateManyWithWhereWithoutUserInput
      | MentorUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: MentorScalarWhereInput | MentorScalarWhereInput[];
  };

  export type JudgeUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<JudgeCreateWithoutUserInput, JudgeUncheckedCreateWithoutUserInput>
      | JudgeCreateWithoutUserInput[]
      | JudgeUncheckedCreateWithoutUserInput[];
    connectOrCreate?: JudgeCreateOrConnectWithoutUserInput | JudgeCreateOrConnectWithoutUserInput[];
    upsert?:
      | JudgeUpsertWithWhereUniqueWithoutUserInput
      | JudgeUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: JudgeCreateManyUserInputEnvelope;
    set?: JudgeWhereUniqueInput | JudgeWhereUniqueInput[];
    disconnect?: JudgeWhereUniqueInput | JudgeWhereUniqueInput[];
    delete?: JudgeWhereUniqueInput | JudgeWhereUniqueInput[];
    connect?: JudgeWhereUniqueInput | JudgeWhereUniqueInput[];
    update?:
      | JudgeUpdateWithWhereUniqueWithoutUserInput
      | JudgeUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | JudgeUpdateManyWithWhereWithoutUserInput
      | JudgeUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: JudgeScalarWhereInput | JudgeScalarWhereInput[];
  };

  export type ChallengeSubmissionUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          ChallengeSubmissionCreateWithoutUserInput,
          ChallengeSubmissionUncheckedCreateWithoutUserInput
        >
      | ChallengeSubmissionCreateWithoutUserInput[]
      | ChallengeSubmissionUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | ChallengeSubmissionCreateOrConnectWithoutUserInput
      | ChallengeSubmissionCreateOrConnectWithoutUserInput[];
    upsert?:
      | ChallengeSubmissionUpsertWithWhereUniqueWithoutUserInput
      | ChallengeSubmissionUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: ChallengeSubmissionCreateManyUserInputEnvelope;
    set?: ChallengeSubmissionWhereUniqueInput | ChallengeSubmissionWhereUniqueInput[];
    disconnect?: ChallengeSubmissionWhereUniqueInput | ChallengeSubmissionWhereUniqueInput[];
    delete?: ChallengeSubmissionWhereUniqueInput | ChallengeSubmissionWhereUniqueInput[];
    connect?: ChallengeSubmissionWhereUniqueInput | ChallengeSubmissionWhereUniqueInput[];
    update?:
      | ChallengeSubmissionUpdateWithWhereUniqueWithoutUserInput
      | ChallengeSubmissionUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | ChallengeSubmissionUpdateManyWithWhereWithoutUserInput
      | ChallengeSubmissionUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: ChallengeSubmissionScalarWhereInput | ChallengeSubmissionScalarWhereInput[];
  };

  export type CommentUpdateManyWithoutAuthorNestedInput = {
    create?:
      | XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput>
      | CommentCreateWithoutAuthorInput[]
      | CommentUncheckedCreateWithoutAuthorInput[];
    connectOrCreate?:
      | CommentCreateOrConnectWithoutAuthorInput
      | CommentCreateOrConnectWithoutAuthorInput[];
    upsert?:
      | CommentUpsertWithWhereUniqueWithoutAuthorInput
      | CommentUpsertWithWhereUniqueWithoutAuthorInput[];
    createMany?: CommentCreateManyAuthorInputEnvelope;
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
    update?:
      | CommentUpdateWithWhereUniqueWithoutAuthorInput
      | CommentUpdateWithWhereUniqueWithoutAuthorInput[];
    updateMany?:
      | CommentUpdateManyWithWhereWithoutAuthorInput
      | CommentUpdateManyWithWhereWithoutAuthorInput[];
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[];
  };

  export type GamificationProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<
      GamificationProfileCreateWithoutUserInput,
      GamificationProfileUncheckedCreateWithoutUserInput
    >;
    connectOrCreate?: GamificationProfileCreateOrConnectWithoutUserInput;
    upsert?: GamificationProfileUpsertWithoutUserInput;
    disconnect?: GamificationProfileWhereInput | boolean;
    delete?: GamificationProfileWhereInput | boolean;
    connect?: GamificationProfileWhereUniqueInput;
    update?: XOR<
      XOR<
        GamificationProfileUpdateToOneWithWhereWithoutUserInput,
        GamificationProfileUpdateWithoutUserInput
      >,
      GamificationProfileUncheckedUpdateWithoutUserInput
    >;
  };

  export type XpEventUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<XpEventCreateWithoutUserInput, XpEventUncheckedCreateWithoutUserInput>
      | XpEventCreateWithoutUserInput[]
      | XpEventUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | XpEventCreateOrConnectWithoutUserInput
      | XpEventCreateOrConnectWithoutUserInput[];
    upsert?:
      | XpEventUpsertWithWhereUniqueWithoutUserInput
      | XpEventUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: XpEventCreateManyUserInputEnvelope;
    set?: XpEventWhereUniqueInput | XpEventWhereUniqueInput[];
    disconnect?: XpEventWhereUniqueInput | XpEventWhereUniqueInput[];
    delete?: XpEventWhereUniqueInput | XpEventWhereUniqueInput[];
    connect?: XpEventWhereUniqueInput | XpEventWhereUniqueInput[];
    update?:
      | XpEventUpdateWithWhereUniqueWithoutUserInput
      | XpEventUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | XpEventUpdateManyWithWhereWithoutUserInput
      | XpEventUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: XpEventScalarWhereInput | XpEventScalarWhereInput[];
  };

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
      | NotificationCreateWithoutUserInput[]
      | NotificationUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | NotificationCreateOrConnectWithoutUserInput
      | NotificationCreateOrConnectWithoutUserInput[];
    upsert?:
      | NotificationUpsertWithWhereUniqueWithoutUserInput
      | NotificationUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: NotificationCreateManyUserInputEnvelope;
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
    update?:
      | NotificationUpdateWithWhereUniqueWithoutUserInput
      | NotificationUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | NotificationUpdateManyWithWhereWithoutUserInput
      | NotificationUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[];
  };

  export type ReportUpdateManyWithoutReporterNestedInput = {
    create?:
      | XOR<ReportCreateWithoutReporterInput, ReportUncheckedCreateWithoutReporterInput>
      | ReportCreateWithoutReporterInput[]
      | ReportUncheckedCreateWithoutReporterInput[];
    connectOrCreate?:
      | ReportCreateOrConnectWithoutReporterInput
      | ReportCreateOrConnectWithoutReporterInput[];
    upsert?:
      | ReportUpsertWithWhereUniqueWithoutReporterInput
      | ReportUpsertWithWhereUniqueWithoutReporterInput[];
    createMany?: ReportCreateManyReporterInputEnvelope;
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[];
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[];
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[];
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[];
    update?:
      | ReportUpdateWithWhereUniqueWithoutReporterInput
      | ReportUpdateWithWhereUniqueWithoutReporterInput[];
    updateMany?:
      | ReportUpdateManyWithWhereWithoutReporterInput
      | ReportUpdateManyWithWhereWithoutReporterInput[];
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[];
  };

  export type FileUpdateManyWithoutUploadedByNestedInput = {
    create?:
      | XOR<FileCreateWithoutUploadedByInput, FileUncheckedCreateWithoutUploadedByInput>
      | FileCreateWithoutUploadedByInput[]
      | FileUncheckedCreateWithoutUploadedByInput[];
    connectOrCreate?:
      | FileCreateOrConnectWithoutUploadedByInput
      | FileCreateOrConnectWithoutUploadedByInput[];
    upsert?:
      | FileUpsertWithWhereUniqueWithoutUploadedByInput
      | FileUpsertWithWhereUniqueWithoutUploadedByInput[];
    createMany?: FileCreateManyUploadedByInputEnvelope;
    set?: FileWhereUniqueInput | FileWhereUniqueInput[];
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[];
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[];
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[];
    update?:
      | FileUpdateWithWhereUniqueWithoutUploadedByInput
      | FileUpdateWithWhereUniqueWithoutUploadedByInput[];
    updateMany?:
      | FileUpdateManyWithWhereWithoutUploadedByInput
      | FileUpdateManyWithWhereWithoutUploadedByInput[];
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[];
  };

  export type ChallengeUpdateManyWithoutOwnerNestedInput = {
    create?:
      | XOR<ChallengeCreateWithoutOwnerInput, ChallengeUncheckedCreateWithoutOwnerInput>
      | ChallengeCreateWithoutOwnerInput[]
      | ChallengeUncheckedCreateWithoutOwnerInput[];
    connectOrCreate?:
      | ChallengeCreateOrConnectWithoutOwnerInput
      | ChallengeCreateOrConnectWithoutOwnerInput[];
    upsert?:
      | ChallengeUpsertWithWhereUniqueWithoutOwnerInput
      | ChallengeUpsertWithWhereUniqueWithoutOwnerInput[];
    createMany?: ChallengeCreateManyOwnerInputEnvelope;
    set?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[];
    disconnect?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[];
    delete?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[];
    connect?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[];
    update?:
      | ChallengeUpdateWithWhereUniqueWithoutOwnerInput
      | ChallengeUpdateWithWhereUniqueWithoutOwnerInput[];
    updateMany?:
      | ChallengeUpdateManyWithWhereWithoutOwnerInput
      | ChallengeUpdateManyWithWhereWithoutOwnerInput[];
    deleteMany?: ChallengeScalarWhereInput | ChallengeScalarWhereInput[];
  };

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
      | AccountCreateWithoutUserInput[]
      | AccountUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | AccountCreateOrConnectWithoutUserInput
      | AccountCreateOrConnectWithoutUserInput[];
    upsert?:
      | AccountUpsertWithWhereUniqueWithoutUserInput
      | AccountUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: AccountCreateManyUserInputEnvelope;
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[];
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[];
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[];
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[];
    update?:
      | AccountUpdateWithWhereUniqueWithoutUserInput
      | AccountUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | AccountUpdateManyWithWhereWithoutUserInput
      | AccountUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[];
  };

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
      | SessionCreateWithoutUserInput[]
      | SessionUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | SessionCreateOrConnectWithoutUserInput
      | SessionCreateOrConnectWithoutUserInput[];
    upsert?:
      | SessionUpsertWithWhereUniqueWithoutUserInput
      | SessionUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: SessionCreateManyUserInputEnvelope;
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[];
    update?:
      | SessionUpdateWithWhereUniqueWithoutUserInput
      | SessionUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | SessionUpdateManyWithWhereWithoutUserInput
      | SessionUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[];
  };

  export type ApiKeyUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<ApiKeyCreateWithoutUserInput, ApiKeyUncheckedCreateWithoutUserInput>
      | ApiKeyCreateWithoutUserInput[]
      | ApiKeyUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | ApiKeyCreateOrConnectWithoutUserInput
      | ApiKeyCreateOrConnectWithoutUserInput[];
    upsert?:
      | ApiKeyUpsertWithWhereUniqueWithoutUserInput
      | ApiKeyUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: ApiKeyCreateManyUserInputEnvelope;
    set?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[];
    disconnect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[];
    delete?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[];
    connect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[];
    update?:
      | ApiKeyUpdateWithWhereUniqueWithoutUserInput
      | ApiKeyUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | ApiKeyUpdateManyWithWhereWithoutUserInput
      | ApiKeyUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: ApiKeyScalarWhereInput | ApiKeyScalarWhereInput[];
  };

  export type AuditLogUncheckedUpdateManyWithoutActorNestedInput = {
    create?:
      | XOR<AuditLogCreateWithoutActorInput, AuditLogUncheckedCreateWithoutActorInput>
      | AuditLogCreateWithoutActorInput[]
      | AuditLogUncheckedCreateWithoutActorInput[];
    connectOrCreate?:
      | AuditLogCreateOrConnectWithoutActorInput
      | AuditLogCreateOrConnectWithoutActorInput[];
    upsert?:
      | AuditLogUpsertWithWhereUniqueWithoutActorInput
      | AuditLogUpsertWithWhereUniqueWithoutActorInput[];
    createMany?: AuditLogCreateManyActorInputEnvelope;
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
    update?:
      | AuditLogUpdateWithWhereUniqueWithoutActorInput
      | AuditLogUpdateWithWhereUniqueWithoutActorInput[];
    updateMany?:
      | AuditLogUpdateManyWithWhereWithoutActorInput
      | AuditLogUpdateManyWithWhereWithoutActorInput[];
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[];
  };

  export type TeamMemberUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput>
      | TeamMemberCreateWithoutUserInput[]
      | TeamMemberUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | TeamMemberCreateOrConnectWithoutUserInput
      | TeamMemberCreateOrConnectWithoutUserInput[];
    upsert?:
      | TeamMemberUpsertWithWhereUniqueWithoutUserInput
      | TeamMemberUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: TeamMemberCreateManyUserInputEnvelope;
    set?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[];
    disconnect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[];
    delete?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[];
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[];
    update?:
      | TeamMemberUpdateWithWhereUniqueWithoutUserInput
      | TeamMemberUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | TeamMemberUpdateManyWithWhereWithoutUserInput
      | TeamMemberUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[];
  };

  export type MentorUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<MentorCreateWithoutUserInput, MentorUncheckedCreateWithoutUserInput>
      | MentorCreateWithoutUserInput[]
      | MentorUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | MentorCreateOrConnectWithoutUserInput
      | MentorCreateOrConnectWithoutUserInput[];
    upsert?:
      | MentorUpsertWithWhereUniqueWithoutUserInput
      | MentorUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: MentorCreateManyUserInputEnvelope;
    set?: MentorWhereUniqueInput | MentorWhereUniqueInput[];
    disconnect?: MentorWhereUniqueInput | MentorWhereUniqueInput[];
    delete?: MentorWhereUniqueInput | MentorWhereUniqueInput[];
    connect?: MentorWhereUniqueInput | MentorWhereUniqueInput[];
    update?:
      | MentorUpdateWithWhereUniqueWithoutUserInput
      | MentorUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | MentorUpdateManyWithWhereWithoutUserInput
      | MentorUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: MentorScalarWhereInput | MentorScalarWhereInput[];
  };

  export type JudgeUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<JudgeCreateWithoutUserInput, JudgeUncheckedCreateWithoutUserInput>
      | JudgeCreateWithoutUserInput[]
      | JudgeUncheckedCreateWithoutUserInput[];
    connectOrCreate?: JudgeCreateOrConnectWithoutUserInput | JudgeCreateOrConnectWithoutUserInput[];
    upsert?:
      | JudgeUpsertWithWhereUniqueWithoutUserInput
      | JudgeUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: JudgeCreateManyUserInputEnvelope;
    set?: JudgeWhereUniqueInput | JudgeWhereUniqueInput[];
    disconnect?: JudgeWhereUniqueInput | JudgeWhereUniqueInput[];
    delete?: JudgeWhereUniqueInput | JudgeWhereUniqueInput[];
    connect?: JudgeWhereUniqueInput | JudgeWhereUniqueInput[];
    update?:
      | JudgeUpdateWithWhereUniqueWithoutUserInput
      | JudgeUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | JudgeUpdateManyWithWhereWithoutUserInput
      | JudgeUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: JudgeScalarWhereInput | JudgeScalarWhereInput[];
  };

  export type ChallengeSubmissionUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          ChallengeSubmissionCreateWithoutUserInput,
          ChallengeSubmissionUncheckedCreateWithoutUserInput
        >
      | ChallengeSubmissionCreateWithoutUserInput[]
      | ChallengeSubmissionUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | ChallengeSubmissionCreateOrConnectWithoutUserInput
      | ChallengeSubmissionCreateOrConnectWithoutUserInput[];
    upsert?:
      | ChallengeSubmissionUpsertWithWhereUniqueWithoutUserInput
      | ChallengeSubmissionUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: ChallengeSubmissionCreateManyUserInputEnvelope;
    set?: ChallengeSubmissionWhereUniqueInput | ChallengeSubmissionWhereUniqueInput[];
    disconnect?: ChallengeSubmissionWhereUniqueInput | ChallengeSubmissionWhereUniqueInput[];
    delete?: ChallengeSubmissionWhereUniqueInput | ChallengeSubmissionWhereUniqueInput[];
    connect?: ChallengeSubmissionWhereUniqueInput | ChallengeSubmissionWhereUniqueInput[];
    update?:
      | ChallengeSubmissionUpdateWithWhereUniqueWithoutUserInput
      | ChallengeSubmissionUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | ChallengeSubmissionUpdateManyWithWhereWithoutUserInput
      | ChallengeSubmissionUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: ChallengeSubmissionScalarWhereInput | ChallengeSubmissionScalarWhereInput[];
  };

  export type CommentUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?:
      | XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput>
      | CommentCreateWithoutAuthorInput[]
      | CommentUncheckedCreateWithoutAuthorInput[];
    connectOrCreate?:
      | CommentCreateOrConnectWithoutAuthorInput
      | CommentCreateOrConnectWithoutAuthorInput[];
    upsert?:
      | CommentUpsertWithWhereUniqueWithoutAuthorInput
      | CommentUpsertWithWhereUniqueWithoutAuthorInput[];
    createMany?: CommentCreateManyAuthorInputEnvelope;
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
    update?:
      | CommentUpdateWithWhereUniqueWithoutAuthorInput
      | CommentUpdateWithWhereUniqueWithoutAuthorInput[];
    updateMany?:
      | CommentUpdateManyWithWhereWithoutAuthorInput
      | CommentUpdateManyWithWhereWithoutAuthorInput[];
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[];
  };

  export type GamificationProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<
      GamificationProfileCreateWithoutUserInput,
      GamificationProfileUncheckedCreateWithoutUserInput
    >;
    connectOrCreate?: GamificationProfileCreateOrConnectWithoutUserInput;
    upsert?: GamificationProfileUpsertWithoutUserInput;
    disconnect?: GamificationProfileWhereInput | boolean;
    delete?: GamificationProfileWhereInput | boolean;
    connect?: GamificationProfileWhereUniqueInput;
    update?: XOR<
      XOR<
        GamificationProfileUpdateToOneWithWhereWithoutUserInput,
        GamificationProfileUpdateWithoutUserInput
      >,
      GamificationProfileUncheckedUpdateWithoutUserInput
    >;
  };

  export type XpEventUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<XpEventCreateWithoutUserInput, XpEventUncheckedCreateWithoutUserInput>
      | XpEventCreateWithoutUserInput[]
      | XpEventUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | XpEventCreateOrConnectWithoutUserInput
      | XpEventCreateOrConnectWithoutUserInput[];
    upsert?:
      | XpEventUpsertWithWhereUniqueWithoutUserInput
      | XpEventUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: XpEventCreateManyUserInputEnvelope;
    set?: XpEventWhereUniqueInput | XpEventWhereUniqueInput[];
    disconnect?: XpEventWhereUniqueInput | XpEventWhereUniqueInput[];
    delete?: XpEventWhereUniqueInput | XpEventWhereUniqueInput[];
    connect?: XpEventWhereUniqueInput | XpEventWhereUniqueInput[];
    update?:
      | XpEventUpdateWithWhereUniqueWithoutUserInput
      | XpEventUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | XpEventUpdateManyWithWhereWithoutUserInput
      | XpEventUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: XpEventScalarWhereInput | XpEventScalarWhereInput[];
  };

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
      | NotificationCreateWithoutUserInput[]
      | NotificationUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | NotificationCreateOrConnectWithoutUserInput
      | NotificationCreateOrConnectWithoutUserInput[];
    upsert?:
      | NotificationUpsertWithWhereUniqueWithoutUserInput
      | NotificationUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: NotificationCreateManyUserInputEnvelope;
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
    update?:
      | NotificationUpdateWithWhereUniqueWithoutUserInput
      | NotificationUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | NotificationUpdateManyWithWhereWithoutUserInput
      | NotificationUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[];
  };

  export type ReportUncheckedUpdateManyWithoutReporterNestedInput = {
    create?:
      | XOR<ReportCreateWithoutReporterInput, ReportUncheckedCreateWithoutReporterInput>
      | ReportCreateWithoutReporterInput[]
      | ReportUncheckedCreateWithoutReporterInput[];
    connectOrCreate?:
      | ReportCreateOrConnectWithoutReporterInput
      | ReportCreateOrConnectWithoutReporterInput[];
    upsert?:
      | ReportUpsertWithWhereUniqueWithoutReporterInput
      | ReportUpsertWithWhereUniqueWithoutReporterInput[];
    createMany?: ReportCreateManyReporterInputEnvelope;
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[];
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[];
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[];
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[];
    update?:
      | ReportUpdateWithWhereUniqueWithoutReporterInput
      | ReportUpdateWithWhereUniqueWithoutReporterInput[];
    updateMany?:
      | ReportUpdateManyWithWhereWithoutReporterInput
      | ReportUpdateManyWithWhereWithoutReporterInput[];
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[];
  };

  export type FileUncheckedUpdateManyWithoutUploadedByNestedInput = {
    create?:
      | XOR<FileCreateWithoutUploadedByInput, FileUncheckedCreateWithoutUploadedByInput>
      | FileCreateWithoutUploadedByInput[]
      | FileUncheckedCreateWithoutUploadedByInput[];
    connectOrCreate?:
      | FileCreateOrConnectWithoutUploadedByInput
      | FileCreateOrConnectWithoutUploadedByInput[];
    upsert?:
      | FileUpsertWithWhereUniqueWithoutUploadedByInput
      | FileUpsertWithWhereUniqueWithoutUploadedByInput[];
    createMany?: FileCreateManyUploadedByInputEnvelope;
    set?: FileWhereUniqueInput | FileWhereUniqueInput[];
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[];
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[];
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[];
    update?:
      | FileUpdateWithWhereUniqueWithoutUploadedByInput
      | FileUpdateWithWhereUniqueWithoutUploadedByInput[];
    updateMany?:
      | FileUpdateManyWithWhereWithoutUploadedByInput
      | FileUpdateManyWithWhereWithoutUploadedByInput[];
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[];
  };

  export type ChallengeUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?:
      | XOR<ChallengeCreateWithoutOwnerInput, ChallengeUncheckedCreateWithoutOwnerInput>
      | ChallengeCreateWithoutOwnerInput[]
      | ChallengeUncheckedCreateWithoutOwnerInput[];
    connectOrCreate?:
      | ChallengeCreateOrConnectWithoutOwnerInput
      | ChallengeCreateOrConnectWithoutOwnerInput[];
    upsert?:
      | ChallengeUpsertWithWhereUniqueWithoutOwnerInput
      | ChallengeUpsertWithWhereUniqueWithoutOwnerInput[];
    createMany?: ChallengeCreateManyOwnerInputEnvelope;
    set?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[];
    disconnect?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[];
    delete?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[];
    connect?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[];
    update?:
      | ChallengeUpdateWithWhereUniqueWithoutOwnerInput
      | ChallengeUpdateWithWhereUniqueWithoutOwnerInput[];
    updateMany?:
      | ChallengeUpdateManyWithWhereWithoutOwnerInput
      | ChallengeUpdateManyWithWhereWithoutOwnerInput[];
    deleteMany?: ChallengeScalarWhereInput | ChallengeScalarWhereInput[];
  };

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>;
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput;
    connect?: UserWhereUniqueInput;
  };

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
  };

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>;
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput;
    upsert?: UserUpsertWithoutAccountsInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>,
      UserUncheckedUpdateWithoutAccountsInput
    >;
  };

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>;
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput;
    connect?: UserWhereUniqueInput;
  };

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>;
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput;
    upsert?: UserUpsertWithoutSessionsInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>,
      UserUncheckedUpdateWithoutSessionsInput
    >;
  };

  export type ApiKeyCreatescopesInput = {
    set: string[];
  };

  export type UserCreateNestedOneWithoutApiKeysInput = {
    create?: XOR<UserCreateWithoutApiKeysInput, UserUncheckedCreateWithoutApiKeysInput>;
    connectOrCreate?: UserCreateOrConnectWithoutApiKeysInput;
    connect?: UserWhereUniqueInput;
  };

  export type ApiKeyUpdatescopesInput = {
    set?: string[];
    push?: string | string[];
  };

  export type UserUpdateOneRequiredWithoutApiKeysNestedInput = {
    create?: XOR<UserCreateWithoutApiKeysInput, UserUncheckedCreateWithoutApiKeysInput>;
    connectOrCreate?: UserCreateOrConnectWithoutApiKeysInput;
    upsert?: UserUpsertWithoutApiKeysInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<UserUpdateToOneWithWhereWithoutApiKeysInput, UserUpdateWithoutApiKeysInput>,
      UserUncheckedUpdateWithoutApiKeysInput
    >;
  };

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>;
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput;
    connect?: UserWhereUniqueInput;
  };

  export type UserUpdateOneWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>;
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput;
    upsert?: UserUpsertWithoutAuditLogsInput;
    disconnect?: UserWhereInput | boolean;
    delete?: UserWhereInput | boolean;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>,
      UserUncheckedUpdateWithoutAuditLogsInput
    >;
  };

  export type TrackCreateNestedManyWithoutHackathonInput = {
    create?:
      | XOR<TrackCreateWithoutHackathonInput, TrackUncheckedCreateWithoutHackathonInput>
      | TrackCreateWithoutHackathonInput[]
      | TrackUncheckedCreateWithoutHackathonInput[];
    connectOrCreate?:
      | TrackCreateOrConnectWithoutHackathonInput
      | TrackCreateOrConnectWithoutHackathonInput[];
    createMany?: TrackCreateManyHackathonInputEnvelope;
    connect?: TrackWhereUniqueInput | TrackWhereUniqueInput[];
  };

  export type TeamCreateNestedManyWithoutHackathonInput = {
    create?:
      | XOR<TeamCreateWithoutHackathonInput, TeamUncheckedCreateWithoutHackathonInput>
      | TeamCreateWithoutHackathonInput[]
      | TeamUncheckedCreateWithoutHackathonInput[];
    connectOrCreate?:
      | TeamCreateOrConnectWithoutHackathonInput
      | TeamCreateOrConnectWithoutHackathonInput[];
    createMany?: TeamCreateManyHackathonInputEnvelope;
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[];
  };

  export type MentorCreateNestedManyWithoutHackathonInput = {
    create?:
      | XOR<MentorCreateWithoutHackathonInput, MentorUncheckedCreateWithoutHackathonInput>
      | MentorCreateWithoutHackathonInput[]
      | MentorUncheckedCreateWithoutHackathonInput[];
    connectOrCreate?:
      | MentorCreateOrConnectWithoutHackathonInput
      | MentorCreateOrConnectWithoutHackathonInput[];
    createMany?: MentorCreateManyHackathonInputEnvelope;
    connect?: MentorWhereUniqueInput | MentorWhereUniqueInput[];
  };

  export type JudgeCreateNestedManyWithoutHackathonInput = {
    create?:
      | XOR<JudgeCreateWithoutHackathonInput, JudgeUncheckedCreateWithoutHackathonInput>
      | JudgeCreateWithoutHackathonInput[]
      | JudgeUncheckedCreateWithoutHackathonInput[];
    connectOrCreate?:
      | JudgeCreateOrConnectWithoutHackathonInput
      | JudgeCreateOrConnectWithoutHackathonInput[];
    createMany?: JudgeCreateManyHackathonInputEnvelope;
    connect?: JudgeWhereUniqueInput | JudgeWhereUniqueInput[];
  };

  export type CriteriaCreateNestedManyWithoutHackathonInput = {
    create?:
      | XOR<CriteriaCreateWithoutHackathonInput, CriteriaUncheckedCreateWithoutHackathonInput>
      | CriteriaCreateWithoutHackathonInput[]
      | CriteriaUncheckedCreateWithoutHackathonInput[];
    connectOrCreate?:
      | CriteriaCreateOrConnectWithoutHackathonInput
      | CriteriaCreateOrConnectWithoutHackathonInput[];
    createMany?: CriteriaCreateManyHackathonInputEnvelope;
    connect?: CriteriaWhereUniqueInput | CriteriaWhereUniqueInput[];
  };

  export type SubmissionCreateNestedManyWithoutHackathonInput = {
    create?:
      | XOR<SubmissionCreateWithoutHackathonInput, SubmissionUncheckedCreateWithoutHackathonInput>
      | SubmissionCreateWithoutHackathonInput[]
      | SubmissionUncheckedCreateWithoutHackathonInput[];
    connectOrCreate?:
      | SubmissionCreateOrConnectWithoutHackathonInput
      | SubmissionCreateOrConnectWithoutHackathonInput[];
    createMany?: SubmissionCreateManyHackathonInputEnvelope;
    connect?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[];
  };

  export type AnnouncementCreateNestedManyWithoutHackathonInput = {
    create?:
      | XOR<
          AnnouncementCreateWithoutHackathonInput,
          AnnouncementUncheckedCreateWithoutHackathonInput
        >
      | AnnouncementCreateWithoutHackathonInput[]
      | AnnouncementUncheckedCreateWithoutHackathonInput[];
    connectOrCreate?:
      | AnnouncementCreateOrConnectWithoutHackathonInput
      | AnnouncementCreateOrConnectWithoutHackathonInput[];
    createMany?: AnnouncementCreateManyHackathonInputEnvelope;
    connect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[];
  };

  export type TrackUncheckedCreateNestedManyWithoutHackathonInput = {
    create?:
      | XOR<TrackCreateWithoutHackathonInput, TrackUncheckedCreateWithoutHackathonInput>
      | TrackCreateWithoutHackathonInput[]
      | TrackUncheckedCreateWithoutHackathonInput[];
    connectOrCreate?:
      | TrackCreateOrConnectWithoutHackathonInput
      | TrackCreateOrConnectWithoutHackathonInput[];
    createMany?: TrackCreateManyHackathonInputEnvelope;
    connect?: TrackWhereUniqueInput | TrackWhereUniqueInput[];
  };

  export type TeamUncheckedCreateNestedManyWithoutHackathonInput = {
    create?:
      | XOR<TeamCreateWithoutHackathonInput, TeamUncheckedCreateWithoutHackathonInput>
      | TeamCreateWithoutHackathonInput[]
      | TeamUncheckedCreateWithoutHackathonInput[];
    connectOrCreate?:
      | TeamCreateOrConnectWithoutHackathonInput
      | TeamCreateOrConnectWithoutHackathonInput[];
    createMany?: TeamCreateManyHackathonInputEnvelope;
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[];
  };

  export type MentorUncheckedCreateNestedManyWithoutHackathonInput = {
    create?:
      | XOR<MentorCreateWithoutHackathonInput, MentorUncheckedCreateWithoutHackathonInput>
      | MentorCreateWithoutHackathonInput[]
      | MentorUncheckedCreateWithoutHackathonInput[];
    connectOrCreate?:
      | MentorCreateOrConnectWithoutHackathonInput
      | MentorCreateOrConnectWithoutHackathonInput[];
    createMany?: MentorCreateManyHackathonInputEnvelope;
    connect?: MentorWhereUniqueInput | MentorWhereUniqueInput[];
  };

  export type JudgeUncheckedCreateNestedManyWithoutHackathonInput = {
    create?:
      | XOR<JudgeCreateWithoutHackathonInput, JudgeUncheckedCreateWithoutHackathonInput>
      | JudgeCreateWithoutHackathonInput[]
      | JudgeUncheckedCreateWithoutHackathonInput[];
    connectOrCreate?:
      | JudgeCreateOrConnectWithoutHackathonInput
      | JudgeCreateOrConnectWithoutHackathonInput[];
    createMany?: JudgeCreateManyHackathonInputEnvelope;
    connect?: JudgeWhereUniqueInput | JudgeWhereUniqueInput[];
  };

  export type CriteriaUncheckedCreateNestedManyWithoutHackathonInput = {
    create?:
      | XOR<CriteriaCreateWithoutHackathonInput, CriteriaUncheckedCreateWithoutHackathonInput>
      | CriteriaCreateWithoutHackathonInput[]
      | CriteriaUncheckedCreateWithoutHackathonInput[];
    connectOrCreate?:
      | CriteriaCreateOrConnectWithoutHackathonInput
      | CriteriaCreateOrConnectWithoutHackathonInput[];
    createMany?: CriteriaCreateManyHackathonInputEnvelope;
    connect?: CriteriaWhereUniqueInput | CriteriaWhereUniqueInput[];
  };

  export type SubmissionUncheckedCreateNestedManyWithoutHackathonInput = {
    create?:
      | XOR<SubmissionCreateWithoutHackathonInput, SubmissionUncheckedCreateWithoutHackathonInput>
      | SubmissionCreateWithoutHackathonInput[]
      | SubmissionUncheckedCreateWithoutHackathonInput[];
    connectOrCreate?:
      | SubmissionCreateOrConnectWithoutHackathonInput
      | SubmissionCreateOrConnectWithoutHackathonInput[];
    createMany?: SubmissionCreateManyHackathonInputEnvelope;
    connect?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[];
  };

  export type AnnouncementUncheckedCreateNestedManyWithoutHackathonInput = {
    create?:
      | XOR<
          AnnouncementCreateWithoutHackathonInput,
          AnnouncementUncheckedCreateWithoutHackathonInput
        >
      | AnnouncementCreateWithoutHackathonInput[]
      | AnnouncementUncheckedCreateWithoutHackathonInput[];
    connectOrCreate?:
      | AnnouncementCreateOrConnectWithoutHackathonInput
      | AnnouncementCreateOrConnectWithoutHackathonInput[];
    createMany?: AnnouncementCreateManyHackathonInputEnvelope;
    connect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[];
  };

  export type EnumHackathonStatusFieldUpdateOperationsInput = {
    set?: $Enums.HackathonStatus;
  };

  export type EnumHackathonLocationFieldUpdateOperationsInput = {
    set?: $Enums.HackathonLocation;
  };

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null;
    increment?: Decimal | DecimalJsLike | number | string;
    decrement?: Decimal | DecimalJsLike | number | string;
    multiply?: Decimal | DecimalJsLike | number | string;
    divide?: Decimal | DecimalJsLike | number | string;
  };

  export type IntFieldUpdateOperationsInput = {
    set?: number;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
  };

  export type TrackUpdateManyWithoutHackathonNestedInput = {
    create?:
      | XOR<TrackCreateWithoutHackathonInput, TrackUncheckedCreateWithoutHackathonInput>
      | TrackCreateWithoutHackathonInput[]
      | TrackUncheckedCreateWithoutHackathonInput[];
    connectOrCreate?:
      | TrackCreateOrConnectWithoutHackathonInput
      | TrackCreateOrConnectWithoutHackathonInput[];
    upsert?:
      | TrackUpsertWithWhereUniqueWithoutHackathonInput
      | TrackUpsertWithWhereUniqueWithoutHackathonInput[];
    createMany?: TrackCreateManyHackathonInputEnvelope;
    set?: TrackWhereUniqueInput | TrackWhereUniqueInput[];
    disconnect?: TrackWhereUniqueInput | TrackWhereUniqueInput[];
    delete?: TrackWhereUniqueInput | TrackWhereUniqueInput[];
    connect?: TrackWhereUniqueInput | TrackWhereUniqueInput[];
    update?:
      | TrackUpdateWithWhereUniqueWithoutHackathonInput
      | TrackUpdateWithWhereUniqueWithoutHackathonInput[];
    updateMany?:
      | TrackUpdateManyWithWhereWithoutHackathonInput
      | TrackUpdateManyWithWhereWithoutHackathonInput[];
    deleteMany?: TrackScalarWhereInput | TrackScalarWhereInput[];
  };

  export type TeamUpdateManyWithoutHackathonNestedInput = {
    create?:
      | XOR<TeamCreateWithoutHackathonInput, TeamUncheckedCreateWithoutHackathonInput>
      | TeamCreateWithoutHackathonInput[]
      | TeamUncheckedCreateWithoutHackathonInput[];
    connectOrCreate?:
      | TeamCreateOrConnectWithoutHackathonInput
      | TeamCreateOrConnectWithoutHackathonInput[];
    upsert?:
      | TeamUpsertWithWhereUniqueWithoutHackathonInput
      | TeamUpsertWithWhereUniqueWithoutHackathonInput[];
    createMany?: TeamCreateManyHackathonInputEnvelope;
    set?: TeamWhereUniqueInput | TeamWhereUniqueInput[];
    disconnect?: TeamWhereUniqueInput | TeamWhereUniqueInput[];
    delete?: TeamWhereUniqueInput | TeamWhereUniqueInput[];
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[];
    update?:
      | TeamUpdateWithWhereUniqueWithoutHackathonInput
      | TeamUpdateWithWhereUniqueWithoutHackathonInput[];
    updateMany?:
      | TeamUpdateManyWithWhereWithoutHackathonInput
      | TeamUpdateManyWithWhereWithoutHackathonInput[];
    deleteMany?: TeamScalarWhereInput | TeamScalarWhereInput[];
  };

  export type MentorUpdateManyWithoutHackathonNestedInput = {
    create?:
      | XOR<MentorCreateWithoutHackathonInput, MentorUncheckedCreateWithoutHackathonInput>
      | MentorCreateWithoutHackathonInput[]
      | MentorUncheckedCreateWithoutHackathonInput[];
    connectOrCreate?:
      | MentorCreateOrConnectWithoutHackathonInput
      | MentorCreateOrConnectWithoutHackathonInput[];
    upsert?:
      | MentorUpsertWithWhereUniqueWithoutHackathonInput
      | MentorUpsertWithWhereUniqueWithoutHackathonInput[];
    createMany?: MentorCreateManyHackathonInputEnvelope;
    set?: MentorWhereUniqueInput | MentorWhereUniqueInput[];
    disconnect?: MentorWhereUniqueInput | MentorWhereUniqueInput[];
    delete?: MentorWhereUniqueInput | MentorWhereUniqueInput[];
    connect?: MentorWhereUniqueInput | MentorWhereUniqueInput[];
    update?:
      | MentorUpdateWithWhereUniqueWithoutHackathonInput
      | MentorUpdateWithWhereUniqueWithoutHackathonInput[];
    updateMany?:
      | MentorUpdateManyWithWhereWithoutHackathonInput
      | MentorUpdateManyWithWhereWithoutHackathonInput[];
    deleteMany?: MentorScalarWhereInput | MentorScalarWhereInput[];
  };

  export type JudgeUpdateManyWithoutHackathonNestedInput = {
    create?:
      | XOR<JudgeCreateWithoutHackathonInput, JudgeUncheckedCreateWithoutHackathonInput>
      | JudgeCreateWithoutHackathonInput[]
      | JudgeUncheckedCreateWithoutHackathonInput[];
    connectOrCreate?:
      | JudgeCreateOrConnectWithoutHackathonInput
      | JudgeCreateOrConnectWithoutHackathonInput[];
    upsert?:
      | JudgeUpsertWithWhereUniqueWithoutHackathonInput
      | JudgeUpsertWithWhereUniqueWithoutHackathonInput[];
    createMany?: JudgeCreateManyHackathonInputEnvelope;
    set?: JudgeWhereUniqueInput | JudgeWhereUniqueInput[];
    disconnect?: JudgeWhereUniqueInput | JudgeWhereUniqueInput[];
    delete?: JudgeWhereUniqueInput | JudgeWhereUniqueInput[];
    connect?: JudgeWhereUniqueInput | JudgeWhereUniqueInput[];
    update?:
      | JudgeUpdateWithWhereUniqueWithoutHackathonInput
      | JudgeUpdateWithWhereUniqueWithoutHackathonInput[];
    updateMany?:
      | JudgeUpdateManyWithWhereWithoutHackathonInput
      | JudgeUpdateManyWithWhereWithoutHackathonInput[];
    deleteMany?: JudgeScalarWhereInput | JudgeScalarWhereInput[];
  };

  export type CriteriaUpdateManyWithoutHackathonNestedInput = {
    create?:
      | XOR<CriteriaCreateWithoutHackathonInput, CriteriaUncheckedCreateWithoutHackathonInput>
      | CriteriaCreateWithoutHackathonInput[]
      | CriteriaUncheckedCreateWithoutHackathonInput[];
    connectOrCreate?:
      | CriteriaCreateOrConnectWithoutHackathonInput
      | CriteriaCreateOrConnectWithoutHackathonInput[];
    upsert?:
      | CriteriaUpsertWithWhereUniqueWithoutHackathonInput
      | CriteriaUpsertWithWhereUniqueWithoutHackathonInput[];
    createMany?: CriteriaCreateManyHackathonInputEnvelope;
    set?: CriteriaWhereUniqueInput | CriteriaWhereUniqueInput[];
    disconnect?: CriteriaWhereUniqueInput | CriteriaWhereUniqueInput[];
    delete?: CriteriaWhereUniqueInput | CriteriaWhereUniqueInput[];
    connect?: CriteriaWhereUniqueInput | CriteriaWhereUniqueInput[];
    update?:
      | CriteriaUpdateWithWhereUniqueWithoutHackathonInput
      | CriteriaUpdateWithWhereUniqueWithoutHackathonInput[];
    updateMany?:
      | CriteriaUpdateManyWithWhereWithoutHackathonInput
      | CriteriaUpdateManyWithWhereWithoutHackathonInput[];
    deleteMany?: CriteriaScalarWhereInput | CriteriaScalarWhereInput[];
  };

  export type SubmissionUpdateManyWithoutHackathonNestedInput = {
    create?:
      | XOR<SubmissionCreateWithoutHackathonInput, SubmissionUncheckedCreateWithoutHackathonInput>
      | SubmissionCreateWithoutHackathonInput[]
      | SubmissionUncheckedCreateWithoutHackathonInput[];
    connectOrCreate?:
      | SubmissionCreateOrConnectWithoutHackathonInput
      | SubmissionCreateOrConnectWithoutHackathonInput[];
    upsert?:
      | SubmissionUpsertWithWhereUniqueWithoutHackathonInput
      | SubmissionUpsertWithWhereUniqueWithoutHackathonInput[];
    createMany?: SubmissionCreateManyHackathonInputEnvelope;
    set?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[];
    disconnect?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[];
    delete?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[];
    connect?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[];
    update?:
      | SubmissionUpdateWithWhereUniqueWithoutHackathonInput
      | SubmissionUpdateWithWhereUniqueWithoutHackathonInput[];
    updateMany?:
      | SubmissionUpdateManyWithWhereWithoutHackathonInput
      | SubmissionUpdateManyWithWhereWithoutHackathonInput[];
    deleteMany?: SubmissionScalarWhereInput | SubmissionScalarWhereInput[];
  };

  export type AnnouncementUpdateManyWithoutHackathonNestedInput = {
    create?:
      | XOR<
          AnnouncementCreateWithoutHackathonInput,
          AnnouncementUncheckedCreateWithoutHackathonInput
        >
      | AnnouncementCreateWithoutHackathonInput[]
      | AnnouncementUncheckedCreateWithoutHackathonInput[];
    connectOrCreate?:
      | AnnouncementCreateOrConnectWithoutHackathonInput
      | AnnouncementCreateOrConnectWithoutHackathonInput[];
    upsert?:
      | AnnouncementUpsertWithWhereUniqueWithoutHackathonInput
      | AnnouncementUpsertWithWhereUniqueWithoutHackathonInput[];
    createMany?: AnnouncementCreateManyHackathonInputEnvelope;
    set?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[];
    disconnect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[];
    delete?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[];
    connect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[];
    update?:
      | AnnouncementUpdateWithWhereUniqueWithoutHackathonInput
      | AnnouncementUpdateWithWhereUniqueWithoutHackathonInput[];
    updateMany?:
      | AnnouncementUpdateManyWithWhereWithoutHackathonInput
      | AnnouncementUpdateManyWithWhereWithoutHackathonInput[];
    deleteMany?: AnnouncementScalarWhereInput | AnnouncementScalarWhereInput[];
  };

  export type TrackUncheckedUpdateManyWithoutHackathonNestedInput = {
    create?:
      | XOR<TrackCreateWithoutHackathonInput, TrackUncheckedCreateWithoutHackathonInput>
      | TrackCreateWithoutHackathonInput[]
      | TrackUncheckedCreateWithoutHackathonInput[];
    connectOrCreate?:
      | TrackCreateOrConnectWithoutHackathonInput
      | TrackCreateOrConnectWithoutHackathonInput[];
    upsert?:
      | TrackUpsertWithWhereUniqueWithoutHackathonInput
      | TrackUpsertWithWhereUniqueWithoutHackathonInput[];
    createMany?: TrackCreateManyHackathonInputEnvelope;
    set?: TrackWhereUniqueInput | TrackWhereUniqueInput[];
    disconnect?: TrackWhereUniqueInput | TrackWhereUniqueInput[];
    delete?: TrackWhereUniqueInput | TrackWhereUniqueInput[];
    connect?: TrackWhereUniqueInput | TrackWhereUniqueInput[];
    update?:
      | TrackUpdateWithWhereUniqueWithoutHackathonInput
      | TrackUpdateWithWhereUniqueWithoutHackathonInput[];
    updateMany?:
      | TrackUpdateManyWithWhereWithoutHackathonInput
      | TrackUpdateManyWithWhereWithoutHackathonInput[];
    deleteMany?: TrackScalarWhereInput | TrackScalarWhereInput[];
  };

  export type TeamUncheckedUpdateManyWithoutHackathonNestedInput = {
    create?:
      | XOR<TeamCreateWithoutHackathonInput, TeamUncheckedCreateWithoutHackathonInput>
      | TeamCreateWithoutHackathonInput[]
      | TeamUncheckedCreateWithoutHackathonInput[];
    connectOrCreate?:
      | TeamCreateOrConnectWithoutHackathonInput
      | TeamCreateOrConnectWithoutHackathonInput[];
    upsert?:
      | TeamUpsertWithWhereUniqueWithoutHackathonInput
      | TeamUpsertWithWhereUniqueWithoutHackathonInput[];
    createMany?: TeamCreateManyHackathonInputEnvelope;
    set?: TeamWhereUniqueInput | TeamWhereUniqueInput[];
    disconnect?: TeamWhereUniqueInput | TeamWhereUniqueInput[];
    delete?: TeamWhereUniqueInput | TeamWhereUniqueInput[];
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[];
    update?:
      | TeamUpdateWithWhereUniqueWithoutHackathonInput
      | TeamUpdateWithWhereUniqueWithoutHackathonInput[];
    updateMany?:
      | TeamUpdateManyWithWhereWithoutHackathonInput
      | TeamUpdateManyWithWhereWithoutHackathonInput[];
    deleteMany?: TeamScalarWhereInput | TeamScalarWhereInput[];
  };

  export type MentorUncheckedUpdateManyWithoutHackathonNestedInput = {
    create?:
      | XOR<MentorCreateWithoutHackathonInput, MentorUncheckedCreateWithoutHackathonInput>
      | MentorCreateWithoutHackathonInput[]
      | MentorUncheckedCreateWithoutHackathonInput[];
    connectOrCreate?:
      | MentorCreateOrConnectWithoutHackathonInput
      | MentorCreateOrConnectWithoutHackathonInput[];
    upsert?:
      | MentorUpsertWithWhereUniqueWithoutHackathonInput
      | MentorUpsertWithWhereUniqueWithoutHackathonInput[];
    createMany?: MentorCreateManyHackathonInputEnvelope;
    set?: MentorWhereUniqueInput | MentorWhereUniqueInput[];
    disconnect?: MentorWhereUniqueInput | MentorWhereUniqueInput[];
    delete?: MentorWhereUniqueInput | MentorWhereUniqueInput[];
    connect?: MentorWhereUniqueInput | MentorWhereUniqueInput[];
    update?:
      | MentorUpdateWithWhereUniqueWithoutHackathonInput
      | MentorUpdateWithWhereUniqueWithoutHackathonInput[];
    updateMany?:
      | MentorUpdateManyWithWhereWithoutHackathonInput
      | MentorUpdateManyWithWhereWithoutHackathonInput[];
    deleteMany?: MentorScalarWhereInput | MentorScalarWhereInput[];
  };

  export type JudgeUncheckedUpdateManyWithoutHackathonNestedInput = {
    create?:
      | XOR<JudgeCreateWithoutHackathonInput, JudgeUncheckedCreateWithoutHackathonInput>
      | JudgeCreateWithoutHackathonInput[]
      | JudgeUncheckedCreateWithoutHackathonInput[];
    connectOrCreate?:
      | JudgeCreateOrConnectWithoutHackathonInput
      | JudgeCreateOrConnectWithoutHackathonInput[];
    upsert?:
      | JudgeUpsertWithWhereUniqueWithoutHackathonInput
      | JudgeUpsertWithWhereUniqueWithoutHackathonInput[];
    createMany?: JudgeCreateManyHackathonInputEnvelope;
    set?: JudgeWhereUniqueInput | JudgeWhereUniqueInput[];
    disconnect?: JudgeWhereUniqueInput | JudgeWhereUniqueInput[];
    delete?: JudgeWhereUniqueInput | JudgeWhereUniqueInput[];
    connect?: JudgeWhereUniqueInput | JudgeWhereUniqueInput[];
    update?:
      | JudgeUpdateWithWhereUniqueWithoutHackathonInput
      | JudgeUpdateWithWhereUniqueWithoutHackathonInput[];
    updateMany?:
      | JudgeUpdateManyWithWhereWithoutHackathonInput
      | JudgeUpdateManyWithWhereWithoutHackathonInput[];
    deleteMany?: JudgeScalarWhereInput | JudgeScalarWhereInput[];
  };

  export type CriteriaUncheckedUpdateManyWithoutHackathonNestedInput = {
    create?:
      | XOR<CriteriaCreateWithoutHackathonInput, CriteriaUncheckedCreateWithoutHackathonInput>
      | CriteriaCreateWithoutHackathonInput[]
      | CriteriaUncheckedCreateWithoutHackathonInput[];
    connectOrCreate?:
      | CriteriaCreateOrConnectWithoutHackathonInput
      | CriteriaCreateOrConnectWithoutHackathonInput[];
    upsert?:
      | CriteriaUpsertWithWhereUniqueWithoutHackathonInput
      | CriteriaUpsertWithWhereUniqueWithoutHackathonInput[];
    createMany?: CriteriaCreateManyHackathonInputEnvelope;
    set?: CriteriaWhereUniqueInput | CriteriaWhereUniqueInput[];
    disconnect?: CriteriaWhereUniqueInput | CriteriaWhereUniqueInput[];
    delete?: CriteriaWhereUniqueInput | CriteriaWhereUniqueInput[];
    connect?: CriteriaWhereUniqueInput | CriteriaWhereUniqueInput[];
    update?:
      | CriteriaUpdateWithWhereUniqueWithoutHackathonInput
      | CriteriaUpdateWithWhereUniqueWithoutHackathonInput[];
    updateMany?:
      | CriteriaUpdateManyWithWhereWithoutHackathonInput
      | CriteriaUpdateManyWithWhereWithoutHackathonInput[];
    deleteMany?: CriteriaScalarWhereInput | CriteriaScalarWhereInput[];
  };

  export type SubmissionUncheckedUpdateManyWithoutHackathonNestedInput = {
    create?:
      | XOR<SubmissionCreateWithoutHackathonInput, SubmissionUncheckedCreateWithoutHackathonInput>
      | SubmissionCreateWithoutHackathonInput[]
      | SubmissionUncheckedCreateWithoutHackathonInput[];
    connectOrCreate?:
      | SubmissionCreateOrConnectWithoutHackathonInput
      | SubmissionCreateOrConnectWithoutHackathonInput[];
    upsert?:
      | SubmissionUpsertWithWhereUniqueWithoutHackathonInput
      | SubmissionUpsertWithWhereUniqueWithoutHackathonInput[];
    createMany?: SubmissionCreateManyHackathonInputEnvelope;
    set?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[];
    disconnect?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[];
    delete?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[];
    connect?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[];
    update?:
      | SubmissionUpdateWithWhereUniqueWithoutHackathonInput
      | SubmissionUpdateWithWhereUniqueWithoutHackathonInput[];
    updateMany?:
      | SubmissionUpdateManyWithWhereWithoutHackathonInput
      | SubmissionUpdateManyWithWhereWithoutHackathonInput[];
    deleteMany?: SubmissionScalarWhereInput | SubmissionScalarWhereInput[];
  };

  export type AnnouncementUncheckedUpdateManyWithoutHackathonNestedInput = {
    create?:
      | XOR<
          AnnouncementCreateWithoutHackathonInput,
          AnnouncementUncheckedCreateWithoutHackathonInput
        >
      | AnnouncementCreateWithoutHackathonInput[]
      | AnnouncementUncheckedCreateWithoutHackathonInput[];
    connectOrCreate?:
      | AnnouncementCreateOrConnectWithoutHackathonInput
      | AnnouncementCreateOrConnectWithoutHackathonInput[];
    upsert?:
      | AnnouncementUpsertWithWhereUniqueWithoutHackathonInput
      | AnnouncementUpsertWithWhereUniqueWithoutHackathonInput[];
    createMany?: AnnouncementCreateManyHackathonInputEnvelope;
    set?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[];
    disconnect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[];
    delete?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[];
    connect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[];
    update?:
      | AnnouncementUpdateWithWhereUniqueWithoutHackathonInput
      | AnnouncementUpdateWithWhereUniqueWithoutHackathonInput[];
    updateMany?:
      | AnnouncementUpdateManyWithWhereWithoutHackathonInput
      | AnnouncementUpdateManyWithWhereWithoutHackathonInput[];
    deleteMany?: AnnouncementScalarWhereInput | AnnouncementScalarWhereInput[];
  };

  export type HackathonCreateNestedOneWithoutTracksInput = {
    create?: XOR<HackathonCreateWithoutTracksInput, HackathonUncheckedCreateWithoutTracksInput>;
    connectOrCreate?: HackathonCreateOrConnectWithoutTracksInput;
    connect?: HackathonWhereUniqueInput;
  };

  export type SubmissionCreateNestedManyWithoutTrackInput = {
    create?:
      | XOR<SubmissionCreateWithoutTrackInput, SubmissionUncheckedCreateWithoutTrackInput>
      | SubmissionCreateWithoutTrackInput[]
      | SubmissionUncheckedCreateWithoutTrackInput[];
    connectOrCreate?:
      | SubmissionCreateOrConnectWithoutTrackInput
      | SubmissionCreateOrConnectWithoutTrackInput[];
    createMany?: SubmissionCreateManyTrackInputEnvelope;
    connect?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[];
  };

  export type SubmissionUncheckedCreateNestedManyWithoutTrackInput = {
    create?:
      | XOR<SubmissionCreateWithoutTrackInput, SubmissionUncheckedCreateWithoutTrackInput>
      | SubmissionCreateWithoutTrackInput[]
      | SubmissionUncheckedCreateWithoutTrackInput[];
    connectOrCreate?:
      | SubmissionCreateOrConnectWithoutTrackInput
      | SubmissionCreateOrConnectWithoutTrackInput[];
    createMany?: SubmissionCreateManyTrackInputEnvelope;
    connect?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[];
  };

  export type HackathonUpdateOneRequiredWithoutTracksNestedInput = {
    create?: XOR<HackathonCreateWithoutTracksInput, HackathonUncheckedCreateWithoutTracksInput>;
    connectOrCreate?: HackathonCreateOrConnectWithoutTracksInput;
    upsert?: HackathonUpsertWithoutTracksInput;
    connect?: HackathonWhereUniqueInput;
    update?: XOR<
      XOR<HackathonUpdateToOneWithWhereWithoutTracksInput, HackathonUpdateWithoutTracksInput>,
      HackathonUncheckedUpdateWithoutTracksInput
    >;
  };

  export type SubmissionUpdateManyWithoutTrackNestedInput = {
    create?:
      | XOR<SubmissionCreateWithoutTrackInput, SubmissionUncheckedCreateWithoutTrackInput>
      | SubmissionCreateWithoutTrackInput[]
      | SubmissionUncheckedCreateWithoutTrackInput[];
    connectOrCreate?:
      | SubmissionCreateOrConnectWithoutTrackInput
      | SubmissionCreateOrConnectWithoutTrackInput[];
    upsert?:
      | SubmissionUpsertWithWhereUniqueWithoutTrackInput
      | SubmissionUpsertWithWhereUniqueWithoutTrackInput[];
    createMany?: SubmissionCreateManyTrackInputEnvelope;
    set?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[];
    disconnect?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[];
    delete?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[];
    connect?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[];
    update?:
      | SubmissionUpdateWithWhereUniqueWithoutTrackInput
      | SubmissionUpdateWithWhereUniqueWithoutTrackInput[];
    updateMany?:
      | SubmissionUpdateManyWithWhereWithoutTrackInput
      | SubmissionUpdateManyWithWhereWithoutTrackInput[];
    deleteMany?: SubmissionScalarWhereInput | SubmissionScalarWhereInput[];
  };

  export type SubmissionUncheckedUpdateManyWithoutTrackNestedInput = {
    create?:
      | XOR<SubmissionCreateWithoutTrackInput, SubmissionUncheckedCreateWithoutTrackInput>
      | SubmissionCreateWithoutTrackInput[]
      | SubmissionUncheckedCreateWithoutTrackInput[];
    connectOrCreate?:
      | SubmissionCreateOrConnectWithoutTrackInput
      | SubmissionCreateOrConnectWithoutTrackInput[];
    upsert?:
      | SubmissionUpsertWithWhereUniqueWithoutTrackInput
      | SubmissionUpsertWithWhereUniqueWithoutTrackInput[];
    createMany?: SubmissionCreateManyTrackInputEnvelope;
    set?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[];
    disconnect?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[];
    delete?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[];
    connect?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[];
    update?:
      | SubmissionUpdateWithWhereUniqueWithoutTrackInput
      | SubmissionUpdateWithWhereUniqueWithoutTrackInput[];
    updateMany?:
      | SubmissionUpdateManyWithWhereWithoutTrackInput
      | SubmissionUpdateManyWithWhereWithoutTrackInput[];
    deleteMany?: SubmissionScalarWhereInput | SubmissionScalarWhereInput[];
  };

  export type HackathonCreateNestedOneWithoutTeamsInput = {
    create?: XOR<HackathonCreateWithoutTeamsInput, HackathonUncheckedCreateWithoutTeamsInput>;
    connectOrCreate?: HackathonCreateOrConnectWithoutTeamsInput;
    connect?: HackathonWhereUniqueInput;
  };

  export type TeamMemberCreateNestedManyWithoutTeamInput = {
    create?:
      | XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput>
      | TeamMemberCreateWithoutTeamInput[]
      | TeamMemberUncheckedCreateWithoutTeamInput[];
    connectOrCreate?:
      | TeamMemberCreateOrConnectWithoutTeamInput
      | TeamMemberCreateOrConnectWithoutTeamInput[];
    createMany?: TeamMemberCreateManyTeamInputEnvelope;
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[];
  };

  export type SubmissionCreateNestedManyWithoutTeamInput = {
    create?:
      | XOR<SubmissionCreateWithoutTeamInput, SubmissionUncheckedCreateWithoutTeamInput>
      | SubmissionCreateWithoutTeamInput[]
      | SubmissionUncheckedCreateWithoutTeamInput[];
    connectOrCreate?:
      | SubmissionCreateOrConnectWithoutTeamInput
      | SubmissionCreateOrConnectWithoutTeamInput[];
    createMany?: SubmissionCreateManyTeamInputEnvelope;
    connect?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[];
  };

  export type ChallengeSubmissionCreateNestedManyWithoutTeamInput = {
    create?:
      | XOR<
          ChallengeSubmissionCreateWithoutTeamInput,
          ChallengeSubmissionUncheckedCreateWithoutTeamInput
        >
      | ChallengeSubmissionCreateWithoutTeamInput[]
      | ChallengeSubmissionUncheckedCreateWithoutTeamInput[];
    connectOrCreate?:
      | ChallengeSubmissionCreateOrConnectWithoutTeamInput
      | ChallengeSubmissionCreateOrConnectWithoutTeamInput[];
    createMany?: ChallengeSubmissionCreateManyTeamInputEnvelope;
    connect?: ChallengeSubmissionWhereUniqueInput | ChallengeSubmissionWhereUniqueInput[];
  };

  export type TeamMemberUncheckedCreateNestedManyWithoutTeamInput = {
    create?:
      | XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput>
      | TeamMemberCreateWithoutTeamInput[]
      | TeamMemberUncheckedCreateWithoutTeamInput[];
    connectOrCreate?:
      | TeamMemberCreateOrConnectWithoutTeamInput
      | TeamMemberCreateOrConnectWithoutTeamInput[];
    createMany?: TeamMemberCreateManyTeamInputEnvelope;
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[];
  };

  export type SubmissionUncheckedCreateNestedManyWithoutTeamInput = {
    create?:
      | XOR<SubmissionCreateWithoutTeamInput, SubmissionUncheckedCreateWithoutTeamInput>
      | SubmissionCreateWithoutTeamInput[]
      | SubmissionUncheckedCreateWithoutTeamInput[];
    connectOrCreate?:
      | SubmissionCreateOrConnectWithoutTeamInput
      | SubmissionCreateOrConnectWithoutTeamInput[];
    createMany?: SubmissionCreateManyTeamInputEnvelope;
    connect?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[];
  };

  export type ChallengeSubmissionUncheckedCreateNestedManyWithoutTeamInput = {
    create?:
      | XOR<
          ChallengeSubmissionCreateWithoutTeamInput,
          ChallengeSubmissionUncheckedCreateWithoutTeamInput
        >
      | ChallengeSubmissionCreateWithoutTeamInput[]
      | ChallengeSubmissionUncheckedCreateWithoutTeamInput[];
    connectOrCreate?:
      | ChallengeSubmissionCreateOrConnectWithoutTeamInput
      | ChallengeSubmissionCreateOrConnectWithoutTeamInput[];
    createMany?: ChallengeSubmissionCreateManyTeamInputEnvelope;
    connect?: ChallengeSubmissionWhereUniqueInput | ChallengeSubmissionWhereUniqueInput[];
  };

  export type HackathonUpdateOneRequiredWithoutTeamsNestedInput = {
    create?: XOR<HackathonCreateWithoutTeamsInput, HackathonUncheckedCreateWithoutTeamsInput>;
    connectOrCreate?: HackathonCreateOrConnectWithoutTeamsInput;
    upsert?: HackathonUpsertWithoutTeamsInput;
    connect?: HackathonWhereUniqueInput;
    update?: XOR<
      XOR<HackathonUpdateToOneWithWhereWithoutTeamsInput, HackathonUpdateWithoutTeamsInput>,
      HackathonUncheckedUpdateWithoutTeamsInput
    >;
  };

  export type TeamMemberUpdateManyWithoutTeamNestedInput = {
    create?:
      | XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput>
      | TeamMemberCreateWithoutTeamInput[]
      | TeamMemberUncheckedCreateWithoutTeamInput[];
    connectOrCreate?:
      | TeamMemberCreateOrConnectWithoutTeamInput
      | TeamMemberCreateOrConnectWithoutTeamInput[];
    upsert?:
      | TeamMemberUpsertWithWhereUniqueWithoutTeamInput
      | TeamMemberUpsertWithWhereUniqueWithoutTeamInput[];
    createMany?: TeamMemberCreateManyTeamInputEnvelope;
    set?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[];
    disconnect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[];
    delete?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[];
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[];
    update?:
      | TeamMemberUpdateWithWhereUniqueWithoutTeamInput
      | TeamMemberUpdateWithWhereUniqueWithoutTeamInput[];
    updateMany?:
      | TeamMemberUpdateManyWithWhereWithoutTeamInput
      | TeamMemberUpdateManyWithWhereWithoutTeamInput[];
    deleteMany?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[];
  };

  export type SubmissionUpdateManyWithoutTeamNestedInput = {
    create?:
      | XOR<SubmissionCreateWithoutTeamInput, SubmissionUncheckedCreateWithoutTeamInput>
      | SubmissionCreateWithoutTeamInput[]
      | SubmissionUncheckedCreateWithoutTeamInput[];
    connectOrCreate?:
      | SubmissionCreateOrConnectWithoutTeamInput
      | SubmissionCreateOrConnectWithoutTeamInput[];
    upsert?:
      | SubmissionUpsertWithWhereUniqueWithoutTeamInput
      | SubmissionUpsertWithWhereUniqueWithoutTeamInput[];
    createMany?: SubmissionCreateManyTeamInputEnvelope;
    set?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[];
    disconnect?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[];
    delete?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[];
    connect?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[];
    update?:
      | SubmissionUpdateWithWhereUniqueWithoutTeamInput
      | SubmissionUpdateWithWhereUniqueWithoutTeamInput[];
    updateMany?:
      | SubmissionUpdateManyWithWhereWithoutTeamInput
      | SubmissionUpdateManyWithWhereWithoutTeamInput[];
    deleteMany?: SubmissionScalarWhereInput | SubmissionScalarWhereInput[];
  };

  export type ChallengeSubmissionUpdateManyWithoutTeamNestedInput = {
    create?:
      | XOR<
          ChallengeSubmissionCreateWithoutTeamInput,
          ChallengeSubmissionUncheckedCreateWithoutTeamInput
        >
      | ChallengeSubmissionCreateWithoutTeamInput[]
      | ChallengeSubmissionUncheckedCreateWithoutTeamInput[];
    connectOrCreate?:
      | ChallengeSubmissionCreateOrConnectWithoutTeamInput
      | ChallengeSubmissionCreateOrConnectWithoutTeamInput[];
    upsert?:
      | ChallengeSubmissionUpsertWithWhereUniqueWithoutTeamInput
      | ChallengeSubmissionUpsertWithWhereUniqueWithoutTeamInput[];
    createMany?: ChallengeSubmissionCreateManyTeamInputEnvelope;
    set?: ChallengeSubmissionWhereUniqueInput | ChallengeSubmissionWhereUniqueInput[];
    disconnect?: ChallengeSubmissionWhereUniqueInput | ChallengeSubmissionWhereUniqueInput[];
    delete?: ChallengeSubmissionWhereUniqueInput | ChallengeSubmissionWhereUniqueInput[];
    connect?: ChallengeSubmissionWhereUniqueInput | ChallengeSubmissionWhereUniqueInput[];
    update?:
      | ChallengeSubmissionUpdateWithWhereUniqueWithoutTeamInput
      | ChallengeSubmissionUpdateWithWhereUniqueWithoutTeamInput[];
    updateMany?:
      | ChallengeSubmissionUpdateManyWithWhereWithoutTeamInput
      | ChallengeSubmissionUpdateManyWithWhereWithoutTeamInput[];
    deleteMany?: ChallengeSubmissionScalarWhereInput | ChallengeSubmissionScalarWhereInput[];
  };

  export type TeamMemberUncheckedUpdateManyWithoutTeamNestedInput = {
    create?:
      | XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput>
      | TeamMemberCreateWithoutTeamInput[]
      | TeamMemberUncheckedCreateWithoutTeamInput[];
    connectOrCreate?:
      | TeamMemberCreateOrConnectWithoutTeamInput
      | TeamMemberCreateOrConnectWithoutTeamInput[];
    upsert?:
      | TeamMemberUpsertWithWhereUniqueWithoutTeamInput
      | TeamMemberUpsertWithWhereUniqueWithoutTeamInput[];
    createMany?: TeamMemberCreateManyTeamInputEnvelope;
    set?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[];
    disconnect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[];
    delete?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[];
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[];
    update?:
      | TeamMemberUpdateWithWhereUniqueWithoutTeamInput
      | TeamMemberUpdateWithWhereUniqueWithoutTeamInput[];
    updateMany?:
      | TeamMemberUpdateManyWithWhereWithoutTeamInput
      | TeamMemberUpdateManyWithWhereWithoutTeamInput[];
    deleteMany?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[];
  };

  export type SubmissionUncheckedUpdateManyWithoutTeamNestedInput = {
    create?:
      | XOR<SubmissionCreateWithoutTeamInput, SubmissionUncheckedCreateWithoutTeamInput>
      | SubmissionCreateWithoutTeamInput[]
      | SubmissionUncheckedCreateWithoutTeamInput[];
    connectOrCreate?:
      | SubmissionCreateOrConnectWithoutTeamInput
      | SubmissionCreateOrConnectWithoutTeamInput[];
    upsert?:
      | SubmissionUpsertWithWhereUniqueWithoutTeamInput
      | SubmissionUpsertWithWhereUniqueWithoutTeamInput[];
    createMany?: SubmissionCreateManyTeamInputEnvelope;
    set?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[];
    disconnect?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[];
    delete?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[];
    connect?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[];
    update?:
      | SubmissionUpdateWithWhereUniqueWithoutTeamInput
      | SubmissionUpdateWithWhereUniqueWithoutTeamInput[];
    updateMany?:
      | SubmissionUpdateManyWithWhereWithoutTeamInput
      | SubmissionUpdateManyWithWhereWithoutTeamInput[];
    deleteMany?: SubmissionScalarWhereInput | SubmissionScalarWhereInput[];
  };

  export type ChallengeSubmissionUncheckedUpdateManyWithoutTeamNestedInput = {
    create?:
      | XOR<
          ChallengeSubmissionCreateWithoutTeamInput,
          ChallengeSubmissionUncheckedCreateWithoutTeamInput
        >
      | ChallengeSubmissionCreateWithoutTeamInput[]
      | ChallengeSubmissionUncheckedCreateWithoutTeamInput[];
    connectOrCreate?:
      | ChallengeSubmissionCreateOrConnectWithoutTeamInput
      | ChallengeSubmissionCreateOrConnectWithoutTeamInput[];
    upsert?:
      | ChallengeSubmissionUpsertWithWhereUniqueWithoutTeamInput
      | ChallengeSubmissionUpsertWithWhereUniqueWithoutTeamInput[];
    createMany?: ChallengeSubmissionCreateManyTeamInputEnvelope;
    set?: ChallengeSubmissionWhereUniqueInput | ChallengeSubmissionWhereUniqueInput[];
    disconnect?: ChallengeSubmissionWhereUniqueInput | ChallengeSubmissionWhereUniqueInput[];
    delete?: ChallengeSubmissionWhereUniqueInput | ChallengeSubmissionWhereUniqueInput[];
    connect?: ChallengeSubmissionWhereUniqueInput | ChallengeSubmissionWhereUniqueInput[];
    update?:
      | ChallengeSubmissionUpdateWithWhereUniqueWithoutTeamInput
      | ChallengeSubmissionUpdateWithWhereUniqueWithoutTeamInput[];
    updateMany?:
      | ChallengeSubmissionUpdateManyWithWhereWithoutTeamInput
      | ChallengeSubmissionUpdateManyWithWhereWithoutTeamInput[];
    deleteMany?: ChallengeSubmissionScalarWhereInput | ChallengeSubmissionScalarWhereInput[];
  };

  export type TeamCreateNestedOneWithoutMembersInput = {
    create?: XOR<TeamCreateWithoutMembersInput, TeamUncheckedCreateWithoutMembersInput>;
    connectOrCreate?: TeamCreateOrConnectWithoutMembersInput;
    connect?: TeamWhereUniqueInput;
  };

  export type UserCreateNestedOneWithoutTeamMembershipsInput = {
    create?: XOR<
      UserCreateWithoutTeamMembershipsInput,
      UserUncheckedCreateWithoutTeamMembershipsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutTeamMembershipsInput;
    connect?: UserWhereUniqueInput;
  };

  export type EnumTeamMemberRoleFieldUpdateOperationsInput = {
    set?: $Enums.TeamMemberRole;
  };

  export type TeamUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<TeamCreateWithoutMembersInput, TeamUncheckedCreateWithoutMembersInput>;
    connectOrCreate?: TeamCreateOrConnectWithoutMembersInput;
    upsert?: TeamUpsertWithoutMembersInput;
    connect?: TeamWhereUniqueInput;
    update?: XOR<
      XOR<TeamUpdateToOneWithWhereWithoutMembersInput, TeamUpdateWithoutMembersInput>,
      TeamUncheckedUpdateWithoutMembersInput
    >;
  };

  export type UserUpdateOneRequiredWithoutTeamMembershipsNestedInput = {
    create?: XOR<
      UserCreateWithoutTeamMembershipsInput,
      UserUncheckedCreateWithoutTeamMembershipsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutTeamMembershipsInput;
    upsert?: UserUpsertWithoutTeamMembershipsInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutTeamMembershipsInput,
        UserUpdateWithoutTeamMembershipsInput
      >,
      UserUncheckedUpdateWithoutTeamMembershipsInput
    >;
  };

  export type MentorCreateexpertiseInput = {
    set: string[];
  };

  export type UserCreateNestedOneWithoutMentorProfilesInput = {
    create?: XOR<
      UserCreateWithoutMentorProfilesInput,
      UserUncheckedCreateWithoutMentorProfilesInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutMentorProfilesInput;
    connect?: UserWhereUniqueInput;
  };

  export type HackathonCreateNestedOneWithoutMentorsInput = {
    create?: XOR<HackathonCreateWithoutMentorsInput, HackathonUncheckedCreateWithoutMentorsInput>;
    connectOrCreate?: HackathonCreateOrConnectWithoutMentorsInput;
    connect?: HackathonWhereUniqueInput;
  };

  export type MentorSessionCreateNestedManyWithoutMentorInput = {
    create?:
      | XOR<MentorSessionCreateWithoutMentorInput, MentorSessionUncheckedCreateWithoutMentorInput>
      | MentorSessionCreateWithoutMentorInput[]
      | MentorSessionUncheckedCreateWithoutMentorInput[];
    connectOrCreate?:
      | MentorSessionCreateOrConnectWithoutMentorInput
      | MentorSessionCreateOrConnectWithoutMentorInput[];
    createMany?: MentorSessionCreateManyMentorInputEnvelope;
    connect?: MentorSessionWhereUniqueInput | MentorSessionWhereUniqueInput[];
  };

  export type MentorSessionUncheckedCreateNestedManyWithoutMentorInput = {
    create?:
      | XOR<MentorSessionCreateWithoutMentorInput, MentorSessionUncheckedCreateWithoutMentorInput>
      | MentorSessionCreateWithoutMentorInput[]
      | MentorSessionUncheckedCreateWithoutMentorInput[];
    connectOrCreate?:
      | MentorSessionCreateOrConnectWithoutMentorInput
      | MentorSessionCreateOrConnectWithoutMentorInput[];
    createMany?: MentorSessionCreateManyMentorInputEnvelope;
    connect?: MentorSessionWhereUniqueInput | MentorSessionWhereUniqueInput[];
  };

  export type MentorUpdateexpertiseInput = {
    set?: string[];
    push?: string | string[];
  };

  export type UserUpdateOneRequiredWithoutMentorProfilesNestedInput = {
    create?: XOR<
      UserCreateWithoutMentorProfilesInput,
      UserUncheckedCreateWithoutMentorProfilesInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutMentorProfilesInput;
    upsert?: UserUpsertWithoutMentorProfilesInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<UserUpdateToOneWithWhereWithoutMentorProfilesInput, UserUpdateWithoutMentorProfilesInput>,
      UserUncheckedUpdateWithoutMentorProfilesInput
    >;
  };

  export type HackathonUpdateOneRequiredWithoutMentorsNestedInput = {
    create?: XOR<HackathonCreateWithoutMentorsInput, HackathonUncheckedCreateWithoutMentorsInput>;
    connectOrCreate?: HackathonCreateOrConnectWithoutMentorsInput;
    upsert?: HackathonUpsertWithoutMentorsInput;
    connect?: HackathonWhereUniqueInput;
    update?: XOR<
      XOR<HackathonUpdateToOneWithWhereWithoutMentorsInput, HackathonUpdateWithoutMentorsInput>,
      HackathonUncheckedUpdateWithoutMentorsInput
    >;
  };

  export type MentorSessionUpdateManyWithoutMentorNestedInput = {
    create?:
      | XOR<MentorSessionCreateWithoutMentorInput, MentorSessionUncheckedCreateWithoutMentorInput>
      | MentorSessionCreateWithoutMentorInput[]
      | MentorSessionUncheckedCreateWithoutMentorInput[];
    connectOrCreate?:
      | MentorSessionCreateOrConnectWithoutMentorInput
      | MentorSessionCreateOrConnectWithoutMentorInput[];
    upsert?:
      | MentorSessionUpsertWithWhereUniqueWithoutMentorInput
      | MentorSessionUpsertWithWhereUniqueWithoutMentorInput[];
    createMany?: MentorSessionCreateManyMentorInputEnvelope;
    set?: MentorSessionWhereUniqueInput | MentorSessionWhereUniqueInput[];
    disconnect?: MentorSessionWhereUniqueInput | MentorSessionWhereUniqueInput[];
    delete?: MentorSessionWhereUniqueInput | MentorSessionWhereUniqueInput[];
    connect?: MentorSessionWhereUniqueInput | MentorSessionWhereUniqueInput[];
    update?:
      | MentorSessionUpdateWithWhereUniqueWithoutMentorInput
      | MentorSessionUpdateWithWhereUniqueWithoutMentorInput[];
    updateMany?:
      | MentorSessionUpdateManyWithWhereWithoutMentorInput
      | MentorSessionUpdateManyWithWhereWithoutMentorInput[];
    deleteMany?: MentorSessionScalarWhereInput | MentorSessionScalarWhereInput[];
  };

  export type MentorSessionUncheckedUpdateManyWithoutMentorNestedInput = {
    create?:
      | XOR<MentorSessionCreateWithoutMentorInput, MentorSessionUncheckedCreateWithoutMentorInput>
      | MentorSessionCreateWithoutMentorInput[]
      | MentorSessionUncheckedCreateWithoutMentorInput[];
    connectOrCreate?:
      | MentorSessionCreateOrConnectWithoutMentorInput
      | MentorSessionCreateOrConnectWithoutMentorInput[];
    upsert?:
      | MentorSessionUpsertWithWhereUniqueWithoutMentorInput
      | MentorSessionUpsertWithWhereUniqueWithoutMentorInput[];
    createMany?: MentorSessionCreateManyMentorInputEnvelope;
    set?: MentorSessionWhereUniqueInput | MentorSessionWhereUniqueInput[];
    disconnect?: MentorSessionWhereUniqueInput | MentorSessionWhereUniqueInput[];
    delete?: MentorSessionWhereUniqueInput | MentorSessionWhereUniqueInput[];
    connect?: MentorSessionWhereUniqueInput | MentorSessionWhereUniqueInput[];
    update?:
      | MentorSessionUpdateWithWhereUniqueWithoutMentorInput
      | MentorSessionUpdateWithWhereUniqueWithoutMentorInput[];
    updateMany?:
      | MentorSessionUpdateManyWithWhereWithoutMentorInput
      | MentorSessionUpdateManyWithWhereWithoutMentorInput[];
    deleteMany?: MentorSessionScalarWhereInput | MentorSessionScalarWhereInput[];
  };

  export type MentorCreateNestedOneWithoutSessionsInput = {
    create?: XOR<MentorCreateWithoutSessionsInput, MentorUncheckedCreateWithoutSessionsInput>;
    connectOrCreate?: MentorCreateOrConnectWithoutSessionsInput;
    connect?: MentorWhereUniqueInput;
  };

  export type MentorUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<MentorCreateWithoutSessionsInput, MentorUncheckedCreateWithoutSessionsInput>;
    connectOrCreate?: MentorCreateOrConnectWithoutSessionsInput;
    upsert?: MentorUpsertWithoutSessionsInput;
    connect?: MentorWhereUniqueInput;
    update?: XOR<
      XOR<MentorUpdateToOneWithWhereWithoutSessionsInput, MentorUpdateWithoutSessionsInput>,
      MentorUncheckedUpdateWithoutSessionsInput
    >;
  };

  export type UserCreateNestedOneWithoutJudgeAssignmentsInput = {
    create?: XOR<
      UserCreateWithoutJudgeAssignmentsInput,
      UserUncheckedCreateWithoutJudgeAssignmentsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutJudgeAssignmentsInput;
    connect?: UserWhereUniqueInput;
  };

  export type HackathonCreateNestedOneWithoutJudgesInput = {
    create?: XOR<HackathonCreateWithoutJudgesInput, HackathonUncheckedCreateWithoutJudgesInput>;
    connectOrCreate?: HackathonCreateOrConnectWithoutJudgesInput;
    connect?: HackathonWhereUniqueInput;
  };

  export type ScoreCreateNestedManyWithoutJudgeInput = {
    create?:
      | XOR<ScoreCreateWithoutJudgeInput, ScoreUncheckedCreateWithoutJudgeInput>
      | ScoreCreateWithoutJudgeInput[]
      | ScoreUncheckedCreateWithoutJudgeInput[];
    connectOrCreate?:
      | ScoreCreateOrConnectWithoutJudgeInput
      | ScoreCreateOrConnectWithoutJudgeInput[];
    createMany?: ScoreCreateManyJudgeInputEnvelope;
    connect?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[];
  };

  export type ScoreUncheckedCreateNestedManyWithoutJudgeInput = {
    create?:
      | XOR<ScoreCreateWithoutJudgeInput, ScoreUncheckedCreateWithoutJudgeInput>
      | ScoreCreateWithoutJudgeInput[]
      | ScoreUncheckedCreateWithoutJudgeInput[];
    connectOrCreate?:
      | ScoreCreateOrConnectWithoutJudgeInput
      | ScoreCreateOrConnectWithoutJudgeInput[];
    createMany?: ScoreCreateManyJudgeInputEnvelope;
    connect?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[];
  };

  export type UserUpdateOneRequiredWithoutJudgeAssignmentsNestedInput = {
    create?: XOR<
      UserCreateWithoutJudgeAssignmentsInput,
      UserUncheckedCreateWithoutJudgeAssignmentsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutJudgeAssignmentsInput;
    upsert?: UserUpsertWithoutJudgeAssignmentsInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutJudgeAssignmentsInput,
        UserUpdateWithoutJudgeAssignmentsInput
      >,
      UserUncheckedUpdateWithoutJudgeAssignmentsInput
    >;
  };

  export type HackathonUpdateOneRequiredWithoutJudgesNestedInput = {
    create?: XOR<HackathonCreateWithoutJudgesInput, HackathonUncheckedCreateWithoutJudgesInput>;
    connectOrCreate?: HackathonCreateOrConnectWithoutJudgesInput;
    upsert?: HackathonUpsertWithoutJudgesInput;
    connect?: HackathonWhereUniqueInput;
    update?: XOR<
      XOR<HackathonUpdateToOneWithWhereWithoutJudgesInput, HackathonUpdateWithoutJudgesInput>,
      HackathonUncheckedUpdateWithoutJudgesInput
    >;
  };

  export type ScoreUpdateManyWithoutJudgeNestedInput = {
    create?:
      | XOR<ScoreCreateWithoutJudgeInput, ScoreUncheckedCreateWithoutJudgeInput>
      | ScoreCreateWithoutJudgeInput[]
      | ScoreUncheckedCreateWithoutJudgeInput[];
    connectOrCreate?:
      | ScoreCreateOrConnectWithoutJudgeInput
      | ScoreCreateOrConnectWithoutJudgeInput[];
    upsert?:
      | ScoreUpsertWithWhereUniqueWithoutJudgeInput
      | ScoreUpsertWithWhereUniqueWithoutJudgeInput[];
    createMany?: ScoreCreateManyJudgeInputEnvelope;
    set?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[];
    disconnect?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[];
    delete?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[];
    connect?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[];
    update?:
      | ScoreUpdateWithWhereUniqueWithoutJudgeInput
      | ScoreUpdateWithWhereUniqueWithoutJudgeInput[];
    updateMany?:
      | ScoreUpdateManyWithWhereWithoutJudgeInput
      | ScoreUpdateManyWithWhereWithoutJudgeInput[];
    deleteMany?: ScoreScalarWhereInput | ScoreScalarWhereInput[];
  };

  export type ScoreUncheckedUpdateManyWithoutJudgeNestedInput = {
    create?:
      | XOR<ScoreCreateWithoutJudgeInput, ScoreUncheckedCreateWithoutJudgeInput>
      | ScoreCreateWithoutJudgeInput[]
      | ScoreUncheckedCreateWithoutJudgeInput[];
    connectOrCreate?:
      | ScoreCreateOrConnectWithoutJudgeInput
      | ScoreCreateOrConnectWithoutJudgeInput[];
    upsert?:
      | ScoreUpsertWithWhereUniqueWithoutJudgeInput
      | ScoreUpsertWithWhereUniqueWithoutJudgeInput[];
    createMany?: ScoreCreateManyJudgeInputEnvelope;
    set?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[];
    disconnect?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[];
    delete?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[];
    connect?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[];
    update?:
      | ScoreUpdateWithWhereUniqueWithoutJudgeInput
      | ScoreUpdateWithWhereUniqueWithoutJudgeInput[];
    updateMany?:
      | ScoreUpdateManyWithWhereWithoutJudgeInput
      | ScoreUpdateManyWithWhereWithoutJudgeInput[];
    deleteMany?: ScoreScalarWhereInput | ScoreScalarWhereInput[];
  };

  export type HackathonCreateNestedOneWithoutCriteriaInput = {
    create?: XOR<HackathonCreateWithoutCriteriaInput, HackathonUncheckedCreateWithoutCriteriaInput>;
    connectOrCreate?: HackathonCreateOrConnectWithoutCriteriaInput;
    connect?: HackathonWhereUniqueInput;
  };

  export type ScoreCreateNestedManyWithoutCriterionInput = {
    create?:
      | XOR<ScoreCreateWithoutCriterionInput, ScoreUncheckedCreateWithoutCriterionInput>
      | ScoreCreateWithoutCriterionInput[]
      | ScoreUncheckedCreateWithoutCriterionInput[];
    connectOrCreate?:
      | ScoreCreateOrConnectWithoutCriterionInput
      | ScoreCreateOrConnectWithoutCriterionInput[];
    createMany?: ScoreCreateManyCriterionInputEnvelope;
    connect?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[];
  };

  export type ScoreUncheckedCreateNestedManyWithoutCriterionInput = {
    create?:
      | XOR<ScoreCreateWithoutCriterionInput, ScoreUncheckedCreateWithoutCriterionInput>
      | ScoreCreateWithoutCriterionInput[]
      | ScoreUncheckedCreateWithoutCriterionInput[];
    connectOrCreate?:
      | ScoreCreateOrConnectWithoutCriterionInput
      | ScoreCreateOrConnectWithoutCriterionInput[];
    createMany?: ScoreCreateManyCriterionInputEnvelope;
    connect?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[];
  };

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string;
    increment?: Decimal | DecimalJsLike | number | string;
    decrement?: Decimal | DecimalJsLike | number | string;
    multiply?: Decimal | DecimalJsLike | number | string;
    divide?: Decimal | DecimalJsLike | number | string;
  };

  export type HackathonUpdateOneRequiredWithoutCriteriaNestedInput = {
    create?: XOR<HackathonCreateWithoutCriteriaInput, HackathonUncheckedCreateWithoutCriteriaInput>;
    connectOrCreate?: HackathonCreateOrConnectWithoutCriteriaInput;
    upsert?: HackathonUpsertWithoutCriteriaInput;
    connect?: HackathonWhereUniqueInput;
    update?: XOR<
      XOR<HackathonUpdateToOneWithWhereWithoutCriteriaInput, HackathonUpdateWithoutCriteriaInput>,
      HackathonUncheckedUpdateWithoutCriteriaInput
    >;
  };

  export type ScoreUpdateManyWithoutCriterionNestedInput = {
    create?:
      | XOR<ScoreCreateWithoutCriterionInput, ScoreUncheckedCreateWithoutCriterionInput>
      | ScoreCreateWithoutCriterionInput[]
      | ScoreUncheckedCreateWithoutCriterionInput[];
    connectOrCreate?:
      | ScoreCreateOrConnectWithoutCriterionInput
      | ScoreCreateOrConnectWithoutCriterionInput[];
    upsert?:
      | ScoreUpsertWithWhereUniqueWithoutCriterionInput
      | ScoreUpsertWithWhereUniqueWithoutCriterionInput[];
    createMany?: ScoreCreateManyCriterionInputEnvelope;
    set?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[];
    disconnect?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[];
    delete?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[];
    connect?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[];
    update?:
      | ScoreUpdateWithWhereUniqueWithoutCriterionInput
      | ScoreUpdateWithWhereUniqueWithoutCriterionInput[];
    updateMany?:
      | ScoreUpdateManyWithWhereWithoutCriterionInput
      | ScoreUpdateManyWithWhereWithoutCriterionInput[];
    deleteMany?: ScoreScalarWhereInput | ScoreScalarWhereInput[];
  };

  export type ScoreUncheckedUpdateManyWithoutCriterionNestedInput = {
    create?:
      | XOR<ScoreCreateWithoutCriterionInput, ScoreUncheckedCreateWithoutCriterionInput>
      | ScoreCreateWithoutCriterionInput[]
      | ScoreUncheckedCreateWithoutCriterionInput[];
    connectOrCreate?:
      | ScoreCreateOrConnectWithoutCriterionInput
      | ScoreCreateOrConnectWithoutCriterionInput[];
    upsert?:
      | ScoreUpsertWithWhereUniqueWithoutCriterionInput
      | ScoreUpsertWithWhereUniqueWithoutCriterionInput[];
    createMany?: ScoreCreateManyCriterionInputEnvelope;
    set?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[];
    disconnect?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[];
    delete?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[];
    connect?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[];
    update?:
      | ScoreUpdateWithWhereUniqueWithoutCriterionInput
      | ScoreUpdateWithWhereUniqueWithoutCriterionInput[];
    updateMany?:
      | ScoreUpdateManyWithWhereWithoutCriterionInput
      | ScoreUpdateManyWithWhereWithoutCriterionInput[];
    deleteMany?: ScoreScalarWhereInput | ScoreScalarWhereInput[];
  };

  export type SubmissionCreatefilesInput = {
    set: string[];
  };

  export type HackathonCreateNestedOneWithoutSubmissionsInput = {
    create?: XOR<
      HackathonCreateWithoutSubmissionsInput,
      HackathonUncheckedCreateWithoutSubmissionsInput
    >;
    connectOrCreate?: HackathonCreateOrConnectWithoutSubmissionsInput;
    connect?: HackathonWhereUniqueInput;
  };

  export type TeamCreateNestedOneWithoutSubmissionsInput = {
    create?: XOR<TeamCreateWithoutSubmissionsInput, TeamUncheckedCreateWithoutSubmissionsInput>;
    connectOrCreate?: TeamCreateOrConnectWithoutSubmissionsInput;
    connect?: TeamWhereUniqueInput;
  };

  export type TrackCreateNestedOneWithoutSubmissionsInput = {
    create?: XOR<TrackCreateWithoutSubmissionsInput, TrackUncheckedCreateWithoutSubmissionsInput>;
    connectOrCreate?: TrackCreateOrConnectWithoutSubmissionsInput;
    connect?: TrackWhereUniqueInput;
  };

  export type ScoreCreateNestedManyWithoutSubmissionInput = {
    create?:
      | XOR<ScoreCreateWithoutSubmissionInput, ScoreUncheckedCreateWithoutSubmissionInput>
      | ScoreCreateWithoutSubmissionInput[]
      | ScoreUncheckedCreateWithoutSubmissionInput[];
    connectOrCreate?:
      | ScoreCreateOrConnectWithoutSubmissionInput
      | ScoreCreateOrConnectWithoutSubmissionInput[];
    createMany?: ScoreCreateManySubmissionInputEnvelope;
    connect?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[];
  };

  export type ScoreUncheckedCreateNestedManyWithoutSubmissionInput = {
    create?:
      | XOR<ScoreCreateWithoutSubmissionInput, ScoreUncheckedCreateWithoutSubmissionInput>
      | ScoreCreateWithoutSubmissionInput[]
      | ScoreUncheckedCreateWithoutSubmissionInput[];
    connectOrCreate?:
      | ScoreCreateOrConnectWithoutSubmissionInput
      | ScoreCreateOrConnectWithoutSubmissionInput[];
    createMany?: ScoreCreateManySubmissionInputEnvelope;
    connect?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[];
  };

  export type SubmissionUpdatefilesInput = {
    set?: string[];
    push?: string | string[];
  };

  export type EnumSubmissionStatusFieldUpdateOperationsInput = {
    set?: $Enums.SubmissionStatus;
  };

  export type HackathonUpdateOneRequiredWithoutSubmissionsNestedInput = {
    create?: XOR<
      HackathonCreateWithoutSubmissionsInput,
      HackathonUncheckedCreateWithoutSubmissionsInput
    >;
    connectOrCreate?: HackathonCreateOrConnectWithoutSubmissionsInput;
    upsert?: HackathonUpsertWithoutSubmissionsInput;
    connect?: HackathonWhereUniqueInput;
    update?: XOR<
      XOR<
        HackathonUpdateToOneWithWhereWithoutSubmissionsInput,
        HackathonUpdateWithoutSubmissionsInput
      >,
      HackathonUncheckedUpdateWithoutSubmissionsInput
    >;
  };

  export type TeamUpdateOneRequiredWithoutSubmissionsNestedInput = {
    create?: XOR<TeamCreateWithoutSubmissionsInput, TeamUncheckedCreateWithoutSubmissionsInput>;
    connectOrCreate?: TeamCreateOrConnectWithoutSubmissionsInput;
    upsert?: TeamUpsertWithoutSubmissionsInput;
    connect?: TeamWhereUniqueInput;
    update?: XOR<
      XOR<TeamUpdateToOneWithWhereWithoutSubmissionsInput, TeamUpdateWithoutSubmissionsInput>,
      TeamUncheckedUpdateWithoutSubmissionsInput
    >;
  };

  export type TrackUpdateOneWithoutSubmissionsNestedInput = {
    create?: XOR<TrackCreateWithoutSubmissionsInput, TrackUncheckedCreateWithoutSubmissionsInput>;
    connectOrCreate?: TrackCreateOrConnectWithoutSubmissionsInput;
    upsert?: TrackUpsertWithoutSubmissionsInput;
    disconnect?: TrackWhereInput | boolean;
    delete?: TrackWhereInput | boolean;
    connect?: TrackWhereUniqueInput;
    update?: XOR<
      XOR<TrackUpdateToOneWithWhereWithoutSubmissionsInput, TrackUpdateWithoutSubmissionsInput>,
      TrackUncheckedUpdateWithoutSubmissionsInput
    >;
  };

  export type ScoreUpdateManyWithoutSubmissionNestedInput = {
    create?:
      | XOR<ScoreCreateWithoutSubmissionInput, ScoreUncheckedCreateWithoutSubmissionInput>
      | ScoreCreateWithoutSubmissionInput[]
      | ScoreUncheckedCreateWithoutSubmissionInput[];
    connectOrCreate?:
      | ScoreCreateOrConnectWithoutSubmissionInput
      | ScoreCreateOrConnectWithoutSubmissionInput[];
    upsert?:
      | ScoreUpsertWithWhereUniqueWithoutSubmissionInput
      | ScoreUpsertWithWhereUniqueWithoutSubmissionInput[];
    createMany?: ScoreCreateManySubmissionInputEnvelope;
    set?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[];
    disconnect?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[];
    delete?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[];
    connect?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[];
    update?:
      | ScoreUpdateWithWhereUniqueWithoutSubmissionInput
      | ScoreUpdateWithWhereUniqueWithoutSubmissionInput[];
    updateMany?:
      | ScoreUpdateManyWithWhereWithoutSubmissionInput
      | ScoreUpdateManyWithWhereWithoutSubmissionInput[];
    deleteMany?: ScoreScalarWhereInput | ScoreScalarWhereInput[];
  };

  export type ScoreUncheckedUpdateManyWithoutSubmissionNestedInput = {
    create?:
      | XOR<ScoreCreateWithoutSubmissionInput, ScoreUncheckedCreateWithoutSubmissionInput>
      | ScoreCreateWithoutSubmissionInput[]
      | ScoreUncheckedCreateWithoutSubmissionInput[];
    connectOrCreate?:
      | ScoreCreateOrConnectWithoutSubmissionInput
      | ScoreCreateOrConnectWithoutSubmissionInput[];
    upsert?:
      | ScoreUpsertWithWhereUniqueWithoutSubmissionInput
      | ScoreUpsertWithWhereUniqueWithoutSubmissionInput[];
    createMany?: ScoreCreateManySubmissionInputEnvelope;
    set?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[];
    disconnect?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[];
    delete?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[];
    connect?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[];
    update?:
      | ScoreUpdateWithWhereUniqueWithoutSubmissionInput
      | ScoreUpdateWithWhereUniqueWithoutSubmissionInput[];
    updateMany?:
      | ScoreUpdateManyWithWhereWithoutSubmissionInput
      | ScoreUpdateManyWithWhereWithoutSubmissionInput[];
    deleteMany?: ScoreScalarWhereInput | ScoreScalarWhereInput[];
  };

  export type SubmissionCreateNestedOneWithoutScoresInput = {
    create?: XOR<SubmissionCreateWithoutScoresInput, SubmissionUncheckedCreateWithoutScoresInput>;
    connectOrCreate?: SubmissionCreateOrConnectWithoutScoresInput;
    connect?: SubmissionWhereUniqueInput;
  };

  export type JudgeCreateNestedOneWithoutScoresInput = {
    create?: XOR<JudgeCreateWithoutScoresInput, JudgeUncheckedCreateWithoutScoresInput>;
    connectOrCreate?: JudgeCreateOrConnectWithoutScoresInput;
    connect?: JudgeWhereUniqueInput;
  };

  export type CriteriaCreateNestedOneWithoutScoresInput = {
    create?: XOR<CriteriaCreateWithoutScoresInput, CriteriaUncheckedCreateWithoutScoresInput>;
    connectOrCreate?: CriteriaCreateOrConnectWithoutScoresInput;
    connect?: CriteriaWhereUniqueInput;
  };

  export type SubmissionUpdateOneRequiredWithoutScoresNestedInput = {
    create?: XOR<SubmissionCreateWithoutScoresInput, SubmissionUncheckedCreateWithoutScoresInput>;
    connectOrCreate?: SubmissionCreateOrConnectWithoutScoresInput;
    upsert?: SubmissionUpsertWithoutScoresInput;
    connect?: SubmissionWhereUniqueInput;
    update?: XOR<
      XOR<SubmissionUpdateToOneWithWhereWithoutScoresInput, SubmissionUpdateWithoutScoresInput>,
      SubmissionUncheckedUpdateWithoutScoresInput
    >;
  };

  export type JudgeUpdateOneRequiredWithoutScoresNestedInput = {
    create?: XOR<JudgeCreateWithoutScoresInput, JudgeUncheckedCreateWithoutScoresInput>;
    connectOrCreate?: JudgeCreateOrConnectWithoutScoresInput;
    upsert?: JudgeUpsertWithoutScoresInput;
    connect?: JudgeWhereUniqueInput;
    update?: XOR<
      XOR<JudgeUpdateToOneWithWhereWithoutScoresInput, JudgeUpdateWithoutScoresInput>,
      JudgeUncheckedUpdateWithoutScoresInput
    >;
  };

  export type CriteriaUpdateOneRequiredWithoutScoresNestedInput = {
    create?: XOR<CriteriaCreateWithoutScoresInput, CriteriaUncheckedCreateWithoutScoresInput>;
    connectOrCreate?: CriteriaCreateOrConnectWithoutScoresInput;
    upsert?: CriteriaUpsertWithoutScoresInput;
    connect?: CriteriaWhereUniqueInput;
    update?: XOR<
      XOR<CriteriaUpdateToOneWithWhereWithoutScoresInput, CriteriaUpdateWithoutScoresInput>,
      CriteriaUncheckedUpdateWithoutScoresInput
    >;
  };

  export type ChallengeCreatecategoriesInput = {
    set: string[];
  };

  export type ChallengeCreateskillsInput = {
    set: string[];
  };

  export type ChallengeCreateattachmentsInput = {
    set: string[];
  };

  export type UserCreateNestedOneWithoutOwnedChallengesInput = {
    create?: XOR<
      UserCreateWithoutOwnedChallengesInput,
      UserUncheckedCreateWithoutOwnedChallengesInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutOwnedChallengesInput;
    connect?: UserWhereUniqueInput;
  };

  export type ChallengeSubmissionCreateNestedManyWithoutChallengeInput = {
    create?:
      | XOR<
          ChallengeSubmissionCreateWithoutChallengeInput,
          ChallengeSubmissionUncheckedCreateWithoutChallengeInput
        >
      | ChallengeSubmissionCreateWithoutChallengeInput[]
      | ChallengeSubmissionUncheckedCreateWithoutChallengeInput[];
    connectOrCreate?:
      | ChallengeSubmissionCreateOrConnectWithoutChallengeInput
      | ChallengeSubmissionCreateOrConnectWithoutChallengeInput[];
    createMany?: ChallengeSubmissionCreateManyChallengeInputEnvelope;
    connect?: ChallengeSubmissionWhereUniqueInput | ChallengeSubmissionWhereUniqueInput[];
  };

  export type ChallengeSubmissionUncheckedCreateNestedManyWithoutChallengeInput = {
    create?:
      | XOR<
          ChallengeSubmissionCreateWithoutChallengeInput,
          ChallengeSubmissionUncheckedCreateWithoutChallengeInput
        >
      | ChallengeSubmissionCreateWithoutChallengeInput[]
      | ChallengeSubmissionUncheckedCreateWithoutChallengeInput[];
    connectOrCreate?:
      | ChallengeSubmissionCreateOrConnectWithoutChallengeInput
      | ChallengeSubmissionCreateOrConnectWithoutChallengeInput[];
    createMany?: ChallengeSubmissionCreateManyChallengeInputEnvelope;
    connect?: ChallengeSubmissionWhereUniqueInput | ChallengeSubmissionWhereUniqueInput[];
  };

  export type NullableEnumRewardTypeFieldUpdateOperationsInput = {
    set?: $Enums.RewardType | null;
  };

  export type ChallengeUpdatecategoriesInput = {
    set?: string[];
    push?: string | string[];
  };

  export type ChallengeUpdateskillsInput = {
    set?: string[];
    push?: string | string[];
  };

  export type ChallengeUpdateattachmentsInput = {
    set?: string[];
    push?: string | string[];
  };

  export type EnumChallengeStatusFieldUpdateOperationsInput = {
    set?: $Enums.ChallengeStatus;
  };

  export type EnumChallengeVisibilityFieldUpdateOperationsInput = {
    set?: $Enums.ChallengeVisibility;
  };

  export type UserUpdateOneRequiredWithoutOwnedChallengesNestedInput = {
    create?: XOR<
      UserCreateWithoutOwnedChallengesInput,
      UserUncheckedCreateWithoutOwnedChallengesInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutOwnedChallengesInput;
    upsert?: UserUpsertWithoutOwnedChallengesInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutOwnedChallengesInput,
        UserUpdateWithoutOwnedChallengesInput
      >,
      UserUncheckedUpdateWithoutOwnedChallengesInput
    >;
  };

  export type ChallengeSubmissionUpdateManyWithoutChallengeNestedInput = {
    create?:
      | XOR<
          ChallengeSubmissionCreateWithoutChallengeInput,
          ChallengeSubmissionUncheckedCreateWithoutChallengeInput
        >
      | ChallengeSubmissionCreateWithoutChallengeInput[]
      | ChallengeSubmissionUncheckedCreateWithoutChallengeInput[];
    connectOrCreate?:
      | ChallengeSubmissionCreateOrConnectWithoutChallengeInput
      | ChallengeSubmissionCreateOrConnectWithoutChallengeInput[];
    upsert?:
      | ChallengeSubmissionUpsertWithWhereUniqueWithoutChallengeInput
      | ChallengeSubmissionUpsertWithWhereUniqueWithoutChallengeInput[];
    createMany?: ChallengeSubmissionCreateManyChallengeInputEnvelope;
    set?: ChallengeSubmissionWhereUniqueInput | ChallengeSubmissionWhereUniqueInput[];
    disconnect?: ChallengeSubmissionWhereUniqueInput | ChallengeSubmissionWhereUniqueInput[];
    delete?: ChallengeSubmissionWhereUniqueInput | ChallengeSubmissionWhereUniqueInput[];
    connect?: ChallengeSubmissionWhereUniqueInput | ChallengeSubmissionWhereUniqueInput[];
    update?:
      | ChallengeSubmissionUpdateWithWhereUniqueWithoutChallengeInput
      | ChallengeSubmissionUpdateWithWhereUniqueWithoutChallengeInput[];
    updateMany?:
      | ChallengeSubmissionUpdateManyWithWhereWithoutChallengeInput
      | ChallengeSubmissionUpdateManyWithWhereWithoutChallengeInput[];
    deleteMany?: ChallengeSubmissionScalarWhereInput | ChallengeSubmissionScalarWhereInput[];
  };

  export type ChallengeSubmissionUncheckedUpdateManyWithoutChallengeNestedInput = {
    create?:
      | XOR<
          ChallengeSubmissionCreateWithoutChallengeInput,
          ChallengeSubmissionUncheckedCreateWithoutChallengeInput
        >
      | ChallengeSubmissionCreateWithoutChallengeInput[]
      | ChallengeSubmissionUncheckedCreateWithoutChallengeInput[];
    connectOrCreate?:
      | ChallengeSubmissionCreateOrConnectWithoutChallengeInput
      | ChallengeSubmissionCreateOrConnectWithoutChallengeInput[];
    upsert?:
      | ChallengeSubmissionUpsertWithWhereUniqueWithoutChallengeInput
      | ChallengeSubmissionUpsertWithWhereUniqueWithoutChallengeInput[];
    createMany?: ChallengeSubmissionCreateManyChallengeInputEnvelope;
    set?: ChallengeSubmissionWhereUniqueInput | ChallengeSubmissionWhereUniqueInput[];
    disconnect?: ChallengeSubmissionWhereUniqueInput | ChallengeSubmissionWhereUniqueInput[];
    delete?: ChallengeSubmissionWhereUniqueInput | ChallengeSubmissionWhereUniqueInput[];
    connect?: ChallengeSubmissionWhereUniqueInput | ChallengeSubmissionWhereUniqueInput[];
    update?:
      | ChallengeSubmissionUpdateWithWhereUniqueWithoutChallengeInput
      | ChallengeSubmissionUpdateWithWhereUniqueWithoutChallengeInput[];
    updateMany?:
      | ChallengeSubmissionUpdateManyWithWhereWithoutChallengeInput
      | ChallengeSubmissionUpdateManyWithWhereWithoutChallengeInput[];
    deleteMany?: ChallengeSubmissionScalarWhereInput | ChallengeSubmissionScalarWhereInput[];
  };

  export type ChallengeSubmissionCreatefilesInput = {
    set: string[];
  };

  export type ChallengeCreateNestedOneWithoutSubmissionsInput = {
    create?: XOR<
      ChallengeCreateWithoutSubmissionsInput,
      ChallengeUncheckedCreateWithoutSubmissionsInput
    >;
    connectOrCreate?: ChallengeCreateOrConnectWithoutSubmissionsInput;
    connect?: ChallengeWhereUniqueInput;
  };

  export type UserCreateNestedOneWithoutChallengeSubmissionsInput = {
    create?: XOR<
      UserCreateWithoutChallengeSubmissionsInput,
      UserUncheckedCreateWithoutChallengeSubmissionsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutChallengeSubmissionsInput;
    connect?: UserWhereUniqueInput;
  };

  export type TeamCreateNestedOneWithoutChallengeSubmissionsInput = {
    create?: XOR<
      TeamCreateWithoutChallengeSubmissionsInput,
      TeamUncheckedCreateWithoutChallengeSubmissionsInput
    >;
    connectOrCreate?: TeamCreateOrConnectWithoutChallengeSubmissionsInput;
    connect?: TeamWhereUniqueInput;
  };

  export type ChallengeSubmissionUpdatefilesInput = {
    set?: string[];
    push?: string | string[];
  };

  export type EnumChallengeSubmissionStatusFieldUpdateOperationsInput = {
    set?: $Enums.ChallengeSubmissionStatus;
  };

  export type ChallengeUpdateOneRequiredWithoutSubmissionsNestedInput = {
    create?: XOR<
      ChallengeCreateWithoutSubmissionsInput,
      ChallengeUncheckedCreateWithoutSubmissionsInput
    >;
    connectOrCreate?: ChallengeCreateOrConnectWithoutSubmissionsInput;
    upsert?: ChallengeUpsertWithoutSubmissionsInput;
    connect?: ChallengeWhereUniqueInput;
    update?: XOR<
      XOR<
        ChallengeUpdateToOneWithWhereWithoutSubmissionsInput,
        ChallengeUpdateWithoutSubmissionsInput
      >,
      ChallengeUncheckedUpdateWithoutSubmissionsInput
    >;
  };

  export type UserUpdateOneWithoutChallengeSubmissionsNestedInput = {
    create?: XOR<
      UserCreateWithoutChallengeSubmissionsInput,
      UserUncheckedCreateWithoutChallengeSubmissionsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutChallengeSubmissionsInput;
    upsert?: UserUpsertWithoutChallengeSubmissionsInput;
    disconnect?: UserWhereInput | boolean;
    delete?: UserWhereInput | boolean;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutChallengeSubmissionsInput,
        UserUpdateWithoutChallengeSubmissionsInput
      >,
      UserUncheckedUpdateWithoutChallengeSubmissionsInput
    >;
  };

  export type TeamUpdateOneWithoutChallengeSubmissionsNestedInput = {
    create?: XOR<
      TeamCreateWithoutChallengeSubmissionsInput,
      TeamUncheckedCreateWithoutChallengeSubmissionsInput
    >;
    connectOrCreate?: TeamCreateOrConnectWithoutChallengeSubmissionsInput;
    upsert?: TeamUpsertWithoutChallengeSubmissionsInput;
    disconnect?: TeamWhereInput | boolean;
    delete?: TeamWhereInput | boolean;
    connect?: TeamWhereUniqueInput;
    update?: XOR<
      XOR<
        TeamUpdateToOneWithWhereWithoutChallengeSubmissionsInput,
        TeamUpdateWithoutChallengeSubmissionsInput
      >,
      TeamUncheckedUpdateWithoutChallengeSubmissionsInput
    >;
  };

  export type HackathonCreateNestedOneWithoutAnnouncementsInput = {
    create?: XOR<
      HackathonCreateWithoutAnnouncementsInput,
      HackathonUncheckedCreateWithoutAnnouncementsInput
    >;
    connectOrCreate?: HackathonCreateOrConnectWithoutAnnouncementsInput;
    connect?: HackathonWhereUniqueInput;
  };

  export type EnumAnnouncementScopeFieldUpdateOperationsInput = {
    set?: $Enums.AnnouncementScope;
  };

  export type HackathonUpdateOneWithoutAnnouncementsNestedInput = {
    create?: XOR<
      HackathonCreateWithoutAnnouncementsInput,
      HackathonUncheckedCreateWithoutAnnouncementsInput
    >;
    connectOrCreate?: HackathonCreateOrConnectWithoutAnnouncementsInput;
    upsert?: HackathonUpsertWithoutAnnouncementsInput;
    disconnect?: HackathonWhereInput | boolean;
    delete?: HackathonWhereInput | boolean;
    connect?: HackathonWhereUniqueInput;
    update?: XOR<
      XOR<
        HackathonUpdateToOneWithWhereWithoutAnnouncementsInput,
        HackathonUpdateWithoutAnnouncementsInput
      >,
      HackathonUncheckedUpdateWithoutAnnouncementsInput
    >;
  };

  export type CommentCreateNestedManyWithoutThreadInput = {
    create?:
      | XOR<CommentCreateWithoutThreadInput, CommentUncheckedCreateWithoutThreadInput>
      | CommentCreateWithoutThreadInput[]
      | CommentUncheckedCreateWithoutThreadInput[];
    connectOrCreate?:
      | CommentCreateOrConnectWithoutThreadInput
      | CommentCreateOrConnectWithoutThreadInput[];
    createMany?: CommentCreateManyThreadInputEnvelope;
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
  };

  export type CommentUncheckedCreateNestedManyWithoutThreadInput = {
    create?:
      | XOR<CommentCreateWithoutThreadInput, CommentUncheckedCreateWithoutThreadInput>
      | CommentCreateWithoutThreadInput[]
      | CommentUncheckedCreateWithoutThreadInput[];
    connectOrCreate?:
      | CommentCreateOrConnectWithoutThreadInput
      | CommentCreateOrConnectWithoutThreadInput[];
    createMany?: CommentCreateManyThreadInputEnvelope;
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
  };

  export type EnumCommentEntityTypeFieldUpdateOperationsInput = {
    set?: $Enums.CommentEntityType;
  };

  export type CommentUpdateManyWithoutThreadNestedInput = {
    create?:
      | XOR<CommentCreateWithoutThreadInput, CommentUncheckedCreateWithoutThreadInput>
      | CommentCreateWithoutThreadInput[]
      | CommentUncheckedCreateWithoutThreadInput[];
    connectOrCreate?:
      | CommentCreateOrConnectWithoutThreadInput
      | CommentCreateOrConnectWithoutThreadInput[];
    upsert?:
      | CommentUpsertWithWhereUniqueWithoutThreadInput
      | CommentUpsertWithWhereUniqueWithoutThreadInput[];
    createMany?: CommentCreateManyThreadInputEnvelope;
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
    update?:
      | CommentUpdateWithWhereUniqueWithoutThreadInput
      | CommentUpdateWithWhereUniqueWithoutThreadInput[];
    updateMany?:
      | CommentUpdateManyWithWhereWithoutThreadInput
      | CommentUpdateManyWithWhereWithoutThreadInput[];
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[];
  };

  export type CommentUncheckedUpdateManyWithoutThreadNestedInput = {
    create?:
      | XOR<CommentCreateWithoutThreadInput, CommentUncheckedCreateWithoutThreadInput>
      | CommentCreateWithoutThreadInput[]
      | CommentUncheckedCreateWithoutThreadInput[];
    connectOrCreate?:
      | CommentCreateOrConnectWithoutThreadInput
      | CommentCreateOrConnectWithoutThreadInput[];
    upsert?:
      | CommentUpsertWithWhereUniqueWithoutThreadInput
      | CommentUpsertWithWhereUniqueWithoutThreadInput[];
    createMany?: CommentCreateManyThreadInputEnvelope;
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
    update?:
      | CommentUpdateWithWhereUniqueWithoutThreadInput
      | CommentUpdateWithWhereUniqueWithoutThreadInput[];
    updateMany?:
      | CommentUpdateManyWithWhereWithoutThreadInput
      | CommentUpdateManyWithWhereWithoutThreadInput[];
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[];
  };

  export type CommentThreadCreateNestedOneWithoutCommentsInput = {
    create?: XOR<
      CommentThreadCreateWithoutCommentsInput,
      CommentThreadUncheckedCreateWithoutCommentsInput
    >;
    connectOrCreate?: CommentThreadCreateOrConnectWithoutCommentsInput;
    connect?: CommentThreadWhereUniqueInput;
  };

  export type UserCreateNestedOneWithoutCommentsInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>;
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput;
    connect?: UserWhereUniqueInput;
  };

  export type CommentCreateNestedOneWithoutRepliesInput = {
    create?: XOR<CommentCreateWithoutRepliesInput, CommentUncheckedCreateWithoutRepliesInput>;
    connectOrCreate?: CommentCreateOrConnectWithoutRepliesInput;
    connect?: CommentWhereUniqueInput;
  };

  export type CommentCreateNestedManyWithoutParentInput = {
    create?:
      | XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput>
      | CommentCreateWithoutParentInput[]
      | CommentUncheckedCreateWithoutParentInput[];
    connectOrCreate?:
      | CommentCreateOrConnectWithoutParentInput
      | CommentCreateOrConnectWithoutParentInput[];
    createMany?: CommentCreateManyParentInputEnvelope;
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
  };

  export type CommentUncheckedCreateNestedManyWithoutParentInput = {
    create?:
      | XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput>
      | CommentCreateWithoutParentInput[]
      | CommentUncheckedCreateWithoutParentInput[];
    connectOrCreate?:
      | CommentCreateOrConnectWithoutParentInput
      | CommentCreateOrConnectWithoutParentInput[];
    createMany?: CommentCreateManyParentInputEnvelope;
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
  };

  export type CommentThreadUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<
      CommentThreadCreateWithoutCommentsInput,
      CommentThreadUncheckedCreateWithoutCommentsInput
    >;
    connectOrCreate?: CommentThreadCreateOrConnectWithoutCommentsInput;
    upsert?: CommentThreadUpsertWithoutCommentsInput;
    connect?: CommentThreadWhereUniqueInput;
    update?: XOR<
      XOR<
        CommentThreadUpdateToOneWithWhereWithoutCommentsInput,
        CommentThreadUpdateWithoutCommentsInput
      >,
      CommentThreadUncheckedUpdateWithoutCommentsInput
    >;
  };

  export type UserUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>;
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput;
    upsert?: UserUpsertWithoutCommentsInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<UserUpdateToOneWithWhereWithoutCommentsInput, UserUpdateWithoutCommentsInput>,
      UserUncheckedUpdateWithoutCommentsInput
    >;
  };

  export type CommentUpdateOneWithoutRepliesNestedInput = {
    create?: XOR<CommentCreateWithoutRepliesInput, CommentUncheckedCreateWithoutRepliesInput>;
    connectOrCreate?: CommentCreateOrConnectWithoutRepliesInput;
    upsert?: CommentUpsertWithoutRepliesInput;
    disconnect?: CommentWhereInput | boolean;
    delete?: CommentWhereInput | boolean;
    connect?: CommentWhereUniqueInput;
    update?: XOR<
      XOR<CommentUpdateToOneWithWhereWithoutRepliesInput, CommentUpdateWithoutRepliesInput>,
      CommentUncheckedUpdateWithoutRepliesInput
    >;
  };

  export type CommentUpdateManyWithoutParentNestedInput = {
    create?:
      | XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput>
      | CommentCreateWithoutParentInput[]
      | CommentUncheckedCreateWithoutParentInput[];
    connectOrCreate?:
      | CommentCreateOrConnectWithoutParentInput
      | CommentCreateOrConnectWithoutParentInput[];
    upsert?:
      | CommentUpsertWithWhereUniqueWithoutParentInput
      | CommentUpsertWithWhereUniqueWithoutParentInput[];
    createMany?: CommentCreateManyParentInputEnvelope;
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
    update?:
      | CommentUpdateWithWhereUniqueWithoutParentInput
      | CommentUpdateWithWhereUniqueWithoutParentInput[];
    updateMany?:
      | CommentUpdateManyWithWhereWithoutParentInput
      | CommentUpdateManyWithWhereWithoutParentInput[];
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[];
  };

  export type CommentUncheckedUpdateManyWithoutParentNestedInput = {
    create?:
      | XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput>
      | CommentCreateWithoutParentInput[]
      | CommentUncheckedCreateWithoutParentInput[];
    connectOrCreate?:
      | CommentCreateOrConnectWithoutParentInput
      | CommentCreateOrConnectWithoutParentInput[];
    upsert?:
      | CommentUpsertWithWhereUniqueWithoutParentInput
      | CommentUpsertWithWhereUniqueWithoutParentInput[];
    createMany?: CommentCreateManyParentInputEnvelope;
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[];
    update?:
      | CommentUpdateWithWhereUniqueWithoutParentInput
      | CommentUpdateWithWhereUniqueWithoutParentInput[];
    updateMany?:
      | CommentUpdateManyWithWhereWithoutParentInput
      | CommentUpdateManyWithWhereWithoutParentInput[];
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[];
  };

  export type GamificationProfileCreatebadgesInput = {
    set: string[];
  };

  export type UserCreateNestedOneWithoutGamificationProfileInput = {
    create?: XOR<
      UserCreateWithoutGamificationProfileInput,
      UserUncheckedCreateWithoutGamificationProfileInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutGamificationProfileInput;
    connect?: UserWhereUniqueInput;
  };

  export type GamificationProfileUpdatebadgesInput = {
    set?: string[];
    push?: string | string[];
  };

  export type UserUpdateOneRequiredWithoutGamificationProfileNestedInput = {
    create?: XOR<
      UserCreateWithoutGamificationProfileInput,
      UserUncheckedCreateWithoutGamificationProfileInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutGamificationProfileInput;
    upsert?: UserUpsertWithoutGamificationProfileInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutGamificationProfileInput,
        UserUpdateWithoutGamificationProfileInput
      >,
      UserUncheckedUpdateWithoutGamificationProfileInput
    >;
  };

  export type UserCreateNestedOneWithoutXpEventsInput = {
    create?: XOR<UserCreateWithoutXpEventsInput, UserUncheckedCreateWithoutXpEventsInput>;
    connectOrCreate?: UserCreateOrConnectWithoutXpEventsInput;
    connect?: UserWhereUniqueInput;
  };

  export type UserUpdateOneRequiredWithoutXpEventsNestedInput = {
    create?: XOR<UserCreateWithoutXpEventsInput, UserUncheckedCreateWithoutXpEventsInput>;
    connectOrCreate?: UserCreateOrConnectWithoutXpEventsInput;
    upsert?: UserUpsertWithoutXpEventsInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<UserUpdateToOneWithWhereWithoutXpEventsInput, UserUpdateWithoutXpEventsInput>,
      UserUncheckedUpdateWithoutXpEventsInput
    >;
  };

  export type EnumLeaderboardScopeFieldUpdateOperationsInput = {
    set?: $Enums.LeaderboardScope;
  };

  export type EnumLeaderboardPeriodFieldUpdateOperationsInput = {
    set?: $Enums.LeaderboardPeriod;
  };

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>;
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput;
    connect?: UserWhereUniqueInput;
  };

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>;
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput;
    upsert?: UserUpsertWithoutNotificationsInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>,
      UserUncheckedUpdateWithoutNotificationsInput
    >;
  };

  export type UserCreateNestedOneWithoutReportsInput = {
    create?: XOR<UserCreateWithoutReportsInput, UserUncheckedCreateWithoutReportsInput>;
    connectOrCreate?: UserCreateOrConnectWithoutReportsInput;
    connect?: UserWhereUniqueInput;
  };

  export type EnumReportStatusFieldUpdateOperationsInput = {
    set?: $Enums.ReportStatus;
  };

  export type UserUpdateOneRequiredWithoutReportsNestedInput = {
    create?: XOR<UserCreateWithoutReportsInput, UserUncheckedCreateWithoutReportsInput>;
    connectOrCreate?: UserCreateOrConnectWithoutReportsInput;
    upsert?: UserUpsertWithoutReportsInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<UserUpdateToOneWithWhereWithoutReportsInput, UserUpdateWithoutReportsInput>,
      UserUncheckedUpdateWithoutReportsInput
    >;
  };

  export type UserCreateNestedOneWithoutUploadedFilesInput = {
    create?: XOR<UserCreateWithoutUploadedFilesInput, UserUncheckedCreateWithoutUploadedFilesInput>;
    connectOrCreate?: UserCreateOrConnectWithoutUploadedFilesInput;
    connect?: UserWhereUniqueInput;
  };

  export type UserUpdateOneRequiredWithoutUploadedFilesNestedInput = {
    create?: XOR<UserCreateWithoutUploadedFilesInput, UserUncheckedCreateWithoutUploadedFilesInput>;
    connectOrCreate?: UserCreateOrConnectWithoutUploadedFilesInput;
    upsert?: UserUpsertWithoutUploadedFilesInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<UserUpdateToOneWithWhereWithoutUploadedFilesInput, UserUpdateWithoutUploadedFilesInput>,
      UserUncheckedUpdateWithoutUploadedFilesInput
    >;
  };

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringFilter<$PrismaModel> | string;
  };

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null;
  };

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringNullableFilter<$PrismaModel> | string | null;
  };

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolFilter<$PrismaModel> | boolean;
  };

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string;
  };

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedStringFilter<$PrismaModel>;
    _max?: NestedStringFilter<$PrismaModel>;
  };

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntFilter<$PrismaModel> | number;
  };

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedDateTimeNullableFilter<$PrismaModel>;
    _max?: NestedDateTimeNullableFilter<$PrismaModel>;
  };

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableFilter<$PrismaModel> | number | null;
  };

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedStringNullableFilter<$PrismaModel>;
    _max?: NestedStringNullableFilter<$PrismaModel>;
  };

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedBoolFilter<$PrismaModel>;
    _max?: NestedBoolFilter<$PrismaModel>;
  };

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedDateTimeFilter<$PrismaModel>;
    _max?: NestedDateTimeFilter<$PrismaModel>;
  };

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedFloatNullableFilter<$PrismaModel>;
    _sum?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedIntNullableFilter<$PrismaModel>;
    _max?: NestedIntNullableFilter<$PrismaModel>;
  };

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null;
  };
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<NestedJsonNullableFilterBase<$PrismaModel>>,
          Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>
        >,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>;

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter;
    path?: string[];
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter;
  };

  export type NestedEnumHackathonStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.HackathonStatus | EnumHackathonStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.HackathonStatus[] | ListEnumHackathonStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.HackathonStatus[] | ListEnumHackathonStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumHackathonStatusFilter<$PrismaModel> | $Enums.HackathonStatus;
  };

  export type NestedEnumHackathonLocationFilter<$PrismaModel = never> = {
    equals?: $Enums.HackathonLocation | EnumHackathonLocationFieldRefInput<$PrismaModel>;
    in?: $Enums.HackathonLocation[] | ListEnumHackathonLocationFieldRefInput<$PrismaModel>;
    notIn?: $Enums.HackathonLocation[] | ListEnumHackathonLocationFieldRefInput<$PrismaModel>;
    not?: NestedEnumHackathonLocationFilter<$PrismaModel> | $Enums.HackathonLocation;
  };

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null;
    in?:
      | Decimal[]
      | DecimalJsLike[]
      | number[]
      | string[]
      | ListDecimalFieldRefInput<$PrismaModel>
      | null;
    notIn?:
      | Decimal[]
      | DecimalJsLike[]
      | number[]
      | string[]
      | ListDecimalFieldRefInput<$PrismaModel>
      | null;
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    not?:
      | NestedDecimalNullableFilter<$PrismaModel>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
  };

  export type NestedEnumHackathonStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.HackathonStatus | EnumHackathonStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.HackathonStatus[] | ListEnumHackathonStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.HackathonStatus[] | ListEnumHackathonStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumHackathonStatusWithAggregatesFilter<$PrismaModel> | $Enums.HackathonStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumHackathonStatusFilter<$PrismaModel>;
    _max?: NestedEnumHackathonStatusFilter<$PrismaModel>;
  };

  export type NestedEnumHackathonLocationWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.HackathonLocation | EnumHackathonLocationFieldRefInput<$PrismaModel>;
    in?: $Enums.HackathonLocation[] | ListEnumHackathonLocationFieldRefInput<$PrismaModel>;
    notIn?: $Enums.HackathonLocation[] | ListEnumHackathonLocationFieldRefInput<$PrismaModel>;
    not?: NestedEnumHackathonLocationWithAggregatesFilter<$PrismaModel> | $Enums.HackathonLocation;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumHackathonLocationFilter<$PrismaModel>;
    _max?: NestedEnumHackathonLocationFilter<$PrismaModel>;
  };

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null;
    in?:
      | Decimal[]
      | DecimalJsLike[]
      | number[]
      | string[]
      | ListDecimalFieldRefInput<$PrismaModel>
      | null;
    notIn?:
      | Decimal[]
      | DecimalJsLike[]
      | number[]
      | string[]
      | ListDecimalFieldRefInput<$PrismaModel>
      | null;
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    not?:
      | NestedDecimalNullableWithAggregatesFilter<$PrismaModel>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedDecimalNullableFilter<$PrismaModel>;
    _sum?: NestedDecimalNullableFilter<$PrismaModel>;
    _min?: NestedDecimalNullableFilter<$PrismaModel>;
    _max?: NestedDecimalNullableFilter<$PrismaModel>;
  };

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedIntFilter<$PrismaModel>;
    _min?: NestedIntFilter<$PrismaModel>;
    _max?: NestedIntFilter<$PrismaModel>;
  };

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatFilter<$PrismaModel> | number;
  };

  export type NestedEnumTeamMemberRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.TeamMemberRole | EnumTeamMemberRoleFieldRefInput<$PrismaModel>;
    in?: $Enums.TeamMemberRole[] | ListEnumTeamMemberRoleFieldRefInput<$PrismaModel>;
    notIn?: $Enums.TeamMemberRole[] | ListEnumTeamMemberRoleFieldRefInput<$PrismaModel>;
    not?: NestedEnumTeamMemberRoleFilter<$PrismaModel> | $Enums.TeamMemberRole;
  };

  export type NestedEnumTeamMemberRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TeamMemberRole | EnumTeamMemberRoleFieldRefInput<$PrismaModel>;
    in?: $Enums.TeamMemberRole[] | ListEnumTeamMemberRoleFieldRefInput<$PrismaModel>;
    notIn?: $Enums.TeamMemberRole[] | ListEnumTeamMemberRoleFieldRefInput<$PrismaModel>;
    not?: NestedEnumTeamMemberRoleWithAggregatesFilter<$PrismaModel> | $Enums.TeamMemberRole;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumTeamMemberRoleFilter<$PrismaModel>;
    _max?: NestedEnumTeamMemberRoleFilter<$PrismaModel>;
  };

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>;
    notIn?:
      | Decimal[]
      | DecimalJsLike[]
      | number[]
      | string[]
      | ListDecimalFieldRefInput<$PrismaModel>;
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string;
  };

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>;
    notIn?:
      | Decimal[]
      | DecimalJsLike[]
      | number[]
      | string[]
      | ListDecimalFieldRefInput<$PrismaModel>;
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>;
    not?:
      | NestedDecimalWithAggregatesFilter<$PrismaModel>
      | Decimal
      | DecimalJsLike
      | number
      | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedDecimalFilter<$PrismaModel>;
    _sum?: NestedDecimalFilter<$PrismaModel>;
    _min?: NestedDecimalFilter<$PrismaModel>;
    _max?: NestedDecimalFilter<$PrismaModel>;
  };

  export type NestedEnumSubmissionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubmissionStatus | EnumSubmissionStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.SubmissionStatus[] | ListEnumSubmissionStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.SubmissionStatus[] | ListEnumSubmissionStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumSubmissionStatusFilter<$PrismaModel> | $Enums.SubmissionStatus;
  };

  export type NestedEnumSubmissionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubmissionStatus | EnumSubmissionStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.SubmissionStatus[] | ListEnumSubmissionStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.SubmissionStatus[] | ListEnumSubmissionStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumSubmissionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubmissionStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumSubmissionStatusFilter<$PrismaModel>;
    _max?: NestedEnumSubmissionStatusFilter<$PrismaModel>;
  };

  export type NestedEnumRewardTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.RewardType | EnumRewardTypeFieldRefInput<$PrismaModel> | null;
    in?: $Enums.RewardType[] | ListEnumRewardTypeFieldRefInput<$PrismaModel> | null;
    notIn?: $Enums.RewardType[] | ListEnumRewardTypeFieldRefInput<$PrismaModel> | null;
    not?: NestedEnumRewardTypeNullableFilter<$PrismaModel> | $Enums.RewardType | null;
  };

  export type NestedEnumChallengeStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ChallengeStatus | EnumChallengeStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.ChallengeStatus[] | ListEnumChallengeStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.ChallengeStatus[] | ListEnumChallengeStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumChallengeStatusFilter<$PrismaModel> | $Enums.ChallengeStatus;
  };

  export type NestedEnumChallengeVisibilityFilter<$PrismaModel = never> = {
    equals?: $Enums.ChallengeVisibility | EnumChallengeVisibilityFieldRefInput<$PrismaModel>;
    in?: $Enums.ChallengeVisibility[] | ListEnumChallengeVisibilityFieldRefInput<$PrismaModel>;
    notIn?: $Enums.ChallengeVisibility[] | ListEnumChallengeVisibilityFieldRefInput<$PrismaModel>;
    not?: NestedEnumChallengeVisibilityFilter<$PrismaModel> | $Enums.ChallengeVisibility;
  };

  export type NestedEnumRewardTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RewardType | EnumRewardTypeFieldRefInput<$PrismaModel> | null;
    in?: $Enums.RewardType[] | ListEnumRewardTypeFieldRefInput<$PrismaModel> | null;
    notIn?: $Enums.RewardType[] | ListEnumRewardTypeFieldRefInput<$PrismaModel> | null;
    not?: NestedEnumRewardTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.RewardType | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedEnumRewardTypeNullableFilter<$PrismaModel>;
    _max?: NestedEnumRewardTypeNullableFilter<$PrismaModel>;
  };

  export type NestedEnumChallengeStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChallengeStatus | EnumChallengeStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.ChallengeStatus[] | ListEnumChallengeStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.ChallengeStatus[] | ListEnumChallengeStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumChallengeStatusWithAggregatesFilter<$PrismaModel> | $Enums.ChallengeStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumChallengeStatusFilter<$PrismaModel>;
    _max?: NestedEnumChallengeStatusFilter<$PrismaModel>;
  };

  export type NestedEnumChallengeVisibilityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChallengeVisibility | EnumChallengeVisibilityFieldRefInput<$PrismaModel>;
    in?: $Enums.ChallengeVisibility[] | ListEnumChallengeVisibilityFieldRefInput<$PrismaModel>;
    notIn?: $Enums.ChallengeVisibility[] | ListEnumChallengeVisibilityFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumChallengeVisibilityWithAggregatesFilter<$PrismaModel>
      | $Enums.ChallengeVisibility;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumChallengeVisibilityFilter<$PrismaModel>;
    _max?: NestedEnumChallengeVisibilityFilter<$PrismaModel>;
  };

  export type NestedEnumChallengeSubmissionStatusFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.ChallengeSubmissionStatus
      | EnumChallengeSubmissionStatusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.ChallengeSubmissionStatus[]
      | ListEnumChallengeSubmissionStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.ChallengeSubmissionStatus[]
      | ListEnumChallengeSubmissionStatusFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumChallengeSubmissionStatusFilter<$PrismaModel>
      | $Enums.ChallengeSubmissionStatus;
  };

  export type NestedEnumChallengeSubmissionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.ChallengeSubmissionStatus
      | EnumChallengeSubmissionStatusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.ChallengeSubmissionStatus[]
      | ListEnumChallengeSubmissionStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.ChallengeSubmissionStatus[]
      | ListEnumChallengeSubmissionStatusFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumChallengeSubmissionStatusWithAggregatesFilter<$PrismaModel>
      | $Enums.ChallengeSubmissionStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumChallengeSubmissionStatusFilter<$PrismaModel>;
    _max?: NestedEnumChallengeSubmissionStatusFilter<$PrismaModel>;
  };

  export type NestedEnumAnnouncementScopeFilter<$PrismaModel = never> = {
    equals?: $Enums.AnnouncementScope | EnumAnnouncementScopeFieldRefInput<$PrismaModel>;
    in?: $Enums.AnnouncementScope[] | ListEnumAnnouncementScopeFieldRefInput<$PrismaModel>;
    notIn?: $Enums.AnnouncementScope[] | ListEnumAnnouncementScopeFieldRefInput<$PrismaModel>;
    not?: NestedEnumAnnouncementScopeFilter<$PrismaModel> | $Enums.AnnouncementScope;
  };

  export type NestedEnumAnnouncementScopeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AnnouncementScope | EnumAnnouncementScopeFieldRefInput<$PrismaModel>;
    in?: $Enums.AnnouncementScope[] | ListEnumAnnouncementScopeFieldRefInput<$PrismaModel>;
    notIn?: $Enums.AnnouncementScope[] | ListEnumAnnouncementScopeFieldRefInput<$PrismaModel>;
    not?: NestedEnumAnnouncementScopeWithAggregatesFilter<$PrismaModel> | $Enums.AnnouncementScope;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumAnnouncementScopeFilter<$PrismaModel>;
    _max?: NestedEnumAnnouncementScopeFilter<$PrismaModel>;
  };

  export type NestedEnumCommentEntityTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CommentEntityType | EnumCommentEntityTypeFieldRefInput<$PrismaModel>;
    in?: $Enums.CommentEntityType[] | ListEnumCommentEntityTypeFieldRefInput<$PrismaModel>;
    notIn?: $Enums.CommentEntityType[] | ListEnumCommentEntityTypeFieldRefInput<$PrismaModel>;
    not?: NestedEnumCommentEntityTypeFilter<$PrismaModel> | $Enums.CommentEntityType;
  };

  export type NestedEnumCommentEntityTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CommentEntityType | EnumCommentEntityTypeFieldRefInput<$PrismaModel>;
    in?: $Enums.CommentEntityType[] | ListEnumCommentEntityTypeFieldRefInput<$PrismaModel>;
    notIn?: $Enums.CommentEntityType[] | ListEnumCommentEntityTypeFieldRefInput<$PrismaModel>;
    not?: NestedEnumCommentEntityTypeWithAggregatesFilter<$PrismaModel> | $Enums.CommentEntityType;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumCommentEntityTypeFilter<$PrismaModel>;
    _max?: NestedEnumCommentEntityTypeFilter<$PrismaModel>;
  };

  export type NestedEnumLeaderboardScopeFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaderboardScope | EnumLeaderboardScopeFieldRefInput<$PrismaModel>;
    in?: $Enums.LeaderboardScope[] | ListEnumLeaderboardScopeFieldRefInput<$PrismaModel>;
    notIn?: $Enums.LeaderboardScope[] | ListEnumLeaderboardScopeFieldRefInput<$PrismaModel>;
    not?: NestedEnumLeaderboardScopeFilter<$PrismaModel> | $Enums.LeaderboardScope;
  };

  export type NestedEnumLeaderboardPeriodFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaderboardPeriod | EnumLeaderboardPeriodFieldRefInput<$PrismaModel>;
    in?: $Enums.LeaderboardPeriod[] | ListEnumLeaderboardPeriodFieldRefInput<$PrismaModel>;
    notIn?: $Enums.LeaderboardPeriod[] | ListEnumLeaderboardPeriodFieldRefInput<$PrismaModel>;
    not?: NestedEnumLeaderboardPeriodFilter<$PrismaModel> | $Enums.LeaderboardPeriod;
  };

  export type NestedEnumLeaderboardScopeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaderboardScope | EnumLeaderboardScopeFieldRefInput<$PrismaModel>;
    in?: $Enums.LeaderboardScope[] | ListEnumLeaderboardScopeFieldRefInput<$PrismaModel>;
    notIn?: $Enums.LeaderboardScope[] | ListEnumLeaderboardScopeFieldRefInput<$PrismaModel>;
    not?: NestedEnumLeaderboardScopeWithAggregatesFilter<$PrismaModel> | $Enums.LeaderboardScope;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumLeaderboardScopeFilter<$PrismaModel>;
    _max?: NestedEnumLeaderboardScopeFilter<$PrismaModel>;
  };

  export type NestedEnumLeaderboardPeriodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaderboardPeriod | EnumLeaderboardPeriodFieldRefInput<$PrismaModel>;
    in?: $Enums.LeaderboardPeriod[] | ListEnumLeaderboardPeriodFieldRefInput<$PrismaModel>;
    notIn?: $Enums.LeaderboardPeriod[] | ListEnumLeaderboardPeriodFieldRefInput<$PrismaModel>;
    not?: NestedEnumLeaderboardPeriodWithAggregatesFilter<$PrismaModel> | $Enums.LeaderboardPeriod;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumLeaderboardPeriodFilter<$PrismaModel>;
    _max?: NestedEnumLeaderboardPeriodFilter<$PrismaModel>;
  };
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<NestedJsonFilterBase<$PrismaModel>>,
          Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>
        >,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>;

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter;
    path?: string[];
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter;
  };

  export type NestedEnumReportStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportStatus | EnumReportStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumReportStatusFilter<$PrismaModel> | $Enums.ReportStatus;
  };

  export type NestedEnumReportStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportStatus | EnumReportStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumReportStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReportStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumReportStatusFilter<$PrismaModel>;
    _max?: NestedEnumReportStatusFilter<$PrismaModel>;
  };

  export type AccountCreateWithoutUserInput = {
    id?: string;
    type: string;
    provider: string;
    providerAccountId: string;
    refresh_token?: string | null;
    access_token?: string | null;
    expires_at?: number | null;
    token_type?: string | null;
    scope?: string | null;
    id_token?: string | null;
    session_state?: string | null;
  };

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string;
    type: string;
    provider: string;
    providerAccountId: string;
    refresh_token?: string | null;
    access_token?: string | null;
    expires_at?: number | null;
    token_type?: string | null;
    scope?: string | null;
    id_token?: string | null;
    session_state?: string | null;
  };

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput;
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>;
  };

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type SessionCreateWithoutUserInput = {
    id?: string;
    sessionToken: string;
    expires: Date | string;
  };

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string;
    sessionToken: string;
    expires: Date | string;
  };

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput;
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>;
  };

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type ApiKeyCreateWithoutUserInput = {
    id?: string;
    name: string;
    hashedKey: string;
    scopes?: ApiKeyCreatescopesInput | string[];
    lastUsedAt?: Date | string | null;
    expiresAt?: Date | string | null;
    createdAt?: Date | string;
    isActive?: boolean;
  };

  export type ApiKeyUncheckedCreateWithoutUserInput = {
    id?: string;
    name: string;
    hashedKey: string;
    scopes?: ApiKeyCreatescopesInput | string[];
    lastUsedAt?: Date | string | null;
    expiresAt?: Date | string | null;
    createdAt?: Date | string;
    isActive?: boolean;
  };

  export type ApiKeyCreateOrConnectWithoutUserInput = {
    where: ApiKeyWhereUniqueInput;
    create: XOR<ApiKeyCreateWithoutUserInput, ApiKeyUncheckedCreateWithoutUserInput>;
  };

  export type ApiKeyCreateManyUserInputEnvelope = {
    data: ApiKeyCreateManyUserInput | ApiKeyCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type AuditLogCreateWithoutActorInput = {
    id?: string;
    action: string;
    entityType: string;
    entityId?: string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    ipAddress?: string | null;
    userAgent?: string | null;
    createdAt?: Date | string;
  };

  export type AuditLogUncheckedCreateWithoutActorInput = {
    id?: string;
    action: string;
    entityType: string;
    entityId?: string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    ipAddress?: string | null;
    userAgent?: string | null;
    createdAt?: Date | string;
  };

  export type AuditLogCreateOrConnectWithoutActorInput = {
    where: AuditLogWhereUniqueInput;
    create: XOR<AuditLogCreateWithoutActorInput, AuditLogUncheckedCreateWithoutActorInput>;
  };

  export type AuditLogCreateManyActorInputEnvelope = {
    data: AuditLogCreateManyActorInput | AuditLogCreateManyActorInput[];
    skipDuplicates?: boolean;
  };

  export type TeamMemberCreateWithoutUserInput = {
    role?: $Enums.TeamMemberRole;
    joinedAt?: Date | string;
    team: TeamCreateNestedOneWithoutMembersInput;
  };

  export type TeamMemberUncheckedCreateWithoutUserInput = {
    teamId: string;
    role?: $Enums.TeamMemberRole;
    joinedAt?: Date | string;
  };

  export type TeamMemberCreateOrConnectWithoutUserInput = {
    where: TeamMemberWhereUniqueInput;
    create: XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput>;
  };

  export type TeamMemberCreateManyUserInputEnvelope = {
    data: TeamMemberCreateManyUserInput | TeamMemberCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type MentorCreateWithoutUserInput = {
    id?: string;
    bio?: string | null;
    calendlyUrl?: string | null;
    expertise?: MentorCreateexpertiseInput | string[];
    createdAt?: Date | string;
    hackathon: HackathonCreateNestedOneWithoutMentorsInput;
    sessions?: MentorSessionCreateNestedManyWithoutMentorInput;
  };

  export type MentorUncheckedCreateWithoutUserInput = {
    id?: string;
    hackathonId: string;
    bio?: string | null;
    calendlyUrl?: string | null;
    expertise?: MentorCreateexpertiseInput | string[];
    createdAt?: Date | string;
    sessions?: MentorSessionUncheckedCreateNestedManyWithoutMentorInput;
  };

  export type MentorCreateOrConnectWithoutUserInput = {
    where: MentorWhereUniqueInput;
    create: XOR<MentorCreateWithoutUserInput, MentorUncheckedCreateWithoutUserInput>;
  };

  export type MentorCreateManyUserInputEnvelope = {
    data: MentorCreateManyUserInput | MentorCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type JudgeCreateWithoutUserInput = {
    id?: string;
    bio?: string | null;
    createdAt?: Date | string;
    hackathon: HackathonCreateNestedOneWithoutJudgesInput;
    scores?: ScoreCreateNestedManyWithoutJudgeInput;
  };

  export type JudgeUncheckedCreateWithoutUserInput = {
    id?: string;
    hackathonId: string;
    bio?: string | null;
    createdAt?: Date | string;
    scores?: ScoreUncheckedCreateNestedManyWithoutJudgeInput;
  };

  export type JudgeCreateOrConnectWithoutUserInput = {
    where: JudgeWhereUniqueInput;
    create: XOR<JudgeCreateWithoutUserInput, JudgeUncheckedCreateWithoutUserInput>;
  };

  export type JudgeCreateManyUserInputEnvelope = {
    data: JudgeCreateManyUserInput | JudgeCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type ChallengeSubmissionCreateWithoutUserInput = {
    id?: string;
    title: string;
    repoUrl?: string | null;
    content: string;
    files?: ChallengeSubmissionCreatefilesInput | string[];
    status?: $Enums.ChallengeSubmissionStatus;
    score?: Decimal | DecimalJsLike | number | string | null;
    feedback?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    challenge: ChallengeCreateNestedOneWithoutSubmissionsInput;
    team?: TeamCreateNestedOneWithoutChallengeSubmissionsInput;
  };

  export type ChallengeSubmissionUncheckedCreateWithoutUserInput = {
    id?: string;
    challengeId: string;
    teamId?: string | null;
    title: string;
    repoUrl?: string | null;
    content: string;
    files?: ChallengeSubmissionCreatefilesInput | string[];
    status?: $Enums.ChallengeSubmissionStatus;
    score?: Decimal | DecimalJsLike | number | string | null;
    feedback?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ChallengeSubmissionCreateOrConnectWithoutUserInput = {
    where: ChallengeSubmissionWhereUniqueInput;
    create: XOR<
      ChallengeSubmissionCreateWithoutUserInput,
      ChallengeSubmissionUncheckedCreateWithoutUserInput
    >;
  };

  export type ChallengeSubmissionCreateManyUserInputEnvelope = {
    data: ChallengeSubmissionCreateManyUserInput | ChallengeSubmissionCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type CommentCreateWithoutAuthorInput = {
    id?: string;
    body: string;
    isFlagged?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    thread: CommentThreadCreateNestedOneWithoutCommentsInput;
    parent?: CommentCreateNestedOneWithoutRepliesInput;
    replies?: CommentCreateNestedManyWithoutParentInput;
  };

  export type CommentUncheckedCreateWithoutAuthorInput = {
    id?: string;
    threadId: string;
    parentId?: string | null;
    body: string;
    isFlagged?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    replies?: CommentUncheckedCreateNestedManyWithoutParentInput;
  };

  export type CommentCreateOrConnectWithoutAuthorInput = {
    where: CommentWhereUniqueInput;
    create: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput>;
  };

  export type CommentCreateManyAuthorInputEnvelope = {
    data: CommentCreateManyAuthorInput | CommentCreateManyAuthorInput[];
    skipDuplicates?: boolean;
  };

  export type GamificationProfileCreateWithoutUserInput = {
    xp?: number;
    level?: number;
    streakDays?: number;
    vaultKeys?: number;
    badges?: GamificationProfileCreatebadgesInput | string[];
    lastActivityAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type GamificationProfileUncheckedCreateWithoutUserInput = {
    xp?: number;
    level?: number;
    streakDays?: number;
    vaultKeys?: number;
    badges?: GamificationProfileCreatebadgesInput | string[];
    lastActivityAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type GamificationProfileCreateOrConnectWithoutUserInput = {
    where: GamificationProfileWhereUniqueInput;
    create: XOR<
      GamificationProfileCreateWithoutUserInput,
      GamificationProfileUncheckedCreateWithoutUserInput
    >;
  };

  export type XpEventCreateWithoutUserInput = {
    id?: string;
    eventType: string;
    points: number;
    refType?: string | null;
    refId?: string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
  };

  export type XpEventUncheckedCreateWithoutUserInput = {
    id?: string;
    eventType: string;
    points: number;
    refType?: string | null;
    refId?: string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
  };

  export type XpEventCreateOrConnectWithoutUserInput = {
    where: XpEventWhereUniqueInput;
    create: XOR<XpEventCreateWithoutUserInput, XpEventUncheckedCreateWithoutUserInput>;
  };

  export type XpEventCreateManyUserInputEnvelope = {
    data: XpEventCreateManyUserInput | XpEventCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type NotificationCreateWithoutUserInput = {
    id?: string;
    type: string;
    data: JsonNullValueInput | InputJsonValue;
    readAt?: Date | string | null;
    createdAt?: Date | string;
  };

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string;
    type: string;
    data: JsonNullValueInput | InputJsonValue;
    readAt?: Date | string | null;
    createdAt?: Date | string;
  };

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput;
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>;
  };

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type ReportCreateWithoutReporterInput = {
    id?: string;
    entityType: string;
    entityId: string;
    reason: string;
    status?: $Enums.ReportStatus;
    resolution?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ReportUncheckedCreateWithoutReporterInput = {
    id?: string;
    entityType: string;
    entityId: string;
    reason: string;
    status?: $Enums.ReportStatus;
    resolution?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ReportCreateOrConnectWithoutReporterInput = {
    where: ReportWhereUniqueInput;
    create: XOR<ReportCreateWithoutReporterInput, ReportUncheckedCreateWithoutReporterInput>;
  };

  export type ReportCreateManyReporterInputEnvelope = {
    data: ReportCreateManyReporterInput | ReportCreateManyReporterInput[];
    skipDuplicates?: boolean;
  };

  export type FileCreateWithoutUploadedByInput = {
    id?: string;
    filename: string;
    mimetype: string;
    size: number;
    key: string;
    url: string;
    type: string;
    entityId?: string | null;
    entityType?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
  };

  export type FileUncheckedCreateWithoutUploadedByInput = {
    id?: string;
    filename: string;
    mimetype: string;
    size: number;
    key: string;
    url: string;
    type: string;
    entityId?: string | null;
    entityType?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
  };

  export type FileCreateOrConnectWithoutUploadedByInput = {
    where: FileWhereUniqueInput;
    create: XOR<FileCreateWithoutUploadedByInput, FileUncheckedCreateWithoutUploadedByInput>;
  };

  export type FileCreateManyUploadedByInputEnvelope = {
    data: FileCreateManyUploadedByInput | FileCreateManyUploadedByInput[];
    skipDuplicates?: boolean;
  };

  export type ChallengeCreateWithoutOwnerInput = {
    id?: string;
    slug: string;
    title: string;
    problemStatement: string;
    ownerOrg?: string | null;
    rewardType?: $Enums.RewardType | null;
    rewardValue?: string | null;
    categories?: ChallengeCreatecategoriesInput | string[];
    skills?: ChallengeCreateskillsInput | string[];
    attachments?: ChallengeCreateattachmentsInput | string[];
    status?: $Enums.ChallengeStatus;
    visibility?: $Enums.ChallengeVisibility;
    deadlineAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    submissions?: ChallengeSubmissionCreateNestedManyWithoutChallengeInput;
  };

  export type ChallengeUncheckedCreateWithoutOwnerInput = {
    id?: string;
    slug: string;
    title: string;
    problemStatement: string;
    ownerOrg?: string | null;
    rewardType?: $Enums.RewardType | null;
    rewardValue?: string | null;
    categories?: ChallengeCreatecategoriesInput | string[];
    skills?: ChallengeCreateskillsInput | string[];
    attachments?: ChallengeCreateattachmentsInput | string[];
    status?: $Enums.ChallengeStatus;
    visibility?: $Enums.ChallengeVisibility;
    deadlineAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    submissions?: ChallengeSubmissionUncheckedCreateNestedManyWithoutChallengeInput;
  };

  export type ChallengeCreateOrConnectWithoutOwnerInput = {
    where: ChallengeWhereUniqueInput;
    create: XOR<ChallengeCreateWithoutOwnerInput, ChallengeUncheckedCreateWithoutOwnerInput>;
  };

  export type ChallengeCreateManyOwnerInputEnvelope = {
    data: ChallengeCreateManyOwnerInput | ChallengeCreateManyOwnerInput[];
    skipDuplicates?: boolean;
  };

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput;
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>;
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>;
  };

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput;
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>;
  };

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput;
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>;
  };

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[];
    OR?: AccountScalarWhereInput[];
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[];
    id?: StringFilter<'Account'> | string;
    userId?: StringFilter<'Account'> | string;
    type?: StringFilter<'Account'> | string;
    provider?: StringFilter<'Account'> | string;
    providerAccountId?: StringFilter<'Account'> | string;
    refresh_token?: StringNullableFilter<'Account'> | string | null;
    access_token?: StringNullableFilter<'Account'> | string | null;
    expires_at?: IntNullableFilter<'Account'> | number | null;
    token_type?: StringNullableFilter<'Account'> | string | null;
    scope?: StringNullableFilter<'Account'> | string | null;
    id_token?: StringNullableFilter<'Account'> | string | null;
    session_state?: StringNullableFilter<'Account'> | string | null;
  };

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput;
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>;
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>;
  };

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput;
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>;
  };

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput;
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>;
  };

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[];
    OR?: SessionScalarWhereInput[];
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[];
    id?: StringFilter<'Session'> | string;
    sessionToken?: StringFilter<'Session'> | string;
    userId?: StringFilter<'Session'> | string;
    expires?: DateTimeFilter<'Session'> | Date | string;
  };

  export type ApiKeyUpsertWithWhereUniqueWithoutUserInput = {
    where: ApiKeyWhereUniqueInput;
    update: XOR<ApiKeyUpdateWithoutUserInput, ApiKeyUncheckedUpdateWithoutUserInput>;
    create: XOR<ApiKeyCreateWithoutUserInput, ApiKeyUncheckedCreateWithoutUserInput>;
  };

  export type ApiKeyUpdateWithWhereUniqueWithoutUserInput = {
    where: ApiKeyWhereUniqueInput;
    data: XOR<ApiKeyUpdateWithoutUserInput, ApiKeyUncheckedUpdateWithoutUserInput>;
  };

  export type ApiKeyUpdateManyWithWhereWithoutUserInput = {
    where: ApiKeyScalarWhereInput;
    data: XOR<ApiKeyUpdateManyMutationInput, ApiKeyUncheckedUpdateManyWithoutUserInput>;
  };

  export type ApiKeyScalarWhereInput = {
    AND?: ApiKeyScalarWhereInput | ApiKeyScalarWhereInput[];
    OR?: ApiKeyScalarWhereInput[];
    NOT?: ApiKeyScalarWhereInput | ApiKeyScalarWhereInput[];
    id?: StringFilter<'ApiKey'> | string;
    userId?: StringFilter<'ApiKey'> | string;
    name?: StringFilter<'ApiKey'> | string;
    hashedKey?: StringFilter<'ApiKey'> | string;
    scopes?: StringNullableListFilter<'ApiKey'>;
    lastUsedAt?: DateTimeNullableFilter<'ApiKey'> | Date | string | null;
    expiresAt?: DateTimeNullableFilter<'ApiKey'> | Date | string | null;
    createdAt?: DateTimeFilter<'ApiKey'> | Date | string;
    isActive?: BoolFilter<'ApiKey'> | boolean;
  };

  export type AuditLogUpsertWithWhereUniqueWithoutActorInput = {
    where: AuditLogWhereUniqueInput;
    update: XOR<AuditLogUpdateWithoutActorInput, AuditLogUncheckedUpdateWithoutActorInput>;
    create: XOR<AuditLogCreateWithoutActorInput, AuditLogUncheckedCreateWithoutActorInput>;
  };

  export type AuditLogUpdateWithWhereUniqueWithoutActorInput = {
    where: AuditLogWhereUniqueInput;
    data: XOR<AuditLogUpdateWithoutActorInput, AuditLogUncheckedUpdateWithoutActorInput>;
  };

  export type AuditLogUpdateManyWithWhereWithoutActorInput = {
    where: AuditLogScalarWhereInput;
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutActorInput>;
  };

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[];
    OR?: AuditLogScalarWhereInput[];
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[];
    id?: StringFilter<'AuditLog'> | string;
    actorId?: StringNullableFilter<'AuditLog'> | string | null;
    action?: StringFilter<'AuditLog'> | string;
    entityType?: StringFilter<'AuditLog'> | string;
    entityId?: StringNullableFilter<'AuditLog'> | string | null;
    metadata?: JsonNullableFilter<'AuditLog'>;
    ipAddress?: StringNullableFilter<'AuditLog'> | string | null;
    userAgent?: StringNullableFilter<'AuditLog'> | string | null;
    createdAt?: DateTimeFilter<'AuditLog'> | Date | string;
  };

  export type TeamMemberUpsertWithWhereUniqueWithoutUserInput = {
    where: TeamMemberWhereUniqueInput;
    update: XOR<TeamMemberUpdateWithoutUserInput, TeamMemberUncheckedUpdateWithoutUserInput>;
    create: XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput>;
  };

  export type TeamMemberUpdateWithWhereUniqueWithoutUserInput = {
    where: TeamMemberWhereUniqueInput;
    data: XOR<TeamMemberUpdateWithoutUserInput, TeamMemberUncheckedUpdateWithoutUserInput>;
  };

  export type TeamMemberUpdateManyWithWhereWithoutUserInput = {
    where: TeamMemberScalarWhereInput;
    data: XOR<TeamMemberUpdateManyMutationInput, TeamMemberUncheckedUpdateManyWithoutUserInput>;
  };

  export type TeamMemberScalarWhereInput = {
    AND?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[];
    OR?: TeamMemberScalarWhereInput[];
    NOT?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[];
    teamId?: StringFilter<'TeamMember'> | string;
    userId?: StringFilter<'TeamMember'> | string;
    role?: EnumTeamMemberRoleFilter<'TeamMember'> | $Enums.TeamMemberRole;
    joinedAt?: DateTimeFilter<'TeamMember'> | Date | string;
  };

  export type MentorUpsertWithWhereUniqueWithoutUserInput = {
    where: MentorWhereUniqueInput;
    update: XOR<MentorUpdateWithoutUserInput, MentorUncheckedUpdateWithoutUserInput>;
    create: XOR<MentorCreateWithoutUserInput, MentorUncheckedCreateWithoutUserInput>;
  };

  export type MentorUpdateWithWhereUniqueWithoutUserInput = {
    where: MentorWhereUniqueInput;
    data: XOR<MentorUpdateWithoutUserInput, MentorUncheckedUpdateWithoutUserInput>;
  };

  export type MentorUpdateManyWithWhereWithoutUserInput = {
    where: MentorScalarWhereInput;
    data: XOR<MentorUpdateManyMutationInput, MentorUncheckedUpdateManyWithoutUserInput>;
  };

  export type MentorScalarWhereInput = {
    AND?: MentorScalarWhereInput | MentorScalarWhereInput[];
    OR?: MentorScalarWhereInput[];
    NOT?: MentorScalarWhereInput | MentorScalarWhereInput[];
    id?: StringFilter<'Mentor'> | string;
    userId?: StringFilter<'Mentor'> | string;
    hackathonId?: StringFilter<'Mentor'> | string;
    bio?: StringNullableFilter<'Mentor'> | string | null;
    calendlyUrl?: StringNullableFilter<'Mentor'> | string | null;
    expertise?: StringNullableListFilter<'Mentor'>;
    createdAt?: DateTimeFilter<'Mentor'> | Date | string;
  };

  export type JudgeUpsertWithWhereUniqueWithoutUserInput = {
    where: JudgeWhereUniqueInput;
    update: XOR<JudgeUpdateWithoutUserInput, JudgeUncheckedUpdateWithoutUserInput>;
    create: XOR<JudgeCreateWithoutUserInput, JudgeUncheckedCreateWithoutUserInput>;
  };

  export type JudgeUpdateWithWhereUniqueWithoutUserInput = {
    where: JudgeWhereUniqueInput;
    data: XOR<JudgeUpdateWithoutUserInput, JudgeUncheckedUpdateWithoutUserInput>;
  };

  export type JudgeUpdateManyWithWhereWithoutUserInput = {
    where: JudgeScalarWhereInput;
    data: XOR<JudgeUpdateManyMutationInput, JudgeUncheckedUpdateManyWithoutUserInput>;
  };

  export type JudgeScalarWhereInput = {
    AND?: JudgeScalarWhereInput | JudgeScalarWhereInput[];
    OR?: JudgeScalarWhereInput[];
    NOT?: JudgeScalarWhereInput | JudgeScalarWhereInput[];
    id?: StringFilter<'Judge'> | string;
    userId?: StringFilter<'Judge'> | string;
    hackathonId?: StringFilter<'Judge'> | string;
    bio?: StringNullableFilter<'Judge'> | string | null;
    createdAt?: DateTimeFilter<'Judge'> | Date | string;
  };

  export type ChallengeSubmissionUpsertWithWhereUniqueWithoutUserInput = {
    where: ChallengeSubmissionWhereUniqueInput;
    update: XOR<
      ChallengeSubmissionUpdateWithoutUserInput,
      ChallengeSubmissionUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      ChallengeSubmissionCreateWithoutUserInput,
      ChallengeSubmissionUncheckedCreateWithoutUserInput
    >;
  };

  export type ChallengeSubmissionUpdateWithWhereUniqueWithoutUserInput = {
    where: ChallengeSubmissionWhereUniqueInput;
    data: XOR<
      ChallengeSubmissionUpdateWithoutUserInput,
      ChallengeSubmissionUncheckedUpdateWithoutUserInput
    >;
  };

  export type ChallengeSubmissionUpdateManyWithWhereWithoutUserInput = {
    where: ChallengeSubmissionScalarWhereInput;
    data: XOR<
      ChallengeSubmissionUpdateManyMutationInput,
      ChallengeSubmissionUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type ChallengeSubmissionScalarWhereInput = {
    AND?: ChallengeSubmissionScalarWhereInput | ChallengeSubmissionScalarWhereInput[];
    OR?: ChallengeSubmissionScalarWhereInput[];
    NOT?: ChallengeSubmissionScalarWhereInput | ChallengeSubmissionScalarWhereInput[];
    id?: StringFilter<'ChallengeSubmission'> | string;
    challengeId?: StringFilter<'ChallengeSubmission'> | string;
    userId?: StringNullableFilter<'ChallengeSubmission'> | string | null;
    teamId?: StringNullableFilter<'ChallengeSubmission'> | string | null;
    title?: StringFilter<'ChallengeSubmission'> | string;
    repoUrl?: StringNullableFilter<'ChallengeSubmission'> | string | null;
    content?: StringFilter<'ChallengeSubmission'> | string;
    files?: StringNullableListFilter<'ChallengeSubmission'>;
    status?:
      | EnumChallengeSubmissionStatusFilter<'ChallengeSubmission'>
      | $Enums.ChallengeSubmissionStatus;
    score?:
      | DecimalNullableFilter<'ChallengeSubmission'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    feedback?: StringNullableFilter<'ChallengeSubmission'> | string | null;
    createdAt?: DateTimeFilter<'ChallengeSubmission'> | Date | string;
    updatedAt?: DateTimeFilter<'ChallengeSubmission'> | Date | string;
  };

  export type CommentUpsertWithWhereUniqueWithoutAuthorInput = {
    where: CommentWhereUniqueInput;
    update: XOR<CommentUpdateWithoutAuthorInput, CommentUncheckedUpdateWithoutAuthorInput>;
    create: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput>;
  };

  export type CommentUpdateWithWhereUniqueWithoutAuthorInput = {
    where: CommentWhereUniqueInput;
    data: XOR<CommentUpdateWithoutAuthorInput, CommentUncheckedUpdateWithoutAuthorInput>;
  };

  export type CommentUpdateManyWithWhereWithoutAuthorInput = {
    where: CommentScalarWhereInput;
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutAuthorInput>;
  };

  export type CommentScalarWhereInput = {
    AND?: CommentScalarWhereInput | CommentScalarWhereInput[];
    OR?: CommentScalarWhereInput[];
    NOT?: CommentScalarWhereInput | CommentScalarWhereInput[];
    id?: StringFilter<'Comment'> | string;
    threadId?: StringFilter<'Comment'> | string;
    authorId?: StringFilter<'Comment'> | string;
    parentId?: StringNullableFilter<'Comment'> | string | null;
    body?: StringFilter<'Comment'> | string;
    isFlagged?: BoolFilter<'Comment'> | boolean;
    createdAt?: DateTimeFilter<'Comment'> | Date | string;
    updatedAt?: DateTimeFilter<'Comment'> | Date | string;
  };

  export type GamificationProfileUpsertWithoutUserInput = {
    update: XOR<
      GamificationProfileUpdateWithoutUserInput,
      GamificationProfileUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      GamificationProfileCreateWithoutUserInput,
      GamificationProfileUncheckedCreateWithoutUserInput
    >;
    where?: GamificationProfileWhereInput;
  };

  export type GamificationProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: GamificationProfileWhereInput;
    data: XOR<
      GamificationProfileUpdateWithoutUserInput,
      GamificationProfileUncheckedUpdateWithoutUserInput
    >;
  };

  export type GamificationProfileUpdateWithoutUserInput = {
    xp?: IntFieldUpdateOperationsInput | number;
    level?: IntFieldUpdateOperationsInput | number;
    streakDays?: IntFieldUpdateOperationsInput | number;
    vaultKeys?: IntFieldUpdateOperationsInput | number;
    badges?: GamificationProfileUpdatebadgesInput | string[];
    lastActivityAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type GamificationProfileUncheckedUpdateWithoutUserInput = {
    xp?: IntFieldUpdateOperationsInput | number;
    level?: IntFieldUpdateOperationsInput | number;
    streakDays?: IntFieldUpdateOperationsInput | number;
    vaultKeys?: IntFieldUpdateOperationsInput | number;
    badges?: GamificationProfileUpdatebadgesInput | string[];
    lastActivityAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type XpEventUpsertWithWhereUniqueWithoutUserInput = {
    where: XpEventWhereUniqueInput;
    update: XOR<XpEventUpdateWithoutUserInput, XpEventUncheckedUpdateWithoutUserInput>;
    create: XOR<XpEventCreateWithoutUserInput, XpEventUncheckedCreateWithoutUserInput>;
  };

  export type XpEventUpdateWithWhereUniqueWithoutUserInput = {
    where: XpEventWhereUniqueInput;
    data: XOR<XpEventUpdateWithoutUserInput, XpEventUncheckedUpdateWithoutUserInput>;
  };

  export type XpEventUpdateManyWithWhereWithoutUserInput = {
    where: XpEventScalarWhereInput;
    data: XOR<XpEventUpdateManyMutationInput, XpEventUncheckedUpdateManyWithoutUserInput>;
  };

  export type XpEventScalarWhereInput = {
    AND?: XpEventScalarWhereInput | XpEventScalarWhereInput[];
    OR?: XpEventScalarWhereInput[];
    NOT?: XpEventScalarWhereInput | XpEventScalarWhereInput[];
    id?: StringFilter<'XpEvent'> | string;
    userId?: StringFilter<'XpEvent'> | string;
    eventType?: StringFilter<'XpEvent'> | string;
    points?: IntFilter<'XpEvent'> | number;
    refType?: StringNullableFilter<'XpEvent'> | string | null;
    refId?: StringNullableFilter<'XpEvent'> | string | null;
    metadata?: JsonNullableFilter<'XpEvent'>;
    createdAt?: DateTimeFilter<'XpEvent'> | Date | string;
  };

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput;
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>;
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>;
  };

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput;
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>;
  };

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput;
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>;
  };

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[];
    OR?: NotificationScalarWhereInput[];
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[];
    id?: StringFilter<'Notification'> | string;
    userId?: StringFilter<'Notification'> | string;
    type?: StringFilter<'Notification'> | string;
    data?: JsonFilter<'Notification'>;
    readAt?: DateTimeNullableFilter<'Notification'> | Date | string | null;
    createdAt?: DateTimeFilter<'Notification'> | Date | string;
  };

  export type ReportUpsertWithWhereUniqueWithoutReporterInput = {
    where: ReportWhereUniqueInput;
    update: XOR<ReportUpdateWithoutReporterInput, ReportUncheckedUpdateWithoutReporterInput>;
    create: XOR<ReportCreateWithoutReporterInput, ReportUncheckedCreateWithoutReporterInput>;
  };

  export type ReportUpdateWithWhereUniqueWithoutReporterInput = {
    where: ReportWhereUniqueInput;
    data: XOR<ReportUpdateWithoutReporterInput, ReportUncheckedUpdateWithoutReporterInput>;
  };

  export type ReportUpdateManyWithWhereWithoutReporterInput = {
    where: ReportScalarWhereInput;
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyWithoutReporterInput>;
  };

  export type ReportScalarWhereInput = {
    AND?: ReportScalarWhereInput | ReportScalarWhereInput[];
    OR?: ReportScalarWhereInput[];
    NOT?: ReportScalarWhereInput | ReportScalarWhereInput[];
    id?: StringFilter<'Report'> | string;
    reporterId?: StringFilter<'Report'> | string;
    entityType?: StringFilter<'Report'> | string;
    entityId?: StringFilter<'Report'> | string;
    reason?: StringFilter<'Report'> | string;
    status?: EnumReportStatusFilter<'Report'> | $Enums.ReportStatus;
    resolution?: StringNullableFilter<'Report'> | string | null;
    createdAt?: DateTimeFilter<'Report'> | Date | string;
    updatedAt?: DateTimeFilter<'Report'> | Date | string;
  };

  export type FileUpsertWithWhereUniqueWithoutUploadedByInput = {
    where: FileWhereUniqueInput;
    update: XOR<FileUpdateWithoutUploadedByInput, FileUncheckedUpdateWithoutUploadedByInput>;
    create: XOR<FileCreateWithoutUploadedByInput, FileUncheckedCreateWithoutUploadedByInput>;
  };

  export type FileUpdateWithWhereUniqueWithoutUploadedByInput = {
    where: FileWhereUniqueInput;
    data: XOR<FileUpdateWithoutUploadedByInput, FileUncheckedUpdateWithoutUploadedByInput>;
  };

  export type FileUpdateManyWithWhereWithoutUploadedByInput = {
    where: FileScalarWhereInput;
    data: XOR<FileUpdateManyMutationInput, FileUncheckedUpdateManyWithoutUploadedByInput>;
  };

  export type FileScalarWhereInput = {
    AND?: FileScalarWhereInput | FileScalarWhereInput[];
    OR?: FileScalarWhereInput[];
    NOT?: FileScalarWhereInput | FileScalarWhereInput[];
    id?: StringFilter<'File'> | string;
    filename?: StringFilter<'File'> | string;
    mimetype?: StringFilter<'File'> | string;
    size?: IntFilter<'File'> | number;
    key?: StringFilter<'File'> | string;
    url?: StringFilter<'File'> | string;
    type?: StringFilter<'File'> | string;
    uploadedById?: StringFilter<'File'> | string;
    entityId?: StringNullableFilter<'File'> | string | null;
    entityType?: StringNullableFilter<'File'> | string | null;
    createdAt?: DateTimeFilter<'File'> | Date | string;
    updatedAt?: DateTimeFilter<'File'> | Date | string;
    deletedAt?: DateTimeNullableFilter<'File'> | Date | string | null;
  };

  export type ChallengeUpsertWithWhereUniqueWithoutOwnerInput = {
    where: ChallengeWhereUniqueInput;
    update: XOR<ChallengeUpdateWithoutOwnerInput, ChallengeUncheckedUpdateWithoutOwnerInput>;
    create: XOR<ChallengeCreateWithoutOwnerInput, ChallengeUncheckedCreateWithoutOwnerInput>;
  };

  export type ChallengeUpdateWithWhereUniqueWithoutOwnerInput = {
    where: ChallengeWhereUniqueInput;
    data: XOR<ChallengeUpdateWithoutOwnerInput, ChallengeUncheckedUpdateWithoutOwnerInput>;
  };

  export type ChallengeUpdateManyWithWhereWithoutOwnerInput = {
    where: ChallengeScalarWhereInput;
    data: XOR<ChallengeUpdateManyMutationInput, ChallengeUncheckedUpdateManyWithoutOwnerInput>;
  };

  export type ChallengeScalarWhereInput = {
    AND?: ChallengeScalarWhereInput | ChallengeScalarWhereInput[];
    OR?: ChallengeScalarWhereInput[];
    NOT?: ChallengeScalarWhereInput | ChallengeScalarWhereInput[];
    id?: StringFilter<'Challenge'> | string;
    slug?: StringFilter<'Challenge'> | string;
    title?: StringFilter<'Challenge'> | string;
    problemStatement?: StringFilter<'Challenge'> | string;
    ownerId?: StringFilter<'Challenge'> | string;
    ownerOrg?: StringNullableFilter<'Challenge'> | string | null;
    rewardType?: EnumRewardTypeNullableFilter<'Challenge'> | $Enums.RewardType | null;
    rewardValue?: StringNullableFilter<'Challenge'> | string | null;
    categories?: StringNullableListFilter<'Challenge'>;
    skills?: StringNullableListFilter<'Challenge'>;
    attachments?: StringNullableListFilter<'Challenge'>;
    status?: EnumChallengeStatusFilter<'Challenge'> | $Enums.ChallengeStatus;
    visibility?: EnumChallengeVisibilityFilter<'Challenge'> | $Enums.ChallengeVisibility;
    deadlineAt?: DateTimeNullableFilter<'Challenge'> | Date | string | null;
    createdAt?: DateTimeFilter<'Challenge'> | Date | string;
    updatedAt?: DateTimeFilter<'Challenge'> | Date | string;
  };

  export type UserCreateWithoutAccountsInput = {
    id?: string;
    email: string;
    emailVerified?: Date | string | null;
    name?: string | null;
    handle?: string | null;
    avatarUrl?: string | null;
    bio?: string | null;
    organization?: string | null;
    password?: string | null;
    roles?: UserCreaterolesInput | $Enums.Role[];
    totpSecret?: string | null;
    totpEnabled?: boolean;
    passwordResetToken?: string | null;
    passwordResetExpires?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastLoginAt?: Date | string | null;
    isActive?: boolean;
    isBanned?: boolean;
    sessions?: SessionCreateNestedManyWithoutUserInput;
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput;
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput;
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput;
    mentorProfiles?: MentorCreateNestedManyWithoutUserInput;
    judgeAssignments?: JudgeCreateNestedManyWithoutUserInput;
    challengeSubmissions?: ChallengeSubmissionCreateNestedManyWithoutUserInput;
    comments?: CommentCreateNestedManyWithoutAuthorInput;
    gamificationProfile?: GamificationProfileCreateNestedOneWithoutUserInput;
    xpEvents?: XpEventCreateNestedManyWithoutUserInput;
    notifications?: NotificationCreateNestedManyWithoutUserInput;
    reports?: ReportCreateNestedManyWithoutReporterInput;
    uploadedFiles?: FileCreateNestedManyWithoutUploadedByInput;
    ownedChallenges?: ChallengeCreateNestedManyWithoutOwnerInput;
  };

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string;
    email: string;
    emailVerified?: Date | string | null;
    name?: string | null;
    handle?: string | null;
    avatarUrl?: string | null;
    bio?: string | null;
    organization?: string | null;
    password?: string | null;
    roles?: UserCreaterolesInput | $Enums.Role[];
    totpSecret?: string | null;
    totpEnabled?: boolean;
    passwordResetToken?: string | null;
    passwordResetExpires?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastLoginAt?: Date | string | null;
    isActive?: boolean;
    isBanned?: boolean;
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput;
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput;
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput;
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput;
    mentorProfiles?: MentorUncheckedCreateNestedManyWithoutUserInput;
    judgeAssignments?: JudgeUncheckedCreateNestedManyWithoutUserInput;
    challengeSubmissions?: ChallengeSubmissionUncheckedCreateNestedManyWithoutUserInput;
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput;
    gamificationProfile?: GamificationProfileUncheckedCreateNestedOneWithoutUserInput;
    xpEvents?: XpEventUncheckedCreateNestedManyWithoutUserInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    reports?: ReportUncheckedCreateNestedManyWithoutReporterInput;
    uploadedFiles?: FileUncheckedCreateNestedManyWithoutUploadedByInput;
    ownedChallenges?: ChallengeUncheckedCreateNestedManyWithoutOwnerInput;
  };

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput;
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>;
  };

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>;
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput;
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>;
  };

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    handle?: NullableStringFieldUpdateOperationsInput | string | null;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    organization?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    roles?: UserUpdaterolesInput | $Enums.Role[];
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    totpEnabled?: BoolFieldUpdateOperationsInput | boolean;
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    isBanned?: BoolFieldUpdateOperationsInput | boolean;
    sessions?: SessionUpdateManyWithoutUserNestedInput;
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput;
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput;
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput;
    mentorProfiles?: MentorUpdateManyWithoutUserNestedInput;
    judgeAssignments?: JudgeUpdateManyWithoutUserNestedInput;
    challengeSubmissions?: ChallengeSubmissionUpdateManyWithoutUserNestedInput;
    comments?: CommentUpdateManyWithoutAuthorNestedInput;
    gamificationProfile?: GamificationProfileUpdateOneWithoutUserNestedInput;
    xpEvents?: XpEventUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUpdateManyWithoutUserNestedInput;
    reports?: ReportUpdateManyWithoutReporterNestedInput;
    uploadedFiles?: FileUpdateManyWithoutUploadedByNestedInput;
    ownedChallenges?: ChallengeUpdateManyWithoutOwnerNestedInput;
  };

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    handle?: NullableStringFieldUpdateOperationsInput | string | null;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    organization?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    roles?: UserUpdaterolesInput | $Enums.Role[];
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    totpEnabled?: BoolFieldUpdateOperationsInput | boolean;
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    isBanned?: BoolFieldUpdateOperationsInput | boolean;
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput;
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput;
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput;
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput;
    mentorProfiles?: MentorUncheckedUpdateManyWithoutUserNestedInput;
    judgeAssignments?: JudgeUncheckedUpdateManyWithoutUserNestedInput;
    challengeSubmissions?: ChallengeSubmissionUncheckedUpdateManyWithoutUserNestedInput;
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput;
    gamificationProfile?: GamificationProfileUncheckedUpdateOneWithoutUserNestedInput;
    xpEvents?: XpEventUncheckedUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    reports?: ReportUncheckedUpdateManyWithoutReporterNestedInput;
    uploadedFiles?: FileUncheckedUpdateManyWithoutUploadedByNestedInput;
    ownedChallenges?: ChallengeUncheckedUpdateManyWithoutOwnerNestedInput;
  };

  export type UserCreateWithoutSessionsInput = {
    id?: string;
    email: string;
    emailVerified?: Date | string | null;
    name?: string | null;
    handle?: string | null;
    avatarUrl?: string | null;
    bio?: string | null;
    organization?: string | null;
    password?: string | null;
    roles?: UserCreaterolesInput | $Enums.Role[];
    totpSecret?: string | null;
    totpEnabled?: boolean;
    passwordResetToken?: string | null;
    passwordResetExpires?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastLoginAt?: Date | string | null;
    isActive?: boolean;
    isBanned?: boolean;
    accounts?: AccountCreateNestedManyWithoutUserInput;
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput;
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput;
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput;
    mentorProfiles?: MentorCreateNestedManyWithoutUserInput;
    judgeAssignments?: JudgeCreateNestedManyWithoutUserInput;
    challengeSubmissions?: ChallengeSubmissionCreateNestedManyWithoutUserInput;
    comments?: CommentCreateNestedManyWithoutAuthorInput;
    gamificationProfile?: GamificationProfileCreateNestedOneWithoutUserInput;
    xpEvents?: XpEventCreateNestedManyWithoutUserInput;
    notifications?: NotificationCreateNestedManyWithoutUserInput;
    reports?: ReportCreateNestedManyWithoutReporterInput;
    uploadedFiles?: FileCreateNestedManyWithoutUploadedByInput;
    ownedChallenges?: ChallengeCreateNestedManyWithoutOwnerInput;
  };

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string;
    email: string;
    emailVerified?: Date | string | null;
    name?: string | null;
    handle?: string | null;
    avatarUrl?: string | null;
    bio?: string | null;
    organization?: string | null;
    password?: string | null;
    roles?: UserCreaterolesInput | $Enums.Role[];
    totpSecret?: string | null;
    totpEnabled?: boolean;
    passwordResetToken?: string | null;
    passwordResetExpires?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastLoginAt?: Date | string | null;
    isActive?: boolean;
    isBanned?: boolean;
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput;
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput;
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput;
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput;
    mentorProfiles?: MentorUncheckedCreateNestedManyWithoutUserInput;
    judgeAssignments?: JudgeUncheckedCreateNestedManyWithoutUserInput;
    challengeSubmissions?: ChallengeSubmissionUncheckedCreateNestedManyWithoutUserInput;
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput;
    gamificationProfile?: GamificationProfileUncheckedCreateNestedOneWithoutUserInput;
    xpEvents?: XpEventUncheckedCreateNestedManyWithoutUserInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    reports?: ReportUncheckedCreateNestedManyWithoutReporterInput;
    uploadedFiles?: FileUncheckedCreateNestedManyWithoutUploadedByInput;
    ownedChallenges?: ChallengeUncheckedCreateNestedManyWithoutOwnerInput;
  };

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput;
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>;
  };

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>;
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput;
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>;
  };

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    handle?: NullableStringFieldUpdateOperationsInput | string | null;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    organization?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    roles?: UserUpdaterolesInput | $Enums.Role[];
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    totpEnabled?: BoolFieldUpdateOperationsInput | boolean;
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    isBanned?: BoolFieldUpdateOperationsInput | boolean;
    accounts?: AccountUpdateManyWithoutUserNestedInput;
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput;
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput;
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput;
    mentorProfiles?: MentorUpdateManyWithoutUserNestedInput;
    judgeAssignments?: JudgeUpdateManyWithoutUserNestedInput;
    challengeSubmissions?: ChallengeSubmissionUpdateManyWithoutUserNestedInput;
    comments?: CommentUpdateManyWithoutAuthorNestedInput;
    gamificationProfile?: GamificationProfileUpdateOneWithoutUserNestedInput;
    xpEvents?: XpEventUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUpdateManyWithoutUserNestedInput;
    reports?: ReportUpdateManyWithoutReporterNestedInput;
    uploadedFiles?: FileUpdateManyWithoutUploadedByNestedInput;
    ownedChallenges?: ChallengeUpdateManyWithoutOwnerNestedInput;
  };

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    handle?: NullableStringFieldUpdateOperationsInput | string | null;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    organization?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    roles?: UserUpdaterolesInput | $Enums.Role[];
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    totpEnabled?: BoolFieldUpdateOperationsInput | boolean;
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    isBanned?: BoolFieldUpdateOperationsInput | boolean;
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput;
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput;
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput;
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput;
    mentorProfiles?: MentorUncheckedUpdateManyWithoutUserNestedInput;
    judgeAssignments?: JudgeUncheckedUpdateManyWithoutUserNestedInput;
    challengeSubmissions?: ChallengeSubmissionUncheckedUpdateManyWithoutUserNestedInput;
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput;
    gamificationProfile?: GamificationProfileUncheckedUpdateOneWithoutUserNestedInput;
    xpEvents?: XpEventUncheckedUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    reports?: ReportUncheckedUpdateManyWithoutReporterNestedInput;
    uploadedFiles?: FileUncheckedUpdateManyWithoutUploadedByNestedInput;
    ownedChallenges?: ChallengeUncheckedUpdateManyWithoutOwnerNestedInput;
  };

  export type UserCreateWithoutApiKeysInput = {
    id?: string;
    email: string;
    emailVerified?: Date | string | null;
    name?: string | null;
    handle?: string | null;
    avatarUrl?: string | null;
    bio?: string | null;
    organization?: string | null;
    password?: string | null;
    roles?: UserCreaterolesInput | $Enums.Role[];
    totpSecret?: string | null;
    totpEnabled?: boolean;
    passwordResetToken?: string | null;
    passwordResetExpires?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastLoginAt?: Date | string | null;
    isActive?: boolean;
    isBanned?: boolean;
    accounts?: AccountCreateNestedManyWithoutUserInput;
    sessions?: SessionCreateNestedManyWithoutUserInput;
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput;
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput;
    mentorProfiles?: MentorCreateNestedManyWithoutUserInput;
    judgeAssignments?: JudgeCreateNestedManyWithoutUserInput;
    challengeSubmissions?: ChallengeSubmissionCreateNestedManyWithoutUserInput;
    comments?: CommentCreateNestedManyWithoutAuthorInput;
    gamificationProfile?: GamificationProfileCreateNestedOneWithoutUserInput;
    xpEvents?: XpEventCreateNestedManyWithoutUserInput;
    notifications?: NotificationCreateNestedManyWithoutUserInput;
    reports?: ReportCreateNestedManyWithoutReporterInput;
    uploadedFiles?: FileCreateNestedManyWithoutUploadedByInput;
    ownedChallenges?: ChallengeCreateNestedManyWithoutOwnerInput;
  };

  export type UserUncheckedCreateWithoutApiKeysInput = {
    id?: string;
    email: string;
    emailVerified?: Date | string | null;
    name?: string | null;
    handle?: string | null;
    avatarUrl?: string | null;
    bio?: string | null;
    organization?: string | null;
    password?: string | null;
    roles?: UserCreaterolesInput | $Enums.Role[];
    totpSecret?: string | null;
    totpEnabled?: boolean;
    passwordResetToken?: string | null;
    passwordResetExpires?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastLoginAt?: Date | string | null;
    isActive?: boolean;
    isBanned?: boolean;
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput;
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput;
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput;
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput;
    mentorProfiles?: MentorUncheckedCreateNestedManyWithoutUserInput;
    judgeAssignments?: JudgeUncheckedCreateNestedManyWithoutUserInput;
    challengeSubmissions?: ChallengeSubmissionUncheckedCreateNestedManyWithoutUserInput;
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput;
    gamificationProfile?: GamificationProfileUncheckedCreateNestedOneWithoutUserInput;
    xpEvents?: XpEventUncheckedCreateNestedManyWithoutUserInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    reports?: ReportUncheckedCreateNestedManyWithoutReporterInput;
    uploadedFiles?: FileUncheckedCreateNestedManyWithoutUploadedByInput;
    ownedChallenges?: ChallengeUncheckedCreateNestedManyWithoutOwnerInput;
  };

  export type UserCreateOrConnectWithoutApiKeysInput = {
    where: UserWhereUniqueInput;
    create: XOR<UserCreateWithoutApiKeysInput, UserUncheckedCreateWithoutApiKeysInput>;
  };

  export type UserUpsertWithoutApiKeysInput = {
    update: XOR<UserUpdateWithoutApiKeysInput, UserUncheckedUpdateWithoutApiKeysInput>;
    create: XOR<UserCreateWithoutApiKeysInput, UserUncheckedCreateWithoutApiKeysInput>;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutApiKeysInput = {
    where?: UserWhereInput;
    data: XOR<UserUpdateWithoutApiKeysInput, UserUncheckedUpdateWithoutApiKeysInput>;
  };

  export type UserUpdateWithoutApiKeysInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    handle?: NullableStringFieldUpdateOperationsInput | string | null;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    organization?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    roles?: UserUpdaterolesInput | $Enums.Role[];
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    totpEnabled?: BoolFieldUpdateOperationsInput | boolean;
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    isBanned?: BoolFieldUpdateOperationsInput | boolean;
    accounts?: AccountUpdateManyWithoutUserNestedInput;
    sessions?: SessionUpdateManyWithoutUserNestedInput;
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput;
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput;
    mentorProfiles?: MentorUpdateManyWithoutUserNestedInput;
    judgeAssignments?: JudgeUpdateManyWithoutUserNestedInput;
    challengeSubmissions?: ChallengeSubmissionUpdateManyWithoutUserNestedInput;
    comments?: CommentUpdateManyWithoutAuthorNestedInput;
    gamificationProfile?: GamificationProfileUpdateOneWithoutUserNestedInput;
    xpEvents?: XpEventUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUpdateManyWithoutUserNestedInput;
    reports?: ReportUpdateManyWithoutReporterNestedInput;
    uploadedFiles?: FileUpdateManyWithoutUploadedByNestedInput;
    ownedChallenges?: ChallengeUpdateManyWithoutOwnerNestedInput;
  };

  export type UserUncheckedUpdateWithoutApiKeysInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    handle?: NullableStringFieldUpdateOperationsInput | string | null;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    organization?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    roles?: UserUpdaterolesInput | $Enums.Role[];
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    totpEnabled?: BoolFieldUpdateOperationsInput | boolean;
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    isBanned?: BoolFieldUpdateOperationsInput | boolean;
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput;
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput;
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput;
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput;
    mentorProfiles?: MentorUncheckedUpdateManyWithoutUserNestedInput;
    judgeAssignments?: JudgeUncheckedUpdateManyWithoutUserNestedInput;
    challengeSubmissions?: ChallengeSubmissionUncheckedUpdateManyWithoutUserNestedInput;
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput;
    gamificationProfile?: GamificationProfileUncheckedUpdateOneWithoutUserNestedInput;
    xpEvents?: XpEventUncheckedUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    reports?: ReportUncheckedUpdateManyWithoutReporterNestedInput;
    uploadedFiles?: FileUncheckedUpdateManyWithoutUploadedByNestedInput;
    ownedChallenges?: ChallengeUncheckedUpdateManyWithoutOwnerNestedInput;
  };

  export type UserCreateWithoutAuditLogsInput = {
    id?: string;
    email: string;
    emailVerified?: Date | string | null;
    name?: string | null;
    handle?: string | null;
    avatarUrl?: string | null;
    bio?: string | null;
    organization?: string | null;
    password?: string | null;
    roles?: UserCreaterolesInput | $Enums.Role[];
    totpSecret?: string | null;
    totpEnabled?: boolean;
    passwordResetToken?: string | null;
    passwordResetExpires?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastLoginAt?: Date | string | null;
    isActive?: boolean;
    isBanned?: boolean;
    accounts?: AccountCreateNestedManyWithoutUserInput;
    sessions?: SessionCreateNestedManyWithoutUserInput;
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput;
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput;
    mentorProfiles?: MentorCreateNestedManyWithoutUserInput;
    judgeAssignments?: JudgeCreateNestedManyWithoutUserInput;
    challengeSubmissions?: ChallengeSubmissionCreateNestedManyWithoutUserInput;
    comments?: CommentCreateNestedManyWithoutAuthorInput;
    gamificationProfile?: GamificationProfileCreateNestedOneWithoutUserInput;
    xpEvents?: XpEventCreateNestedManyWithoutUserInput;
    notifications?: NotificationCreateNestedManyWithoutUserInput;
    reports?: ReportCreateNestedManyWithoutReporterInput;
    uploadedFiles?: FileCreateNestedManyWithoutUploadedByInput;
    ownedChallenges?: ChallengeCreateNestedManyWithoutOwnerInput;
  };

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: string;
    email: string;
    emailVerified?: Date | string | null;
    name?: string | null;
    handle?: string | null;
    avatarUrl?: string | null;
    bio?: string | null;
    organization?: string | null;
    password?: string | null;
    roles?: UserCreaterolesInput | $Enums.Role[];
    totpSecret?: string | null;
    totpEnabled?: boolean;
    passwordResetToken?: string | null;
    passwordResetExpires?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastLoginAt?: Date | string | null;
    isActive?: boolean;
    isBanned?: boolean;
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput;
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput;
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput;
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput;
    mentorProfiles?: MentorUncheckedCreateNestedManyWithoutUserInput;
    judgeAssignments?: JudgeUncheckedCreateNestedManyWithoutUserInput;
    challengeSubmissions?: ChallengeSubmissionUncheckedCreateNestedManyWithoutUserInput;
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput;
    gamificationProfile?: GamificationProfileUncheckedCreateNestedOneWithoutUserInput;
    xpEvents?: XpEventUncheckedCreateNestedManyWithoutUserInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    reports?: ReportUncheckedCreateNestedManyWithoutReporterInput;
    uploadedFiles?: FileUncheckedCreateNestedManyWithoutUploadedByInput;
    ownedChallenges?: ChallengeUncheckedCreateNestedManyWithoutOwnerInput;
  };

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput;
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>;
  };

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>;
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput;
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>;
  };

  export type UserUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    handle?: NullableStringFieldUpdateOperationsInput | string | null;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    organization?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    roles?: UserUpdaterolesInput | $Enums.Role[];
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    totpEnabled?: BoolFieldUpdateOperationsInput | boolean;
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    isBanned?: BoolFieldUpdateOperationsInput | boolean;
    accounts?: AccountUpdateManyWithoutUserNestedInput;
    sessions?: SessionUpdateManyWithoutUserNestedInput;
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput;
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput;
    mentorProfiles?: MentorUpdateManyWithoutUserNestedInput;
    judgeAssignments?: JudgeUpdateManyWithoutUserNestedInput;
    challengeSubmissions?: ChallengeSubmissionUpdateManyWithoutUserNestedInput;
    comments?: CommentUpdateManyWithoutAuthorNestedInput;
    gamificationProfile?: GamificationProfileUpdateOneWithoutUserNestedInput;
    xpEvents?: XpEventUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUpdateManyWithoutUserNestedInput;
    reports?: ReportUpdateManyWithoutReporterNestedInput;
    uploadedFiles?: FileUpdateManyWithoutUploadedByNestedInput;
    ownedChallenges?: ChallengeUpdateManyWithoutOwnerNestedInput;
  };

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    handle?: NullableStringFieldUpdateOperationsInput | string | null;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    organization?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    roles?: UserUpdaterolesInput | $Enums.Role[];
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    totpEnabled?: BoolFieldUpdateOperationsInput | boolean;
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    isBanned?: BoolFieldUpdateOperationsInput | boolean;
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput;
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput;
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput;
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput;
    mentorProfiles?: MentorUncheckedUpdateManyWithoutUserNestedInput;
    judgeAssignments?: JudgeUncheckedUpdateManyWithoutUserNestedInput;
    challengeSubmissions?: ChallengeSubmissionUncheckedUpdateManyWithoutUserNestedInput;
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput;
    gamificationProfile?: GamificationProfileUncheckedUpdateOneWithoutUserNestedInput;
    xpEvents?: XpEventUncheckedUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    reports?: ReportUncheckedUpdateManyWithoutReporterNestedInput;
    uploadedFiles?: FileUncheckedUpdateManyWithoutUploadedByNestedInput;
    ownedChallenges?: ChallengeUncheckedUpdateManyWithoutOwnerNestedInput;
  };

  export type TrackCreateWithoutHackathonInput = {
    id?: string;
    title: string;
    description?: string | null;
    order?: number;
    createdAt?: Date | string;
    submissions?: SubmissionCreateNestedManyWithoutTrackInput;
  };

  export type TrackUncheckedCreateWithoutHackathonInput = {
    id?: string;
    title: string;
    description?: string | null;
    order?: number;
    createdAt?: Date | string;
    submissions?: SubmissionUncheckedCreateNestedManyWithoutTrackInput;
  };

  export type TrackCreateOrConnectWithoutHackathonInput = {
    where: TrackWhereUniqueInput;
    create: XOR<TrackCreateWithoutHackathonInput, TrackUncheckedCreateWithoutHackathonInput>;
  };

  export type TrackCreateManyHackathonInputEnvelope = {
    data: TrackCreateManyHackathonInput | TrackCreateManyHackathonInput[];
    skipDuplicates?: boolean;
  };

  export type TeamCreateWithoutHackathonInput = {
    id?: string;
    name: string;
    bio?: string | null;
    logoUrl?: string | null;
    repoUrl?: string | null;
    demoUrl?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    members?: TeamMemberCreateNestedManyWithoutTeamInput;
    submissions?: SubmissionCreateNestedManyWithoutTeamInput;
    challengeSubmissions?: ChallengeSubmissionCreateNestedManyWithoutTeamInput;
  };

  export type TeamUncheckedCreateWithoutHackathonInput = {
    id?: string;
    name: string;
    bio?: string | null;
    logoUrl?: string | null;
    repoUrl?: string | null;
    demoUrl?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    members?: TeamMemberUncheckedCreateNestedManyWithoutTeamInput;
    submissions?: SubmissionUncheckedCreateNestedManyWithoutTeamInput;
    challengeSubmissions?: ChallengeSubmissionUncheckedCreateNestedManyWithoutTeamInput;
  };

  export type TeamCreateOrConnectWithoutHackathonInput = {
    where: TeamWhereUniqueInput;
    create: XOR<TeamCreateWithoutHackathonInput, TeamUncheckedCreateWithoutHackathonInput>;
  };

  export type TeamCreateManyHackathonInputEnvelope = {
    data: TeamCreateManyHackathonInput | TeamCreateManyHackathonInput[];
    skipDuplicates?: boolean;
  };

  export type MentorCreateWithoutHackathonInput = {
    id?: string;
    bio?: string | null;
    calendlyUrl?: string | null;
    expertise?: MentorCreateexpertiseInput | string[];
    createdAt?: Date | string;
    user: UserCreateNestedOneWithoutMentorProfilesInput;
    sessions?: MentorSessionCreateNestedManyWithoutMentorInput;
  };

  export type MentorUncheckedCreateWithoutHackathonInput = {
    id?: string;
    userId: string;
    bio?: string | null;
    calendlyUrl?: string | null;
    expertise?: MentorCreateexpertiseInput | string[];
    createdAt?: Date | string;
    sessions?: MentorSessionUncheckedCreateNestedManyWithoutMentorInput;
  };

  export type MentorCreateOrConnectWithoutHackathonInput = {
    where: MentorWhereUniqueInput;
    create: XOR<MentorCreateWithoutHackathonInput, MentorUncheckedCreateWithoutHackathonInput>;
  };

  export type MentorCreateManyHackathonInputEnvelope = {
    data: MentorCreateManyHackathonInput | MentorCreateManyHackathonInput[];
    skipDuplicates?: boolean;
  };

  export type JudgeCreateWithoutHackathonInput = {
    id?: string;
    bio?: string | null;
    createdAt?: Date | string;
    user: UserCreateNestedOneWithoutJudgeAssignmentsInput;
    scores?: ScoreCreateNestedManyWithoutJudgeInput;
  };

  export type JudgeUncheckedCreateWithoutHackathonInput = {
    id?: string;
    userId: string;
    bio?: string | null;
    createdAt?: Date | string;
    scores?: ScoreUncheckedCreateNestedManyWithoutJudgeInput;
  };

  export type JudgeCreateOrConnectWithoutHackathonInput = {
    where: JudgeWhereUniqueInput;
    create: XOR<JudgeCreateWithoutHackathonInput, JudgeUncheckedCreateWithoutHackathonInput>;
  };

  export type JudgeCreateManyHackathonInputEnvelope = {
    data: JudgeCreateManyHackathonInput | JudgeCreateManyHackathonInput[];
    skipDuplicates?: boolean;
  };

  export type CriteriaCreateWithoutHackathonInput = {
    id?: string;
    name: string;
    description?: string | null;
    maxScore?: number;
    weight?: Decimal | DecimalJsLike | number | string;
    order?: number;
    scores?: ScoreCreateNestedManyWithoutCriterionInput;
  };

  export type CriteriaUncheckedCreateWithoutHackathonInput = {
    id?: string;
    name: string;
    description?: string | null;
    maxScore?: number;
    weight?: Decimal | DecimalJsLike | number | string;
    order?: number;
    scores?: ScoreUncheckedCreateNestedManyWithoutCriterionInput;
  };

  export type CriteriaCreateOrConnectWithoutHackathonInput = {
    where: CriteriaWhereUniqueInput;
    create: XOR<CriteriaCreateWithoutHackathonInput, CriteriaUncheckedCreateWithoutHackathonInput>;
  };

  export type CriteriaCreateManyHackathonInputEnvelope = {
    data: CriteriaCreateManyHackathonInput | CriteriaCreateManyHackathonInput[];
    skipDuplicates?: boolean;
  };

  export type SubmissionCreateWithoutHackathonInput = {
    id?: string;
    title: string;
    abstract: string;
    repoUrl?: string | null;
    demoUrl?: string | null;
    videoUrl?: string | null;
    files?: SubmissionCreatefilesInput | string[];
    submittedAt?: Date | string | null;
    finalizedAt?: Date | string | null;
    status?: $Enums.SubmissionStatus;
    scoreAggregate?: Decimal | DecimalJsLike | number | string | null;
    rank?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    team: TeamCreateNestedOneWithoutSubmissionsInput;
    track?: TrackCreateNestedOneWithoutSubmissionsInput;
    scores?: ScoreCreateNestedManyWithoutSubmissionInput;
  };

  export type SubmissionUncheckedCreateWithoutHackathonInput = {
    id?: string;
    teamId: string;
    trackId?: string | null;
    title: string;
    abstract: string;
    repoUrl?: string | null;
    demoUrl?: string | null;
    videoUrl?: string | null;
    files?: SubmissionCreatefilesInput | string[];
    submittedAt?: Date | string | null;
    finalizedAt?: Date | string | null;
    status?: $Enums.SubmissionStatus;
    scoreAggregate?: Decimal | DecimalJsLike | number | string | null;
    rank?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    scores?: ScoreUncheckedCreateNestedManyWithoutSubmissionInput;
  };

  export type SubmissionCreateOrConnectWithoutHackathonInput = {
    where: SubmissionWhereUniqueInput;
    create: XOR<
      SubmissionCreateWithoutHackathonInput,
      SubmissionUncheckedCreateWithoutHackathonInput
    >;
  };

  export type SubmissionCreateManyHackathonInputEnvelope = {
    data: SubmissionCreateManyHackathonInput | SubmissionCreateManyHackathonInput[];
    skipDuplicates?: boolean;
  };

  export type AnnouncementCreateWithoutHackathonInput = {
    id?: string;
    scope: $Enums.AnnouncementScope;
    title: string;
    body: string;
    pinned?: boolean;
    publishedAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type AnnouncementUncheckedCreateWithoutHackathonInput = {
    id?: string;
    scope: $Enums.AnnouncementScope;
    title: string;
    body: string;
    pinned?: boolean;
    publishedAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type AnnouncementCreateOrConnectWithoutHackathonInput = {
    where: AnnouncementWhereUniqueInput;
    create: XOR<
      AnnouncementCreateWithoutHackathonInput,
      AnnouncementUncheckedCreateWithoutHackathonInput
    >;
  };

  export type AnnouncementCreateManyHackathonInputEnvelope = {
    data: AnnouncementCreateManyHackathonInput | AnnouncementCreateManyHackathonInput[];
    skipDuplicates?: boolean;
  };

  export type TrackUpsertWithWhereUniqueWithoutHackathonInput = {
    where: TrackWhereUniqueInput;
    update: XOR<TrackUpdateWithoutHackathonInput, TrackUncheckedUpdateWithoutHackathonInput>;
    create: XOR<TrackCreateWithoutHackathonInput, TrackUncheckedCreateWithoutHackathonInput>;
  };

  export type TrackUpdateWithWhereUniqueWithoutHackathonInput = {
    where: TrackWhereUniqueInput;
    data: XOR<TrackUpdateWithoutHackathonInput, TrackUncheckedUpdateWithoutHackathonInput>;
  };

  export type TrackUpdateManyWithWhereWithoutHackathonInput = {
    where: TrackScalarWhereInput;
    data: XOR<TrackUpdateManyMutationInput, TrackUncheckedUpdateManyWithoutHackathonInput>;
  };

  export type TrackScalarWhereInput = {
    AND?: TrackScalarWhereInput | TrackScalarWhereInput[];
    OR?: TrackScalarWhereInput[];
    NOT?: TrackScalarWhereInput | TrackScalarWhereInput[];
    id?: StringFilter<'Track'> | string;
    hackathonId?: StringFilter<'Track'> | string;
    title?: StringFilter<'Track'> | string;
    description?: StringNullableFilter<'Track'> | string | null;
    order?: IntFilter<'Track'> | number;
    createdAt?: DateTimeFilter<'Track'> | Date | string;
  };

  export type TeamUpsertWithWhereUniqueWithoutHackathonInput = {
    where: TeamWhereUniqueInput;
    update: XOR<TeamUpdateWithoutHackathonInput, TeamUncheckedUpdateWithoutHackathonInput>;
    create: XOR<TeamCreateWithoutHackathonInput, TeamUncheckedCreateWithoutHackathonInput>;
  };

  export type TeamUpdateWithWhereUniqueWithoutHackathonInput = {
    where: TeamWhereUniqueInput;
    data: XOR<TeamUpdateWithoutHackathonInput, TeamUncheckedUpdateWithoutHackathonInput>;
  };

  export type TeamUpdateManyWithWhereWithoutHackathonInput = {
    where: TeamScalarWhereInput;
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyWithoutHackathonInput>;
  };

  export type TeamScalarWhereInput = {
    AND?: TeamScalarWhereInput | TeamScalarWhereInput[];
    OR?: TeamScalarWhereInput[];
    NOT?: TeamScalarWhereInput | TeamScalarWhereInput[];
    id?: StringFilter<'Team'> | string;
    hackathonId?: StringFilter<'Team'> | string;
    name?: StringFilter<'Team'> | string;
    bio?: StringNullableFilter<'Team'> | string | null;
    logoUrl?: StringNullableFilter<'Team'> | string | null;
    repoUrl?: StringNullableFilter<'Team'> | string | null;
    demoUrl?: StringNullableFilter<'Team'> | string | null;
    createdAt?: DateTimeFilter<'Team'> | Date | string;
    updatedAt?: DateTimeFilter<'Team'> | Date | string;
  };

  export type MentorUpsertWithWhereUniqueWithoutHackathonInput = {
    where: MentorWhereUniqueInput;
    update: XOR<MentorUpdateWithoutHackathonInput, MentorUncheckedUpdateWithoutHackathonInput>;
    create: XOR<MentorCreateWithoutHackathonInput, MentorUncheckedCreateWithoutHackathonInput>;
  };

  export type MentorUpdateWithWhereUniqueWithoutHackathonInput = {
    where: MentorWhereUniqueInput;
    data: XOR<MentorUpdateWithoutHackathonInput, MentorUncheckedUpdateWithoutHackathonInput>;
  };

  export type MentorUpdateManyWithWhereWithoutHackathonInput = {
    where: MentorScalarWhereInput;
    data: XOR<MentorUpdateManyMutationInput, MentorUncheckedUpdateManyWithoutHackathonInput>;
  };

  export type JudgeUpsertWithWhereUniqueWithoutHackathonInput = {
    where: JudgeWhereUniqueInput;
    update: XOR<JudgeUpdateWithoutHackathonInput, JudgeUncheckedUpdateWithoutHackathonInput>;
    create: XOR<JudgeCreateWithoutHackathonInput, JudgeUncheckedCreateWithoutHackathonInput>;
  };

  export type JudgeUpdateWithWhereUniqueWithoutHackathonInput = {
    where: JudgeWhereUniqueInput;
    data: XOR<JudgeUpdateWithoutHackathonInput, JudgeUncheckedUpdateWithoutHackathonInput>;
  };

  export type JudgeUpdateManyWithWhereWithoutHackathonInput = {
    where: JudgeScalarWhereInput;
    data: XOR<JudgeUpdateManyMutationInput, JudgeUncheckedUpdateManyWithoutHackathonInput>;
  };

  export type CriteriaUpsertWithWhereUniqueWithoutHackathonInput = {
    where: CriteriaWhereUniqueInput;
    update: XOR<CriteriaUpdateWithoutHackathonInput, CriteriaUncheckedUpdateWithoutHackathonInput>;
    create: XOR<CriteriaCreateWithoutHackathonInput, CriteriaUncheckedCreateWithoutHackathonInput>;
  };

  export type CriteriaUpdateWithWhereUniqueWithoutHackathonInput = {
    where: CriteriaWhereUniqueInput;
    data: XOR<CriteriaUpdateWithoutHackathonInput, CriteriaUncheckedUpdateWithoutHackathonInput>;
  };

  export type CriteriaUpdateManyWithWhereWithoutHackathonInput = {
    where: CriteriaScalarWhereInput;
    data: XOR<CriteriaUpdateManyMutationInput, CriteriaUncheckedUpdateManyWithoutHackathonInput>;
  };

  export type CriteriaScalarWhereInput = {
    AND?: CriteriaScalarWhereInput | CriteriaScalarWhereInput[];
    OR?: CriteriaScalarWhereInput[];
    NOT?: CriteriaScalarWhereInput | CriteriaScalarWhereInput[];
    id?: StringFilter<'Criteria'> | string;
    hackathonId?: StringFilter<'Criteria'> | string;
    name?: StringFilter<'Criteria'> | string;
    description?: StringNullableFilter<'Criteria'> | string | null;
    maxScore?: IntFilter<'Criteria'> | number;
    weight?: DecimalFilter<'Criteria'> | Decimal | DecimalJsLike | number | string;
    order?: IntFilter<'Criteria'> | number;
  };

  export type SubmissionUpsertWithWhereUniqueWithoutHackathonInput = {
    where: SubmissionWhereUniqueInput;
    update: XOR<
      SubmissionUpdateWithoutHackathonInput,
      SubmissionUncheckedUpdateWithoutHackathonInput
    >;
    create: XOR<
      SubmissionCreateWithoutHackathonInput,
      SubmissionUncheckedCreateWithoutHackathonInput
    >;
  };

  export type SubmissionUpdateWithWhereUniqueWithoutHackathonInput = {
    where: SubmissionWhereUniqueInput;
    data: XOR<
      SubmissionUpdateWithoutHackathonInput,
      SubmissionUncheckedUpdateWithoutHackathonInput
    >;
  };

  export type SubmissionUpdateManyWithWhereWithoutHackathonInput = {
    where: SubmissionScalarWhereInput;
    data: XOR<
      SubmissionUpdateManyMutationInput,
      SubmissionUncheckedUpdateManyWithoutHackathonInput
    >;
  };

  export type SubmissionScalarWhereInput = {
    AND?: SubmissionScalarWhereInput | SubmissionScalarWhereInput[];
    OR?: SubmissionScalarWhereInput[];
    NOT?: SubmissionScalarWhereInput | SubmissionScalarWhereInput[];
    id?: StringFilter<'Submission'> | string;
    hackathonId?: StringFilter<'Submission'> | string;
    teamId?: StringFilter<'Submission'> | string;
    trackId?: StringNullableFilter<'Submission'> | string | null;
    title?: StringFilter<'Submission'> | string;
    abstract?: StringFilter<'Submission'> | string;
    repoUrl?: StringNullableFilter<'Submission'> | string | null;
    demoUrl?: StringNullableFilter<'Submission'> | string | null;
    videoUrl?: StringNullableFilter<'Submission'> | string | null;
    files?: StringNullableListFilter<'Submission'>;
    submittedAt?: DateTimeNullableFilter<'Submission'> | Date | string | null;
    finalizedAt?: DateTimeNullableFilter<'Submission'> | Date | string | null;
    status?: EnumSubmissionStatusFilter<'Submission'> | $Enums.SubmissionStatus;
    scoreAggregate?:
      | DecimalNullableFilter<'Submission'>
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    rank?: IntNullableFilter<'Submission'> | number | null;
    createdAt?: DateTimeFilter<'Submission'> | Date | string;
    updatedAt?: DateTimeFilter<'Submission'> | Date | string;
  };

  export type AnnouncementUpsertWithWhereUniqueWithoutHackathonInput = {
    where: AnnouncementWhereUniqueInput;
    update: XOR<
      AnnouncementUpdateWithoutHackathonInput,
      AnnouncementUncheckedUpdateWithoutHackathonInput
    >;
    create: XOR<
      AnnouncementCreateWithoutHackathonInput,
      AnnouncementUncheckedCreateWithoutHackathonInput
    >;
  };

  export type AnnouncementUpdateWithWhereUniqueWithoutHackathonInput = {
    where: AnnouncementWhereUniqueInput;
    data: XOR<
      AnnouncementUpdateWithoutHackathonInput,
      AnnouncementUncheckedUpdateWithoutHackathonInput
    >;
  };

  export type AnnouncementUpdateManyWithWhereWithoutHackathonInput = {
    where: AnnouncementScalarWhereInput;
    data: XOR<
      AnnouncementUpdateManyMutationInput,
      AnnouncementUncheckedUpdateManyWithoutHackathonInput
    >;
  };

  export type AnnouncementScalarWhereInput = {
    AND?: AnnouncementScalarWhereInput | AnnouncementScalarWhereInput[];
    OR?: AnnouncementScalarWhereInput[];
    NOT?: AnnouncementScalarWhereInput | AnnouncementScalarWhereInput[];
    id?: StringFilter<'Announcement'> | string;
    scope?: EnumAnnouncementScopeFilter<'Announcement'> | $Enums.AnnouncementScope;
    scopeId?: StringNullableFilter<'Announcement'> | string | null;
    title?: StringFilter<'Announcement'> | string;
    body?: StringFilter<'Announcement'> | string;
    pinned?: BoolFilter<'Announcement'> | boolean;
    publishedAt?: DateTimeNullableFilter<'Announcement'> | Date | string | null;
    createdAt?: DateTimeFilter<'Announcement'> | Date | string;
    updatedAt?: DateTimeFilter<'Announcement'> | Date | string;
  };

  export type HackathonCreateWithoutTracksInput = {
    id?: string;
    slug: string;
    title: string;
    description: string;
    coverImage?: string | null;
    status?: $Enums.HackathonStatus;
    location?: $Enums.HackathonLocation;
    registrationOpensAt?: Date | string | null;
    registrationClosesAt?: Date | string | null;
    startsAt: Date | string;
    endsAt: Date | string;
    judgingEndsAt?: Date | string | null;
    prizePool?: Decimal | DecimalJsLike | number | string | null;
    maxTeamSize?: number;
    allowSoloTeams?: boolean;
    rules?: string | null;
    schedule?: NullableJsonNullValueInput | InputJsonValue;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    teams?: TeamCreateNestedManyWithoutHackathonInput;
    mentors?: MentorCreateNestedManyWithoutHackathonInput;
    judges?: JudgeCreateNestedManyWithoutHackathonInput;
    criteria?: CriteriaCreateNestedManyWithoutHackathonInput;
    submissions?: SubmissionCreateNestedManyWithoutHackathonInput;
    announcements?: AnnouncementCreateNestedManyWithoutHackathonInput;
  };

  export type HackathonUncheckedCreateWithoutTracksInput = {
    id?: string;
    slug: string;
    title: string;
    description: string;
    coverImage?: string | null;
    status?: $Enums.HackathonStatus;
    location?: $Enums.HackathonLocation;
    registrationOpensAt?: Date | string | null;
    registrationClosesAt?: Date | string | null;
    startsAt: Date | string;
    endsAt: Date | string;
    judgingEndsAt?: Date | string | null;
    prizePool?: Decimal | DecimalJsLike | number | string | null;
    maxTeamSize?: number;
    allowSoloTeams?: boolean;
    rules?: string | null;
    schedule?: NullableJsonNullValueInput | InputJsonValue;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    teams?: TeamUncheckedCreateNestedManyWithoutHackathonInput;
    mentors?: MentorUncheckedCreateNestedManyWithoutHackathonInput;
    judges?: JudgeUncheckedCreateNestedManyWithoutHackathonInput;
    criteria?: CriteriaUncheckedCreateNestedManyWithoutHackathonInput;
    submissions?: SubmissionUncheckedCreateNestedManyWithoutHackathonInput;
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutHackathonInput;
  };

  export type HackathonCreateOrConnectWithoutTracksInput = {
    where: HackathonWhereUniqueInput;
    create: XOR<HackathonCreateWithoutTracksInput, HackathonUncheckedCreateWithoutTracksInput>;
  };

  export type SubmissionCreateWithoutTrackInput = {
    id?: string;
    title: string;
    abstract: string;
    repoUrl?: string | null;
    demoUrl?: string | null;
    videoUrl?: string | null;
    files?: SubmissionCreatefilesInput | string[];
    submittedAt?: Date | string | null;
    finalizedAt?: Date | string | null;
    status?: $Enums.SubmissionStatus;
    scoreAggregate?: Decimal | DecimalJsLike | number | string | null;
    rank?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    hackathon: HackathonCreateNestedOneWithoutSubmissionsInput;
    team: TeamCreateNestedOneWithoutSubmissionsInput;
    scores?: ScoreCreateNestedManyWithoutSubmissionInput;
  };

  export type SubmissionUncheckedCreateWithoutTrackInput = {
    id?: string;
    hackathonId: string;
    teamId: string;
    title: string;
    abstract: string;
    repoUrl?: string | null;
    demoUrl?: string | null;
    videoUrl?: string | null;
    files?: SubmissionCreatefilesInput | string[];
    submittedAt?: Date | string | null;
    finalizedAt?: Date | string | null;
    status?: $Enums.SubmissionStatus;
    scoreAggregate?: Decimal | DecimalJsLike | number | string | null;
    rank?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    scores?: ScoreUncheckedCreateNestedManyWithoutSubmissionInput;
  };

  export type SubmissionCreateOrConnectWithoutTrackInput = {
    where: SubmissionWhereUniqueInput;
    create: XOR<SubmissionCreateWithoutTrackInput, SubmissionUncheckedCreateWithoutTrackInput>;
  };

  export type SubmissionCreateManyTrackInputEnvelope = {
    data: SubmissionCreateManyTrackInput | SubmissionCreateManyTrackInput[];
    skipDuplicates?: boolean;
  };

  export type HackathonUpsertWithoutTracksInput = {
    update: XOR<HackathonUpdateWithoutTracksInput, HackathonUncheckedUpdateWithoutTracksInput>;
    create: XOR<HackathonCreateWithoutTracksInput, HackathonUncheckedCreateWithoutTracksInput>;
    where?: HackathonWhereInput;
  };

  export type HackathonUpdateToOneWithWhereWithoutTracksInput = {
    where?: HackathonWhereInput;
    data: XOR<HackathonUpdateWithoutTracksInput, HackathonUncheckedUpdateWithoutTracksInput>;
  };

  export type HackathonUpdateWithoutTracksInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumHackathonStatusFieldUpdateOperationsInput | $Enums.HackathonStatus;
    location?: EnumHackathonLocationFieldUpdateOperationsInput | $Enums.HackathonLocation;
    registrationOpensAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    registrationClosesAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    judgingEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    prizePool?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    maxTeamSize?: IntFieldUpdateOperationsInput | number;
    allowSoloTeams?: BoolFieldUpdateOperationsInput | boolean;
    rules?: NullableStringFieldUpdateOperationsInput | string | null;
    schedule?: NullableJsonNullValueInput | InputJsonValue;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    teams?: TeamUpdateManyWithoutHackathonNestedInput;
    mentors?: MentorUpdateManyWithoutHackathonNestedInput;
    judges?: JudgeUpdateManyWithoutHackathonNestedInput;
    criteria?: CriteriaUpdateManyWithoutHackathonNestedInput;
    submissions?: SubmissionUpdateManyWithoutHackathonNestedInput;
    announcements?: AnnouncementUpdateManyWithoutHackathonNestedInput;
  };

  export type HackathonUncheckedUpdateWithoutTracksInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumHackathonStatusFieldUpdateOperationsInput | $Enums.HackathonStatus;
    location?: EnumHackathonLocationFieldUpdateOperationsInput | $Enums.HackathonLocation;
    registrationOpensAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    registrationClosesAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    judgingEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    prizePool?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    maxTeamSize?: IntFieldUpdateOperationsInput | number;
    allowSoloTeams?: BoolFieldUpdateOperationsInput | boolean;
    rules?: NullableStringFieldUpdateOperationsInput | string | null;
    schedule?: NullableJsonNullValueInput | InputJsonValue;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    teams?: TeamUncheckedUpdateManyWithoutHackathonNestedInput;
    mentors?: MentorUncheckedUpdateManyWithoutHackathonNestedInput;
    judges?: JudgeUncheckedUpdateManyWithoutHackathonNestedInput;
    criteria?: CriteriaUncheckedUpdateManyWithoutHackathonNestedInput;
    submissions?: SubmissionUncheckedUpdateManyWithoutHackathonNestedInput;
    announcements?: AnnouncementUncheckedUpdateManyWithoutHackathonNestedInput;
  };

  export type SubmissionUpsertWithWhereUniqueWithoutTrackInput = {
    where: SubmissionWhereUniqueInput;
    update: XOR<SubmissionUpdateWithoutTrackInput, SubmissionUncheckedUpdateWithoutTrackInput>;
    create: XOR<SubmissionCreateWithoutTrackInput, SubmissionUncheckedCreateWithoutTrackInput>;
  };

  export type SubmissionUpdateWithWhereUniqueWithoutTrackInput = {
    where: SubmissionWhereUniqueInput;
    data: XOR<SubmissionUpdateWithoutTrackInput, SubmissionUncheckedUpdateWithoutTrackInput>;
  };

  export type SubmissionUpdateManyWithWhereWithoutTrackInput = {
    where: SubmissionScalarWhereInput;
    data: XOR<SubmissionUpdateManyMutationInput, SubmissionUncheckedUpdateManyWithoutTrackInput>;
  };

  export type HackathonCreateWithoutTeamsInput = {
    id?: string;
    slug: string;
    title: string;
    description: string;
    coverImage?: string | null;
    status?: $Enums.HackathonStatus;
    location?: $Enums.HackathonLocation;
    registrationOpensAt?: Date | string | null;
    registrationClosesAt?: Date | string | null;
    startsAt: Date | string;
    endsAt: Date | string;
    judgingEndsAt?: Date | string | null;
    prizePool?: Decimal | DecimalJsLike | number | string | null;
    maxTeamSize?: number;
    allowSoloTeams?: boolean;
    rules?: string | null;
    schedule?: NullableJsonNullValueInput | InputJsonValue;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    tracks?: TrackCreateNestedManyWithoutHackathonInput;
    mentors?: MentorCreateNestedManyWithoutHackathonInput;
    judges?: JudgeCreateNestedManyWithoutHackathonInput;
    criteria?: CriteriaCreateNestedManyWithoutHackathonInput;
    submissions?: SubmissionCreateNestedManyWithoutHackathonInput;
    announcements?: AnnouncementCreateNestedManyWithoutHackathonInput;
  };

  export type HackathonUncheckedCreateWithoutTeamsInput = {
    id?: string;
    slug: string;
    title: string;
    description: string;
    coverImage?: string | null;
    status?: $Enums.HackathonStatus;
    location?: $Enums.HackathonLocation;
    registrationOpensAt?: Date | string | null;
    registrationClosesAt?: Date | string | null;
    startsAt: Date | string;
    endsAt: Date | string;
    judgingEndsAt?: Date | string | null;
    prizePool?: Decimal | DecimalJsLike | number | string | null;
    maxTeamSize?: number;
    allowSoloTeams?: boolean;
    rules?: string | null;
    schedule?: NullableJsonNullValueInput | InputJsonValue;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    tracks?: TrackUncheckedCreateNestedManyWithoutHackathonInput;
    mentors?: MentorUncheckedCreateNestedManyWithoutHackathonInput;
    judges?: JudgeUncheckedCreateNestedManyWithoutHackathonInput;
    criteria?: CriteriaUncheckedCreateNestedManyWithoutHackathonInput;
    submissions?: SubmissionUncheckedCreateNestedManyWithoutHackathonInput;
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutHackathonInput;
  };

  export type HackathonCreateOrConnectWithoutTeamsInput = {
    where: HackathonWhereUniqueInput;
    create: XOR<HackathonCreateWithoutTeamsInput, HackathonUncheckedCreateWithoutTeamsInput>;
  };

  export type TeamMemberCreateWithoutTeamInput = {
    role?: $Enums.TeamMemberRole;
    joinedAt?: Date | string;
    user: UserCreateNestedOneWithoutTeamMembershipsInput;
  };

  export type TeamMemberUncheckedCreateWithoutTeamInput = {
    userId: string;
    role?: $Enums.TeamMemberRole;
    joinedAt?: Date | string;
  };

  export type TeamMemberCreateOrConnectWithoutTeamInput = {
    where: TeamMemberWhereUniqueInput;
    create: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput>;
  };

  export type TeamMemberCreateManyTeamInputEnvelope = {
    data: TeamMemberCreateManyTeamInput | TeamMemberCreateManyTeamInput[];
    skipDuplicates?: boolean;
  };

  export type SubmissionCreateWithoutTeamInput = {
    id?: string;
    title: string;
    abstract: string;
    repoUrl?: string | null;
    demoUrl?: string | null;
    videoUrl?: string | null;
    files?: SubmissionCreatefilesInput | string[];
    submittedAt?: Date | string | null;
    finalizedAt?: Date | string | null;
    status?: $Enums.SubmissionStatus;
    scoreAggregate?: Decimal | DecimalJsLike | number | string | null;
    rank?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    hackathon: HackathonCreateNestedOneWithoutSubmissionsInput;
    track?: TrackCreateNestedOneWithoutSubmissionsInput;
    scores?: ScoreCreateNestedManyWithoutSubmissionInput;
  };

  export type SubmissionUncheckedCreateWithoutTeamInput = {
    id?: string;
    hackathonId: string;
    trackId?: string | null;
    title: string;
    abstract: string;
    repoUrl?: string | null;
    demoUrl?: string | null;
    videoUrl?: string | null;
    files?: SubmissionCreatefilesInput | string[];
    submittedAt?: Date | string | null;
    finalizedAt?: Date | string | null;
    status?: $Enums.SubmissionStatus;
    scoreAggregate?: Decimal | DecimalJsLike | number | string | null;
    rank?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    scores?: ScoreUncheckedCreateNestedManyWithoutSubmissionInput;
  };

  export type SubmissionCreateOrConnectWithoutTeamInput = {
    where: SubmissionWhereUniqueInput;
    create: XOR<SubmissionCreateWithoutTeamInput, SubmissionUncheckedCreateWithoutTeamInput>;
  };

  export type SubmissionCreateManyTeamInputEnvelope = {
    data: SubmissionCreateManyTeamInput | SubmissionCreateManyTeamInput[];
    skipDuplicates?: boolean;
  };

  export type ChallengeSubmissionCreateWithoutTeamInput = {
    id?: string;
    title: string;
    repoUrl?: string | null;
    content: string;
    files?: ChallengeSubmissionCreatefilesInput | string[];
    status?: $Enums.ChallengeSubmissionStatus;
    score?: Decimal | DecimalJsLike | number | string | null;
    feedback?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    challenge: ChallengeCreateNestedOneWithoutSubmissionsInput;
    user?: UserCreateNestedOneWithoutChallengeSubmissionsInput;
  };

  export type ChallengeSubmissionUncheckedCreateWithoutTeamInput = {
    id?: string;
    challengeId: string;
    userId?: string | null;
    title: string;
    repoUrl?: string | null;
    content: string;
    files?: ChallengeSubmissionCreatefilesInput | string[];
    status?: $Enums.ChallengeSubmissionStatus;
    score?: Decimal | DecimalJsLike | number | string | null;
    feedback?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ChallengeSubmissionCreateOrConnectWithoutTeamInput = {
    where: ChallengeSubmissionWhereUniqueInput;
    create: XOR<
      ChallengeSubmissionCreateWithoutTeamInput,
      ChallengeSubmissionUncheckedCreateWithoutTeamInput
    >;
  };

  export type ChallengeSubmissionCreateManyTeamInputEnvelope = {
    data: ChallengeSubmissionCreateManyTeamInput | ChallengeSubmissionCreateManyTeamInput[];
    skipDuplicates?: boolean;
  };

  export type HackathonUpsertWithoutTeamsInput = {
    update: XOR<HackathonUpdateWithoutTeamsInput, HackathonUncheckedUpdateWithoutTeamsInput>;
    create: XOR<HackathonCreateWithoutTeamsInput, HackathonUncheckedCreateWithoutTeamsInput>;
    where?: HackathonWhereInput;
  };

  export type HackathonUpdateToOneWithWhereWithoutTeamsInput = {
    where?: HackathonWhereInput;
    data: XOR<HackathonUpdateWithoutTeamsInput, HackathonUncheckedUpdateWithoutTeamsInput>;
  };

  export type HackathonUpdateWithoutTeamsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumHackathonStatusFieldUpdateOperationsInput | $Enums.HackathonStatus;
    location?: EnumHackathonLocationFieldUpdateOperationsInput | $Enums.HackathonLocation;
    registrationOpensAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    registrationClosesAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    judgingEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    prizePool?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    maxTeamSize?: IntFieldUpdateOperationsInput | number;
    allowSoloTeams?: BoolFieldUpdateOperationsInput | boolean;
    rules?: NullableStringFieldUpdateOperationsInput | string | null;
    schedule?: NullableJsonNullValueInput | InputJsonValue;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    tracks?: TrackUpdateManyWithoutHackathonNestedInput;
    mentors?: MentorUpdateManyWithoutHackathonNestedInput;
    judges?: JudgeUpdateManyWithoutHackathonNestedInput;
    criteria?: CriteriaUpdateManyWithoutHackathonNestedInput;
    submissions?: SubmissionUpdateManyWithoutHackathonNestedInput;
    announcements?: AnnouncementUpdateManyWithoutHackathonNestedInput;
  };

  export type HackathonUncheckedUpdateWithoutTeamsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumHackathonStatusFieldUpdateOperationsInput | $Enums.HackathonStatus;
    location?: EnumHackathonLocationFieldUpdateOperationsInput | $Enums.HackathonLocation;
    registrationOpensAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    registrationClosesAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    judgingEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    prizePool?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    maxTeamSize?: IntFieldUpdateOperationsInput | number;
    allowSoloTeams?: BoolFieldUpdateOperationsInput | boolean;
    rules?: NullableStringFieldUpdateOperationsInput | string | null;
    schedule?: NullableJsonNullValueInput | InputJsonValue;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    tracks?: TrackUncheckedUpdateManyWithoutHackathonNestedInput;
    mentors?: MentorUncheckedUpdateManyWithoutHackathonNestedInput;
    judges?: JudgeUncheckedUpdateManyWithoutHackathonNestedInput;
    criteria?: CriteriaUncheckedUpdateManyWithoutHackathonNestedInput;
    submissions?: SubmissionUncheckedUpdateManyWithoutHackathonNestedInput;
    announcements?: AnnouncementUncheckedUpdateManyWithoutHackathonNestedInput;
  };

  export type TeamMemberUpsertWithWhereUniqueWithoutTeamInput = {
    where: TeamMemberWhereUniqueInput;
    update: XOR<TeamMemberUpdateWithoutTeamInput, TeamMemberUncheckedUpdateWithoutTeamInput>;
    create: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput>;
  };

  export type TeamMemberUpdateWithWhereUniqueWithoutTeamInput = {
    where: TeamMemberWhereUniqueInput;
    data: XOR<TeamMemberUpdateWithoutTeamInput, TeamMemberUncheckedUpdateWithoutTeamInput>;
  };

  export type TeamMemberUpdateManyWithWhereWithoutTeamInput = {
    where: TeamMemberScalarWhereInput;
    data: XOR<TeamMemberUpdateManyMutationInput, TeamMemberUncheckedUpdateManyWithoutTeamInput>;
  };

  export type SubmissionUpsertWithWhereUniqueWithoutTeamInput = {
    where: SubmissionWhereUniqueInput;
    update: XOR<SubmissionUpdateWithoutTeamInput, SubmissionUncheckedUpdateWithoutTeamInput>;
    create: XOR<SubmissionCreateWithoutTeamInput, SubmissionUncheckedCreateWithoutTeamInput>;
  };

  export type SubmissionUpdateWithWhereUniqueWithoutTeamInput = {
    where: SubmissionWhereUniqueInput;
    data: XOR<SubmissionUpdateWithoutTeamInput, SubmissionUncheckedUpdateWithoutTeamInput>;
  };

  export type SubmissionUpdateManyWithWhereWithoutTeamInput = {
    where: SubmissionScalarWhereInput;
    data: XOR<SubmissionUpdateManyMutationInput, SubmissionUncheckedUpdateManyWithoutTeamInput>;
  };

  export type ChallengeSubmissionUpsertWithWhereUniqueWithoutTeamInput = {
    where: ChallengeSubmissionWhereUniqueInput;
    update: XOR<
      ChallengeSubmissionUpdateWithoutTeamInput,
      ChallengeSubmissionUncheckedUpdateWithoutTeamInput
    >;
    create: XOR<
      ChallengeSubmissionCreateWithoutTeamInput,
      ChallengeSubmissionUncheckedCreateWithoutTeamInput
    >;
  };

  export type ChallengeSubmissionUpdateWithWhereUniqueWithoutTeamInput = {
    where: ChallengeSubmissionWhereUniqueInput;
    data: XOR<
      ChallengeSubmissionUpdateWithoutTeamInput,
      ChallengeSubmissionUncheckedUpdateWithoutTeamInput
    >;
  };

  export type ChallengeSubmissionUpdateManyWithWhereWithoutTeamInput = {
    where: ChallengeSubmissionScalarWhereInput;
    data: XOR<
      ChallengeSubmissionUpdateManyMutationInput,
      ChallengeSubmissionUncheckedUpdateManyWithoutTeamInput
    >;
  };

  export type TeamCreateWithoutMembersInput = {
    id?: string;
    name: string;
    bio?: string | null;
    logoUrl?: string | null;
    repoUrl?: string | null;
    demoUrl?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    hackathon: HackathonCreateNestedOneWithoutTeamsInput;
    submissions?: SubmissionCreateNestedManyWithoutTeamInput;
    challengeSubmissions?: ChallengeSubmissionCreateNestedManyWithoutTeamInput;
  };

  export type TeamUncheckedCreateWithoutMembersInput = {
    id?: string;
    hackathonId: string;
    name: string;
    bio?: string | null;
    logoUrl?: string | null;
    repoUrl?: string | null;
    demoUrl?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    submissions?: SubmissionUncheckedCreateNestedManyWithoutTeamInput;
    challengeSubmissions?: ChallengeSubmissionUncheckedCreateNestedManyWithoutTeamInput;
  };

  export type TeamCreateOrConnectWithoutMembersInput = {
    where: TeamWhereUniqueInput;
    create: XOR<TeamCreateWithoutMembersInput, TeamUncheckedCreateWithoutMembersInput>;
  };

  export type UserCreateWithoutTeamMembershipsInput = {
    id?: string;
    email: string;
    emailVerified?: Date | string | null;
    name?: string | null;
    handle?: string | null;
    avatarUrl?: string | null;
    bio?: string | null;
    organization?: string | null;
    password?: string | null;
    roles?: UserCreaterolesInput | $Enums.Role[];
    totpSecret?: string | null;
    totpEnabled?: boolean;
    passwordResetToken?: string | null;
    passwordResetExpires?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastLoginAt?: Date | string | null;
    isActive?: boolean;
    isBanned?: boolean;
    accounts?: AccountCreateNestedManyWithoutUserInput;
    sessions?: SessionCreateNestedManyWithoutUserInput;
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput;
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput;
    mentorProfiles?: MentorCreateNestedManyWithoutUserInput;
    judgeAssignments?: JudgeCreateNestedManyWithoutUserInput;
    challengeSubmissions?: ChallengeSubmissionCreateNestedManyWithoutUserInput;
    comments?: CommentCreateNestedManyWithoutAuthorInput;
    gamificationProfile?: GamificationProfileCreateNestedOneWithoutUserInput;
    xpEvents?: XpEventCreateNestedManyWithoutUserInput;
    notifications?: NotificationCreateNestedManyWithoutUserInput;
    reports?: ReportCreateNestedManyWithoutReporterInput;
    uploadedFiles?: FileCreateNestedManyWithoutUploadedByInput;
    ownedChallenges?: ChallengeCreateNestedManyWithoutOwnerInput;
  };

  export type UserUncheckedCreateWithoutTeamMembershipsInput = {
    id?: string;
    email: string;
    emailVerified?: Date | string | null;
    name?: string | null;
    handle?: string | null;
    avatarUrl?: string | null;
    bio?: string | null;
    organization?: string | null;
    password?: string | null;
    roles?: UserCreaterolesInput | $Enums.Role[];
    totpSecret?: string | null;
    totpEnabled?: boolean;
    passwordResetToken?: string | null;
    passwordResetExpires?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastLoginAt?: Date | string | null;
    isActive?: boolean;
    isBanned?: boolean;
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput;
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput;
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput;
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput;
    mentorProfiles?: MentorUncheckedCreateNestedManyWithoutUserInput;
    judgeAssignments?: JudgeUncheckedCreateNestedManyWithoutUserInput;
    challengeSubmissions?: ChallengeSubmissionUncheckedCreateNestedManyWithoutUserInput;
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput;
    gamificationProfile?: GamificationProfileUncheckedCreateNestedOneWithoutUserInput;
    xpEvents?: XpEventUncheckedCreateNestedManyWithoutUserInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    reports?: ReportUncheckedCreateNestedManyWithoutReporterInput;
    uploadedFiles?: FileUncheckedCreateNestedManyWithoutUploadedByInput;
    ownedChallenges?: ChallengeUncheckedCreateNestedManyWithoutOwnerInput;
  };

  export type UserCreateOrConnectWithoutTeamMembershipsInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutTeamMembershipsInput,
      UserUncheckedCreateWithoutTeamMembershipsInput
    >;
  };

  export type TeamUpsertWithoutMembersInput = {
    update: XOR<TeamUpdateWithoutMembersInput, TeamUncheckedUpdateWithoutMembersInput>;
    create: XOR<TeamCreateWithoutMembersInput, TeamUncheckedCreateWithoutMembersInput>;
    where?: TeamWhereInput;
  };

  export type TeamUpdateToOneWithWhereWithoutMembersInput = {
    where?: TeamWhereInput;
    data: XOR<TeamUpdateWithoutMembersInput, TeamUncheckedUpdateWithoutMembersInput>;
  };

  export type TeamUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    repoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    demoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    hackathon?: HackathonUpdateOneRequiredWithoutTeamsNestedInput;
    submissions?: SubmissionUpdateManyWithoutTeamNestedInput;
    challengeSubmissions?: ChallengeSubmissionUpdateManyWithoutTeamNestedInput;
  };

  export type TeamUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string;
    hackathonId?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    repoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    demoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    submissions?: SubmissionUncheckedUpdateManyWithoutTeamNestedInput;
    challengeSubmissions?: ChallengeSubmissionUncheckedUpdateManyWithoutTeamNestedInput;
  };

  export type UserUpsertWithoutTeamMembershipsInput = {
    update: XOR<
      UserUpdateWithoutTeamMembershipsInput,
      UserUncheckedUpdateWithoutTeamMembershipsInput
    >;
    create: XOR<
      UserCreateWithoutTeamMembershipsInput,
      UserUncheckedCreateWithoutTeamMembershipsInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutTeamMembershipsInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutTeamMembershipsInput,
      UserUncheckedUpdateWithoutTeamMembershipsInput
    >;
  };

  export type UserUpdateWithoutTeamMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    handle?: NullableStringFieldUpdateOperationsInput | string | null;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    organization?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    roles?: UserUpdaterolesInput | $Enums.Role[];
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    totpEnabled?: BoolFieldUpdateOperationsInput | boolean;
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    isBanned?: BoolFieldUpdateOperationsInput | boolean;
    accounts?: AccountUpdateManyWithoutUserNestedInput;
    sessions?: SessionUpdateManyWithoutUserNestedInput;
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput;
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput;
    mentorProfiles?: MentorUpdateManyWithoutUserNestedInput;
    judgeAssignments?: JudgeUpdateManyWithoutUserNestedInput;
    challengeSubmissions?: ChallengeSubmissionUpdateManyWithoutUserNestedInput;
    comments?: CommentUpdateManyWithoutAuthorNestedInput;
    gamificationProfile?: GamificationProfileUpdateOneWithoutUserNestedInput;
    xpEvents?: XpEventUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUpdateManyWithoutUserNestedInput;
    reports?: ReportUpdateManyWithoutReporterNestedInput;
    uploadedFiles?: FileUpdateManyWithoutUploadedByNestedInput;
    ownedChallenges?: ChallengeUpdateManyWithoutOwnerNestedInput;
  };

  export type UserUncheckedUpdateWithoutTeamMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    handle?: NullableStringFieldUpdateOperationsInput | string | null;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    organization?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    roles?: UserUpdaterolesInput | $Enums.Role[];
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    totpEnabled?: BoolFieldUpdateOperationsInput | boolean;
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    isBanned?: BoolFieldUpdateOperationsInput | boolean;
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput;
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput;
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput;
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput;
    mentorProfiles?: MentorUncheckedUpdateManyWithoutUserNestedInput;
    judgeAssignments?: JudgeUncheckedUpdateManyWithoutUserNestedInput;
    challengeSubmissions?: ChallengeSubmissionUncheckedUpdateManyWithoutUserNestedInput;
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput;
    gamificationProfile?: GamificationProfileUncheckedUpdateOneWithoutUserNestedInput;
    xpEvents?: XpEventUncheckedUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    reports?: ReportUncheckedUpdateManyWithoutReporterNestedInput;
    uploadedFiles?: FileUncheckedUpdateManyWithoutUploadedByNestedInput;
    ownedChallenges?: ChallengeUncheckedUpdateManyWithoutOwnerNestedInput;
  };

  export type UserCreateWithoutMentorProfilesInput = {
    id?: string;
    email: string;
    emailVerified?: Date | string | null;
    name?: string | null;
    handle?: string | null;
    avatarUrl?: string | null;
    bio?: string | null;
    organization?: string | null;
    password?: string | null;
    roles?: UserCreaterolesInput | $Enums.Role[];
    totpSecret?: string | null;
    totpEnabled?: boolean;
    passwordResetToken?: string | null;
    passwordResetExpires?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastLoginAt?: Date | string | null;
    isActive?: boolean;
    isBanned?: boolean;
    accounts?: AccountCreateNestedManyWithoutUserInput;
    sessions?: SessionCreateNestedManyWithoutUserInput;
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput;
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput;
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput;
    judgeAssignments?: JudgeCreateNestedManyWithoutUserInput;
    challengeSubmissions?: ChallengeSubmissionCreateNestedManyWithoutUserInput;
    comments?: CommentCreateNestedManyWithoutAuthorInput;
    gamificationProfile?: GamificationProfileCreateNestedOneWithoutUserInput;
    xpEvents?: XpEventCreateNestedManyWithoutUserInput;
    notifications?: NotificationCreateNestedManyWithoutUserInput;
    reports?: ReportCreateNestedManyWithoutReporterInput;
    uploadedFiles?: FileCreateNestedManyWithoutUploadedByInput;
    ownedChallenges?: ChallengeCreateNestedManyWithoutOwnerInput;
  };

  export type UserUncheckedCreateWithoutMentorProfilesInput = {
    id?: string;
    email: string;
    emailVerified?: Date | string | null;
    name?: string | null;
    handle?: string | null;
    avatarUrl?: string | null;
    bio?: string | null;
    organization?: string | null;
    password?: string | null;
    roles?: UserCreaterolesInput | $Enums.Role[];
    totpSecret?: string | null;
    totpEnabled?: boolean;
    passwordResetToken?: string | null;
    passwordResetExpires?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastLoginAt?: Date | string | null;
    isActive?: boolean;
    isBanned?: boolean;
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput;
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput;
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput;
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput;
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput;
    judgeAssignments?: JudgeUncheckedCreateNestedManyWithoutUserInput;
    challengeSubmissions?: ChallengeSubmissionUncheckedCreateNestedManyWithoutUserInput;
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput;
    gamificationProfile?: GamificationProfileUncheckedCreateNestedOneWithoutUserInput;
    xpEvents?: XpEventUncheckedCreateNestedManyWithoutUserInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    reports?: ReportUncheckedCreateNestedManyWithoutReporterInput;
    uploadedFiles?: FileUncheckedCreateNestedManyWithoutUploadedByInput;
    ownedChallenges?: ChallengeUncheckedCreateNestedManyWithoutOwnerInput;
  };

  export type UserCreateOrConnectWithoutMentorProfilesInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutMentorProfilesInput,
      UserUncheckedCreateWithoutMentorProfilesInput
    >;
  };

  export type HackathonCreateWithoutMentorsInput = {
    id?: string;
    slug: string;
    title: string;
    description: string;
    coverImage?: string | null;
    status?: $Enums.HackathonStatus;
    location?: $Enums.HackathonLocation;
    registrationOpensAt?: Date | string | null;
    registrationClosesAt?: Date | string | null;
    startsAt: Date | string;
    endsAt: Date | string;
    judgingEndsAt?: Date | string | null;
    prizePool?: Decimal | DecimalJsLike | number | string | null;
    maxTeamSize?: number;
    allowSoloTeams?: boolean;
    rules?: string | null;
    schedule?: NullableJsonNullValueInput | InputJsonValue;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    tracks?: TrackCreateNestedManyWithoutHackathonInput;
    teams?: TeamCreateNestedManyWithoutHackathonInput;
    judges?: JudgeCreateNestedManyWithoutHackathonInput;
    criteria?: CriteriaCreateNestedManyWithoutHackathonInput;
    submissions?: SubmissionCreateNestedManyWithoutHackathonInput;
    announcements?: AnnouncementCreateNestedManyWithoutHackathonInput;
  };

  export type HackathonUncheckedCreateWithoutMentorsInput = {
    id?: string;
    slug: string;
    title: string;
    description: string;
    coverImage?: string | null;
    status?: $Enums.HackathonStatus;
    location?: $Enums.HackathonLocation;
    registrationOpensAt?: Date | string | null;
    registrationClosesAt?: Date | string | null;
    startsAt: Date | string;
    endsAt: Date | string;
    judgingEndsAt?: Date | string | null;
    prizePool?: Decimal | DecimalJsLike | number | string | null;
    maxTeamSize?: number;
    allowSoloTeams?: boolean;
    rules?: string | null;
    schedule?: NullableJsonNullValueInput | InputJsonValue;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    tracks?: TrackUncheckedCreateNestedManyWithoutHackathonInput;
    teams?: TeamUncheckedCreateNestedManyWithoutHackathonInput;
    judges?: JudgeUncheckedCreateNestedManyWithoutHackathonInput;
    criteria?: CriteriaUncheckedCreateNestedManyWithoutHackathonInput;
    submissions?: SubmissionUncheckedCreateNestedManyWithoutHackathonInput;
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutHackathonInput;
  };

  export type HackathonCreateOrConnectWithoutMentorsInput = {
    where: HackathonWhereUniqueInput;
    create: XOR<HackathonCreateWithoutMentorsInput, HackathonUncheckedCreateWithoutMentorsInput>;
  };

  export type MentorSessionCreateWithoutMentorInput = {
    id?: string;
    title?: string | null;
    startsAt: Date | string;
    endsAt: Date | string;
    capacity?: number;
    booked?: number;
    meetingUrl?: string | null;
    createdAt?: Date | string;
  };

  export type MentorSessionUncheckedCreateWithoutMentorInput = {
    id?: string;
    title?: string | null;
    startsAt: Date | string;
    endsAt: Date | string;
    capacity?: number;
    booked?: number;
    meetingUrl?: string | null;
    createdAt?: Date | string;
  };

  export type MentorSessionCreateOrConnectWithoutMentorInput = {
    where: MentorSessionWhereUniqueInput;
    create: XOR<
      MentorSessionCreateWithoutMentorInput,
      MentorSessionUncheckedCreateWithoutMentorInput
    >;
  };

  export type MentorSessionCreateManyMentorInputEnvelope = {
    data: MentorSessionCreateManyMentorInput | MentorSessionCreateManyMentorInput[];
    skipDuplicates?: boolean;
  };

  export type UserUpsertWithoutMentorProfilesInput = {
    update: XOR<
      UserUpdateWithoutMentorProfilesInput,
      UserUncheckedUpdateWithoutMentorProfilesInput
    >;
    create: XOR<
      UserCreateWithoutMentorProfilesInput,
      UserUncheckedCreateWithoutMentorProfilesInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutMentorProfilesInput = {
    where?: UserWhereInput;
    data: XOR<UserUpdateWithoutMentorProfilesInput, UserUncheckedUpdateWithoutMentorProfilesInput>;
  };

  export type UserUpdateWithoutMentorProfilesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    handle?: NullableStringFieldUpdateOperationsInput | string | null;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    organization?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    roles?: UserUpdaterolesInput | $Enums.Role[];
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    totpEnabled?: BoolFieldUpdateOperationsInput | boolean;
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    isBanned?: BoolFieldUpdateOperationsInput | boolean;
    accounts?: AccountUpdateManyWithoutUserNestedInput;
    sessions?: SessionUpdateManyWithoutUserNestedInput;
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput;
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput;
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput;
    judgeAssignments?: JudgeUpdateManyWithoutUserNestedInput;
    challengeSubmissions?: ChallengeSubmissionUpdateManyWithoutUserNestedInput;
    comments?: CommentUpdateManyWithoutAuthorNestedInput;
    gamificationProfile?: GamificationProfileUpdateOneWithoutUserNestedInput;
    xpEvents?: XpEventUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUpdateManyWithoutUserNestedInput;
    reports?: ReportUpdateManyWithoutReporterNestedInput;
    uploadedFiles?: FileUpdateManyWithoutUploadedByNestedInput;
    ownedChallenges?: ChallengeUpdateManyWithoutOwnerNestedInput;
  };

  export type UserUncheckedUpdateWithoutMentorProfilesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    handle?: NullableStringFieldUpdateOperationsInput | string | null;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    organization?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    roles?: UserUpdaterolesInput | $Enums.Role[];
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    totpEnabled?: BoolFieldUpdateOperationsInput | boolean;
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    isBanned?: BoolFieldUpdateOperationsInput | boolean;
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput;
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput;
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput;
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput;
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput;
    judgeAssignments?: JudgeUncheckedUpdateManyWithoutUserNestedInput;
    challengeSubmissions?: ChallengeSubmissionUncheckedUpdateManyWithoutUserNestedInput;
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput;
    gamificationProfile?: GamificationProfileUncheckedUpdateOneWithoutUserNestedInput;
    xpEvents?: XpEventUncheckedUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    reports?: ReportUncheckedUpdateManyWithoutReporterNestedInput;
    uploadedFiles?: FileUncheckedUpdateManyWithoutUploadedByNestedInput;
    ownedChallenges?: ChallengeUncheckedUpdateManyWithoutOwnerNestedInput;
  };

  export type HackathonUpsertWithoutMentorsInput = {
    update: XOR<HackathonUpdateWithoutMentorsInput, HackathonUncheckedUpdateWithoutMentorsInput>;
    create: XOR<HackathonCreateWithoutMentorsInput, HackathonUncheckedCreateWithoutMentorsInput>;
    where?: HackathonWhereInput;
  };

  export type HackathonUpdateToOneWithWhereWithoutMentorsInput = {
    where?: HackathonWhereInput;
    data: XOR<HackathonUpdateWithoutMentorsInput, HackathonUncheckedUpdateWithoutMentorsInput>;
  };

  export type HackathonUpdateWithoutMentorsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumHackathonStatusFieldUpdateOperationsInput | $Enums.HackathonStatus;
    location?: EnumHackathonLocationFieldUpdateOperationsInput | $Enums.HackathonLocation;
    registrationOpensAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    registrationClosesAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    judgingEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    prizePool?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    maxTeamSize?: IntFieldUpdateOperationsInput | number;
    allowSoloTeams?: BoolFieldUpdateOperationsInput | boolean;
    rules?: NullableStringFieldUpdateOperationsInput | string | null;
    schedule?: NullableJsonNullValueInput | InputJsonValue;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    tracks?: TrackUpdateManyWithoutHackathonNestedInput;
    teams?: TeamUpdateManyWithoutHackathonNestedInput;
    judges?: JudgeUpdateManyWithoutHackathonNestedInput;
    criteria?: CriteriaUpdateManyWithoutHackathonNestedInput;
    submissions?: SubmissionUpdateManyWithoutHackathonNestedInput;
    announcements?: AnnouncementUpdateManyWithoutHackathonNestedInput;
  };

  export type HackathonUncheckedUpdateWithoutMentorsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumHackathonStatusFieldUpdateOperationsInput | $Enums.HackathonStatus;
    location?: EnumHackathonLocationFieldUpdateOperationsInput | $Enums.HackathonLocation;
    registrationOpensAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    registrationClosesAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    judgingEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    prizePool?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    maxTeamSize?: IntFieldUpdateOperationsInput | number;
    allowSoloTeams?: BoolFieldUpdateOperationsInput | boolean;
    rules?: NullableStringFieldUpdateOperationsInput | string | null;
    schedule?: NullableJsonNullValueInput | InputJsonValue;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    tracks?: TrackUncheckedUpdateManyWithoutHackathonNestedInput;
    teams?: TeamUncheckedUpdateManyWithoutHackathonNestedInput;
    judges?: JudgeUncheckedUpdateManyWithoutHackathonNestedInput;
    criteria?: CriteriaUncheckedUpdateManyWithoutHackathonNestedInput;
    submissions?: SubmissionUncheckedUpdateManyWithoutHackathonNestedInput;
    announcements?: AnnouncementUncheckedUpdateManyWithoutHackathonNestedInput;
  };

  export type MentorSessionUpsertWithWhereUniqueWithoutMentorInput = {
    where: MentorSessionWhereUniqueInput;
    update: XOR<
      MentorSessionUpdateWithoutMentorInput,
      MentorSessionUncheckedUpdateWithoutMentorInput
    >;
    create: XOR<
      MentorSessionCreateWithoutMentorInput,
      MentorSessionUncheckedCreateWithoutMentorInput
    >;
  };

  export type MentorSessionUpdateWithWhereUniqueWithoutMentorInput = {
    where: MentorSessionWhereUniqueInput;
    data: XOR<
      MentorSessionUpdateWithoutMentorInput,
      MentorSessionUncheckedUpdateWithoutMentorInput
    >;
  };

  export type MentorSessionUpdateManyWithWhereWithoutMentorInput = {
    where: MentorSessionScalarWhereInput;
    data: XOR<
      MentorSessionUpdateManyMutationInput,
      MentorSessionUncheckedUpdateManyWithoutMentorInput
    >;
  };

  export type MentorSessionScalarWhereInput = {
    AND?: MentorSessionScalarWhereInput | MentorSessionScalarWhereInput[];
    OR?: MentorSessionScalarWhereInput[];
    NOT?: MentorSessionScalarWhereInput | MentorSessionScalarWhereInput[];
    id?: StringFilter<'MentorSession'> | string;
    mentorId?: StringFilter<'MentorSession'> | string;
    title?: StringNullableFilter<'MentorSession'> | string | null;
    startsAt?: DateTimeFilter<'MentorSession'> | Date | string;
    endsAt?: DateTimeFilter<'MentorSession'> | Date | string;
    capacity?: IntFilter<'MentorSession'> | number;
    booked?: IntFilter<'MentorSession'> | number;
    meetingUrl?: StringNullableFilter<'MentorSession'> | string | null;
    createdAt?: DateTimeFilter<'MentorSession'> | Date | string;
  };

  export type MentorCreateWithoutSessionsInput = {
    id?: string;
    bio?: string | null;
    calendlyUrl?: string | null;
    expertise?: MentorCreateexpertiseInput | string[];
    createdAt?: Date | string;
    user: UserCreateNestedOneWithoutMentorProfilesInput;
    hackathon: HackathonCreateNestedOneWithoutMentorsInput;
  };

  export type MentorUncheckedCreateWithoutSessionsInput = {
    id?: string;
    userId: string;
    hackathonId: string;
    bio?: string | null;
    calendlyUrl?: string | null;
    expertise?: MentorCreateexpertiseInput | string[];
    createdAt?: Date | string;
  };

  export type MentorCreateOrConnectWithoutSessionsInput = {
    where: MentorWhereUniqueInput;
    create: XOR<MentorCreateWithoutSessionsInput, MentorUncheckedCreateWithoutSessionsInput>;
  };

  export type MentorUpsertWithoutSessionsInput = {
    update: XOR<MentorUpdateWithoutSessionsInput, MentorUncheckedUpdateWithoutSessionsInput>;
    create: XOR<MentorCreateWithoutSessionsInput, MentorUncheckedCreateWithoutSessionsInput>;
    where?: MentorWhereInput;
  };

  export type MentorUpdateToOneWithWhereWithoutSessionsInput = {
    where?: MentorWhereInput;
    data: XOR<MentorUpdateWithoutSessionsInput, MentorUncheckedUpdateWithoutSessionsInput>;
  };

  export type MentorUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    calendlyUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    expertise?: MentorUpdateexpertiseInput | string[];
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutMentorProfilesNestedInput;
    hackathon?: HackathonUpdateOneRequiredWithoutMentorsNestedInput;
  };

  export type MentorUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    hackathonId?: StringFieldUpdateOperationsInput | string;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    calendlyUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    expertise?: MentorUpdateexpertiseInput | string[];
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type UserCreateWithoutJudgeAssignmentsInput = {
    id?: string;
    email: string;
    emailVerified?: Date | string | null;
    name?: string | null;
    handle?: string | null;
    avatarUrl?: string | null;
    bio?: string | null;
    organization?: string | null;
    password?: string | null;
    roles?: UserCreaterolesInput | $Enums.Role[];
    totpSecret?: string | null;
    totpEnabled?: boolean;
    passwordResetToken?: string | null;
    passwordResetExpires?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastLoginAt?: Date | string | null;
    isActive?: boolean;
    isBanned?: boolean;
    accounts?: AccountCreateNestedManyWithoutUserInput;
    sessions?: SessionCreateNestedManyWithoutUserInput;
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput;
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput;
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput;
    mentorProfiles?: MentorCreateNestedManyWithoutUserInput;
    challengeSubmissions?: ChallengeSubmissionCreateNestedManyWithoutUserInput;
    comments?: CommentCreateNestedManyWithoutAuthorInput;
    gamificationProfile?: GamificationProfileCreateNestedOneWithoutUserInput;
    xpEvents?: XpEventCreateNestedManyWithoutUserInput;
    notifications?: NotificationCreateNestedManyWithoutUserInput;
    reports?: ReportCreateNestedManyWithoutReporterInput;
    uploadedFiles?: FileCreateNestedManyWithoutUploadedByInput;
    ownedChallenges?: ChallengeCreateNestedManyWithoutOwnerInput;
  };

  export type UserUncheckedCreateWithoutJudgeAssignmentsInput = {
    id?: string;
    email: string;
    emailVerified?: Date | string | null;
    name?: string | null;
    handle?: string | null;
    avatarUrl?: string | null;
    bio?: string | null;
    organization?: string | null;
    password?: string | null;
    roles?: UserCreaterolesInput | $Enums.Role[];
    totpSecret?: string | null;
    totpEnabled?: boolean;
    passwordResetToken?: string | null;
    passwordResetExpires?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastLoginAt?: Date | string | null;
    isActive?: boolean;
    isBanned?: boolean;
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput;
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput;
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput;
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput;
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput;
    mentorProfiles?: MentorUncheckedCreateNestedManyWithoutUserInput;
    challengeSubmissions?: ChallengeSubmissionUncheckedCreateNestedManyWithoutUserInput;
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput;
    gamificationProfile?: GamificationProfileUncheckedCreateNestedOneWithoutUserInput;
    xpEvents?: XpEventUncheckedCreateNestedManyWithoutUserInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    reports?: ReportUncheckedCreateNestedManyWithoutReporterInput;
    uploadedFiles?: FileUncheckedCreateNestedManyWithoutUploadedByInput;
    ownedChallenges?: ChallengeUncheckedCreateNestedManyWithoutOwnerInput;
  };

  export type UserCreateOrConnectWithoutJudgeAssignmentsInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutJudgeAssignmentsInput,
      UserUncheckedCreateWithoutJudgeAssignmentsInput
    >;
  };

  export type HackathonCreateWithoutJudgesInput = {
    id?: string;
    slug: string;
    title: string;
    description: string;
    coverImage?: string | null;
    status?: $Enums.HackathonStatus;
    location?: $Enums.HackathonLocation;
    registrationOpensAt?: Date | string | null;
    registrationClosesAt?: Date | string | null;
    startsAt: Date | string;
    endsAt: Date | string;
    judgingEndsAt?: Date | string | null;
    prizePool?: Decimal | DecimalJsLike | number | string | null;
    maxTeamSize?: number;
    allowSoloTeams?: boolean;
    rules?: string | null;
    schedule?: NullableJsonNullValueInput | InputJsonValue;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    tracks?: TrackCreateNestedManyWithoutHackathonInput;
    teams?: TeamCreateNestedManyWithoutHackathonInput;
    mentors?: MentorCreateNestedManyWithoutHackathonInput;
    criteria?: CriteriaCreateNestedManyWithoutHackathonInput;
    submissions?: SubmissionCreateNestedManyWithoutHackathonInput;
    announcements?: AnnouncementCreateNestedManyWithoutHackathonInput;
  };

  export type HackathonUncheckedCreateWithoutJudgesInput = {
    id?: string;
    slug: string;
    title: string;
    description: string;
    coverImage?: string | null;
    status?: $Enums.HackathonStatus;
    location?: $Enums.HackathonLocation;
    registrationOpensAt?: Date | string | null;
    registrationClosesAt?: Date | string | null;
    startsAt: Date | string;
    endsAt: Date | string;
    judgingEndsAt?: Date | string | null;
    prizePool?: Decimal | DecimalJsLike | number | string | null;
    maxTeamSize?: number;
    allowSoloTeams?: boolean;
    rules?: string | null;
    schedule?: NullableJsonNullValueInput | InputJsonValue;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    tracks?: TrackUncheckedCreateNestedManyWithoutHackathonInput;
    teams?: TeamUncheckedCreateNestedManyWithoutHackathonInput;
    mentors?: MentorUncheckedCreateNestedManyWithoutHackathonInput;
    criteria?: CriteriaUncheckedCreateNestedManyWithoutHackathonInput;
    submissions?: SubmissionUncheckedCreateNestedManyWithoutHackathonInput;
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutHackathonInput;
  };

  export type HackathonCreateOrConnectWithoutJudgesInput = {
    where: HackathonWhereUniqueInput;
    create: XOR<HackathonCreateWithoutJudgesInput, HackathonUncheckedCreateWithoutJudgesInput>;
  };

  export type ScoreCreateWithoutJudgeInput = {
    id?: string;
    score: number;
    feedback?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    submission: SubmissionCreateNestedOneWithoutScoresInput;
    criterion: CriteriaCreateNestedOneWithoutScoresInput;
  };

  export type ScoreUncheckedCreateWithoutJudgeInput = {
    id?: string;
    submissionId: string;
    criterionId: string;
    score: number;
    feedback?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ScoreCreateOrConnectWithoutJudgeInput = {
    where: ScoreWhereUniqueInput;
    create: XOR<ScoreCreateWithoutJudgeInput, ScoreUncheckedCreateWithoutJudgeInput>;
  };

  export type ScoreCreateManyJudgeInputEnvelope = {
    data: ScoreCreateManyJudgeInput | ScoreCreateManyJudgeInput[];
    skipDuplicates?: boolean;
  };

  export type UserUpsertWithoutJudgeAssignmentsInput = {
    update: XOR<
      UserUpdateWithoutJudgeAssignmentsInput,
      UserUncheckedUpdateWithoutJudgeAssignmentsInput
    >;
    create: XOR<
      UserCreateWithoutJudgeAssignmentsInput,
      UserUncheckedCreateWithoutJudgeAssignmentsInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutJudgeAssignmentsInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutJudgeAssignmentsInput,
      UserUncheckedUpdateWithoutJudgeAssignmentsInput
    >;
  };

  export type UserUpdateWithoutJudgeAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    handle?: NullableStringFieldUpdateOperationsInput | string | null;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    organization?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    roles?: UserUpdaterolesInput | $Enums.Role[];
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    totpEnabled?: BoolFieldUpdateOperationsInput | boolean;
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    isBanned?: BoolFieldUpdateOperationsInput | boolean;
    accounts?: AccountUpdateManyWithoutUserNestedInput;
    sessions?: SessionUpdateManyWithoutUserNestedInput;
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput;
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput;
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput;
    mentorProfiles?: MentorUpdateManyWithoutUserNestedInput;
    challengeSubmissions?: ChallengeSubmissionUpdateManyWithoutUserNestedInput;
    comments?: CommentUpdateManyWithoutAuthorNestedInput;
    gamificationProfile?: GamificationProfileUpdateOneWithoutUserNestedInput;
    xpEvents?: XpEventUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUpdateManyWithoutUserNestedInput;
    reports?: ReportUpdateManyWithoutReporterNestedInput;
    uploadedFiles?: FileUpdateManyWithoutUploadedByNestedInput;
    ownedChallenges?: ChallengeUpdateManyWithoutOwnerNestedInput;
  };

  export type UserUncheckedUpdateWithoutJudgeAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    handle?: NullableStringFieldUpdateOperationsInput | string | null;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    organization?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    roles?: UserUpdaterolesInput | $Enums.Role[];
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    totpEnabled?: BoolFieldUpdateOperationsInput | boolean;
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    isBanned?: BoolFieldUpdateOperationsInput | boolean;
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput;
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput;
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput;
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput;
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput;
    mentorProfiles?: MentorUncheckedUpdateManyWithoutUserNestedInput;
    challengeSubmissions?: ChallengeSubmissionUncheckedUpdateManyWithoutUserNestedInput;
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput;
    gamificationProfile?: GamificationProfileUncheckedUpdateOneWithoutUserNestedInput;
    xpEvents?: XpEventUncheckedUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    reports?: ReportUncheckedUpdateManyWithoutReporterNestedInput;
    uploadedFiles?: FileUncheckedUpdateManyWithoutUploadedByNestedInput;
    ownedChallenges?: ChallengeUncheckedUpdateManyWithoutOwnerNestedInput;
  };

  export type HackathonUpsertWithoutJudgesInput = {
    update: XOR<HackathonUpdateWithoutJudgesInput, HackathonUncheckedUpdateWithoutJudgesInput>;
    create: XOR<HackathonCreateWithoutJudgesInput, HackathonUncheckedCreateWithoutJudgesInput>;
    where?: HackathonWhereInput;
  };

  export type HackathonUpdateToOneWithWhereWithoutJudgesInput = {
    where?: HackathonWhereInput;
    data: XOR<HackathonUpdateWithoutJudgesInput, HackathonUncheckedUpdateWithoutJudgesInput>;
  };

  export type HackathonUpdateWithoutJudgesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumHackathonStatusFieldUpdateOperationsInput | $Enums.HackathonStatus;
    location?: EnumHackathonLocationFieldUpdateOperationsInput | $Enums.HackathonLocation;
    registrationOpensAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    registrationClosesAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    judgingEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    prizePool?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    maxTeamSize?: IntFieldUpdateOperationsInput | number;
    allowSoloTeams?: BoolFieldUpdateOperationsInput | boolean;
    rules?: NullableStringFieldUpdateOperationsInput | string | null;
    schedule?: NullableJsonNullValueInput | InputJsonValue;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    tracks?: TrackUpdateManyWithoutHackathonNestedInput;
    teams?: TeamUpdateManyWithoutHackathonNestedInput;
    mentors?: MentorUpdateManyWithoutHackathonNestedInput;
    criteria?: CriteriaUpdateManyWithoutHackathonNestedInput;
    submissions?: SubmissionUpdateManyWithoutHackathonNestedInput;
    announcements?: AnnouncementUpdateManyWithoutHackathonNestedInput;
  };

  export type HackathonUncheckedUpdateWithoutJudgesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumHackathonStatusFieldUpdateOperationsInput | $Enums.HackathonStatus;
    location?: EnumHackathonLocationFieldUpdateOperationsInput | $Enums.HackathonLocation;
    registrationOpensAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    registrationClosesAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    judgingEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    prizePool?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    maxTeamSize?: IntFieldUpdateOperationsInput | number;
    allowSoloTeams?: BoolFieldUpdateOperationsInput | boolean;
    rules?: NullableStringFieldUpdateOperationsInput | string | null;
    schedule?: NullableJsonNullValueInput | InputJsonValue;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    tracks?: TrackUncheckedUpdateManyWithoutHackathonNestedInput;
    teams?: TeamUncheckedUpdateManyWithoutHackathonNestedInput;
    mentors?: MentorUncheckedUpdateManyWithoutHackathonNestedInput;
    criteria?: CriteriaUncheckedUpdateManyWithoutHackathonNestedInput;
    submissions?: SubmissionUncheckedUpdateManyWithoutHackathonNestedInput;
    announcements?: AnnouncementUncheckedUpdateManyWithoutHackathonNestedInput;
  };

  export type ScoreUpsertWithWhereUniqueWithoutJudgeInput = {
    where: ScoreWhereUniqueInput;
    update: XOR<ScoreUpdateWithoutJudgeInput, ScoreUncheckedUpdateWithoutJudgeInput>;
    create: XOR<ScoreCreateWithoutJudgeInput, ScoreUncheckedCreateWithoutJudgeInput>;
  };

  export type ScoreUpdateWithWhereUniqueWithoutJudgeInput = {
    where: ScoreWhereUniqueInput;
    data: XOR<ScoreUpdateWithoutJudgeInput, ScoreUncheckedUpdateWithoutJudgeInput>;
  };

  export type ScoreUpdateManyWithWhereWithoutJudgeInput = {
    where: ScoreScalarWhereInput;
    data: XOR<ScoreUpdateManyMutationInput, ScoreUncheckedUpdateManyWithoutJudgeInput>;
  };

  export type ScoreScalarWhereInput = {
    AND?: ScoreScalarWhereInput | ScoreScalarWhereInput[];
    OR?: ScoreScalarWhereInput[];
    NOT?: ScoreScalarWhereInput | ScoreScalarWhereInput[];
    id?: StringFilter<'Score'> | string;
    submissionId?: StringFilter<'Score'> | string;
    judgeId?: StringFilter<'Score'> | string;
    criterionId?: StringFilter<'Score'> | string;
    score?: IntFilter<'Score'> | number;
    feedback?: StringNullableFilter<'Score'> | string | null;
    createdAt?: DateTimeFilter<'Score'> | Date | string;
    updatedAt?: DateTimeFilter<'Score'> | Date | string;
  };

  export type HackathonCreateWithoutCriteriaInput = {
    id?: string;
    slug: string;
    title: string;
    description: string;
    coverImage?: string | null;
    status?: $Enums.HackathonStatus;
    location?: $Enums.HackathonLocation;
    registrationOpensAt?: Date | string | null;
    registrationClosesAt?: Date | string | null;
    startsAt: Date | string;
    endsAt: Date | string;
    judgingEndsAt?: Date | string | null;
    prizePool?: Decimal | DecimalJsLike | number | string | null;
    maxTeamSize?: number;
    allowSoloTeams?: boolean;
    rules?: string | null;
    schedule?: NullableJsonNullValueInput | InputJsonValue;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    tracks?: TrackCreateNestedManyWithoutHackathonInput;
    teams?: TeamCreateNestedManyWithoutHackathonInput;
    mentors?: MentorCreateNestedManyWithoutHackathonInput;
    judges?: JudgeCreateNestedManyWithoutHackathonInput;
    submissions?: SubmissionCreateNestedManyWithoutHackathonInput;
    announcements?: AnnouncementCreateNestedManyWithoutHackathonInput;
  };

  export type HackathonUncheckedCreateWithoutCriteriaInput = {
    id?: string;
    slug: string;
    title: string;
    description: string;
    coverImage?: string | null;
    status?: $Enums.HackathonStatus;
    location?: $Enums.HackathonLocation;
    registrationOpensAt?: Date | string | null;
    registrationClosesAt?: Date | string | null;
    startsAt: Date | string;
    endsAt: Date | string;
    judgingEndsAt?: Date | string | null;
    prizePool?: Decimal | DecimalJsLike | number | string | null;
    maxTeamSize?: number;
    allowSoloTeams?: boolean;
    rules?: string | null;
    schedule?: NullableJsonNullValueInput | InputJsonValue;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    tracks?: TrackUncheckedCreateNestedManyWithoutHackathonInput;
    teams?: TeamUncheckedCreateNestedManyWithoutHackathonInput;
    mentors?: MentorUncheckedCreateNestedManyWithoutHackathonInput;
    judges?: JudgeUncheckedCreateNestedManyWithoutHackathonInput;
    submissions?: SubmissionUncheckedCreateNestedManyWithoutHackathonInput;
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutHackathonInput;
  };

  export type HackathonCreateOrConnectWithoutCriteriaInput = {
    where: HackathonWhereUniqueInput;
    create: XOR<HackathonCreateWithoutCriteriaInput, HackathonUncheckedCreateWithoutCriteriaInput>;
  };

  export type ScoreCreateWithoutCriterionInput = {
    id?: string;
    score: number;
    feedback?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    submission: SubmissionCreateNestedOneWithoutScoresInput;
    judge: JudgeCreateNestedOneWithoutScoresInput;
  };

  export type ScoreUncheckedCreateWithoutCriterionInput = {
    id?: string;
    submissionId: string;
    judgeId: string;
    score: number;
    feedback?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ScoreCreateOrConnectWithoutCriterionInput = {
    where: ScoreWhereUniqueInput;
    create: XOR<ScoreCreateWithoutCriterionInput, ScoreUncheckedCreateWithoutCriterionInput>;
  };

  export type ScoreCreateManyCriterionInputEnvelope = {
    data: ScoreCreateManyCriterionInput | ScoreCreateManyCriterionInput[];
    skipDuplicates?: boolean;
  };

  export type HackathonUpsertWithoutCriteriaInput = {
    update: XOR<HackathonUpdateWithoutCriteriaInput, HackathonUncheckedUpdateWithoutCriteriaInput>;
    create: XOR<HackathonCreateWithoutCriteriaInput, HackathonUncheckedCreateWithoutCriteriaInput>;
    where?: HackathonWhereInput;
  };

  export type HackathonUpdateToOneWithWhereWithoutCriteriaInput = {
    where?: HackathonWhereInput;
    data: XOR<HackathonUpdateWithoutCriteriaInput, HackathonUncheckedUpdateWithoutCriteriaInput>;
  };

  export type HackathonUpdateWithoutCriteriaInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumHackathonStatusFieldUpdateOperationsInput | $Enums.HackathonStatus;
    location?: EnumHackathonLocationFieldUpdateOperationsInput | $Enums.HackathonLocation;
    registrationOpensAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    registrationClosesAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    judgingEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    prizePool?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    maxTeamSize?: IntFieldUpdateOperationsInput | number;
    allowSoloTeams?: BoolFieldUpdateOperationsInput | boolean;
    rules?: NullableStringFieldUpdateOperationsInput | string | null;
    schedule?: NullableJsonNullValueInput | InputJsonValue;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    tracks?: TrackUpdateManyWithoutHackathonNestedInput;
    teams?: TeamUpdateManyWithoutHackathonNestedInput;
    mentors?: MentorUpdateManyWithoutHackathonNestedInput;
    judges?: JudgeUpdateManyWithoutHackathonNestedInput;
    submissions?: SubmissionUpdateManyWithoutHackathonNestedInput;
    announcements?: AnnouncementUpdateManyWithoutHackathonNestedInput;
  };

  export type HackathonUncheckedUpdateWithoutCriteriaInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumHackathonStatusFieldUpdateOperationsInput | $Enums.HackathonStatus;
    location?: EnumHackathonLocationFieldUpdateOperationsInput | $Enums.HackathonLocation;
    registrationOpensAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    registrationClosesAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    judgingEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    prizePool?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    maxTeamSize?: IntFieldUpdateOperationsInput | number;
    allowSoloTeams?: BoolFieldUpdateOperationsInput | boolean;
    rules?: NullableStringFieldUpdateOperationsInput | string | null;
    schedule?: NullableJsonNullValueInput | InputJsonValue;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    tracks?: TrackUncheckedUpdateManyWithoutHackathonNestedInput;
    teams?: TeamUncheckedUpdateManyWithoutHackathonNestedInput;
    mentors?: MentorUncheckedUpdateManyWithoutHackathonNestedInput;
    judges?: JudgeUncheckedUpdateManyWithoutHackathonNestedInput;
    submissions?: SubmissionUncheckedUpdateManyWithoutHackathonNestedInput;
    announcements?: AnnouncementUncheckedUpdateManyWithoutHackathonNestedInput;
  };

  export type ScoreUpsertWithWhereUniqueWithoutCriterionInput = {
    where: ScoreWhereUniqueInput;
    update: XOR<ScoreUpdateWithoutCriterionInput, ScoreUncheckedUpdateWithoutCriterionInput>;
    create: XOR<ScoreCreateWithoutCriterionInput, ScoreUncheckedCreateWithoutCriterionInput>;
  };

  export type ScoreUpdateWithWhereUniqueWithoutCriterionInput = {
    where: ScoreWhereUniqueInput;
    data: XOR<ScoreUpdateWithoutCriterionInput, ScoreUncheckedUpdateWithoutCriterionInput>;
  };

  export type ScoreUpdateManyWithWhereWithoutCriterionInput = {
    where: ScoreScalarWhereInput;
    data: XOR<ScoreUpdateManyMutationInput, ScoreUncheckedUpdateManyWithoutCriterionInput>;
  };

  export type HackathonCreateWithoutSubmissionsInput = {
    id?: string;
    slug: string;
    title: string;
    description: string;
    coverImage?: string | null;
    status?: $Enums.HackathonStatus;
    location?: $Enums.HackathonLocation;
    registrationOpensAt?: Date | string | null;
    registrationClosesAt?: Date | string | null;
    startsAt: Date | string;
    endsAt: Date | string;
    judgingEndsAt?: Date | string | null;
    prizePool?: Decimal | DecimalJsLike | number | string | null;
    maxTeamSize?: number;
    allowSoloTeams?: boolean;
    rules?: string | null;
    schedule?: NullableJsonNullValueInput | InputJsonValue;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    tracks?: TrackCreateNestedManyWithoutHackathonInput;
    teams?: TeamCreateNestedManyWithoutHackathonInput;
    mentors?: MentorCreateNestedManyWithoutHackathonInput;
    judges?: JudgeCreateNestedManyWithoutHackathonInput;
    criteria?: CriteriaCreateNestedManyWithoutHackathonInput;
    announcements?: AnnouncementCreateNestedManyWithoutHackathonInput;
  };

  export type HackathonUncheckedCreateWithoutSubmissionsInput = {
    id?: string;
    slug: string;
    title: string;
    description: string;
    coverImage?: string | null;
    status?: $Enums.HackathonStatus;
    location?: $Enums.HackathonLocation;
    registrationOpensAt?: Date | string | null;
    registrationClosesAt?: Date | string | null;
    startsAt: Date | string;
    endsAt: Date | string;
    judgingEndsAt?: Date | string | null;
    prizePool?: Decimal | DecimalJsLike | number | string | null;
    maxTeamSize?: number;
    allowSoloTeams?: boolean;
    rules?: string | null;
    schedule?: NullableJsonNullValueInput | InputJsonValue;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    tracks?: TrackUncheckedCreateNestedManyWithoutHackathonInput;
    teams?: TeamUncheckedCreateNestedManyWithoutHackathonInput;
    mentors?: MentorUncheckedCreateNestedManyWithoutHackathonInput;
    judges?: JudgeUncheckedCreateNestedManyWithoutHackathonInput;
    criteria?: CriteriaUncheckedCreateNestedManyWithoutHackathonInput;
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutHackathonInput;
  };

  export type HackathonCreateOrConnectWithoutSubmissionsInput = {
    where: HackathonWhereUniqueInput;
    create: XOR<
      HackathonCreateWithoutSubmissionsInput,
      HackathonUncheckedCreateWithoutSubmissionsInput
    >;
  };

  export type TeamCreateWithoutSubmissionsInput = {
    id?: string;
    name: string;
    bio?: string | null;
    logoUrl?: string | null;
    repoUrl?: string | null;
    demoUrl?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    hackathon: HackathonCreateNestedOneWithoutTeamsInput;
    members?: TeamMemberCreateNestedManyWithoutTeamInput;
    challengeSubmissions?: ChallengeSubmissionCreateNestedManyWithoutTeamInput;
  };

  export type TeamUncheckedCreateWithoutSubmissionsInput = {
    id?: string;
    hackathonId: string;
    name: string;
    bio?: string | null;
    logoUrl?: string | null;
    repoUrl?: string | null;
    demoUrl?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    members?: TeamMemberUncheckedCreateNestedManyWithoutTeamInput;
    challengeSubmissions?: ChallengeSubmissionUncheckedCreateNestedManyWithoutTeamInput;
  };

  export type TeamCreateOrConnectWithoutSubmissionsInput = {
    where: TeamWhereUniqueInput;
    create: XOR<TeamCreateWithoutSubmissionsInput, TeamUncheckedCreateWithoutSubmissionsInput>;
  };

  export type TrackCreateWithoutSubmissionsInput = {
    id?: string;
    title: string;
    description?: string | null;
    order?: number;
    createdAt?: Date | string;
    hackathon: HackathonCreateNestedOneWithoutTracksInput;
  };

  export type TrackUncheckedCreateWithoutSubmissionsInput = {
    id?: string;
    hackathonId: string;
    title: string;
    description?: string | null;
    order?: number;
    createdAt?: Date | string;
  };

  export type TrackCreateOrConnectWithoutSubmissionsInput = {
    where: TrackWhereUniqueInput;
    create: XOR<TrackCreateWithoutSubmissionsInput, TrackUncheckedCreateWithoutSubmissionsInput>;
  };

  export type ScoreCreateWithoutSubmissionInput = {
    id?: string;
    score: number;
    feedback?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    judge: JudgeCreateNestedOneWithoutScoresInput;
    criterion: CriteriaCreateNestedOneWithoutScoresInput;
  };

  export type ScoreUncheckedCreateWithoutSubmissionInput = {
    id?: string;
    judgeId: string;
    criterionId: string;
    score: number;
    feedback?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ScoreCreateOrConnectWithoutSubmissionInput = {
    where: ScoreWhereUniqueInput;
    create: XOR<ScoreCreateWithoutSubmissionInput, ScoreUncheckedCreateWithoutSubmissionInput>;
  };

  export type ScoreCreateManySubmissionInputEnvelope = {
    data: ScoreCreateManySubmissionInput | ScoreCreateManySubmissionInput[];
    skipDuplicates?: boolean;
  };

  export type HackathonUpsertWithoutSubmissionsInput = {
    update: XOR<
      HackathonUpdateWithoutSubmissionsInput,
      HackathonUncheckedUpdateWithoutSubmissionsInput
    >;
    create: XOR<
      HackathonCreateWithoutSubmissionsInput,
      HackathonUncheckedCreateWithoutSubmissionsInput
    >;
    where?: HackathonWhereInput;
  };

  export type HackathonUpdateToOneWithWhereWithoutSubmissionsInput = {
    where?: HackathonWhereInput;
    data: XOR<
      HackathonUpdateWithoutSubmissionsInput,
      HackathonUncheckedUpdateWithoutSubmissionsInput
    >;
  };

  export type HackathonUpdateWithoutSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumHackathonStatusFieldUpdateOperationsInput | $Enums.HackathonStatus;
    location?: EnumHackathonLocationFieldUpdateOperationsInput | $Enums.HackathonLocation;
    registrationOpensAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    registrationClosesAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    judgingEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    prizePool?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    maxTeamSize?: IntFieldUpdateOperationsInput | number;
    allowSoloTeams?: BoolFieldUpdateOperationsInput | boolean;
    rules?: NullableStringFieldUpdateOperationsInput | string | null;
    schedule?: NullableJsonNullValueInput | InputJsonValue;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    tracks?: TrackUpdateManyWithoutHackathonNestedInput;
    teams?: TeamUpdateManyWithoutHackathonNestedInput;
    mentors?: MentorUpdateManyWithoutHackathonNestedInput;
    judges?: JudgeUpdateManyWithoutHackathonNestedInput;
    criteria?: CriteriaUpdateManyWithoutHackathonNestedInput;
    announcements?: AnnouncementUpdateManyWithoutHackathonNestedInput;
  };

  export type HackathonUncheckedUpdateWithoutSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumHackathonStatusFieldUpdateOperationsInput | $Enums.HackathonStatus;
    location?: EnumHackathonLocationFieldUpdateOperationsInput | $Enums.HackathonLocation;
    registrationOpensAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    registrationClosesAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    judgingEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    prizePool?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    maxTeamSize?: IntFieldUpdateOperationsInput | number;
    allowSoloTeams?: BoolFieldUpdateOperationsInput | boolean;
    rules?: NullableStringFieldUpdateOperationsInput | string | null;
    schedule?: NullableJsonNullValueInput | InputJsonValue;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    tracks?: TrackUncheckedUpdateManyWithoutHackathonNestedInput;
    teams?: TeamUncheckedUpdateManyWithoutHackathonNestedInput;
    mentors?: MentorUncheckedUpdateManyWithoutHackathonNestedInput;
    judges?: JudgeUncheckedUpdateManyWithoutHackathonNestedInput;
    criteria?: CriteriaUncheckedUpdateManyWithoutHackathonNestedInput;
    announcements?: AnnouncementUncheckedUpdateManyWithoutHackathonNestedInput;
  };

  export type TeamUpsertWithoutSubmissionsInput = {
    update: XOR<TeamUpdateWithoutSubmissionsInput, TeamUncheckedUpdateWithoutSubmissionsInput>;
    create: XOR<TeamCreateWithoutSubmissionsInput, TeamUncheckedCreateWithoutSubmissionsInput>;
    where?: TeamWhereInput;
  };

  export type TeamUpdateToOneWithWhereWithoutSubmissionsInput = {
    where?: TeamWhereInput;
    data: XOR<TeamUpdateWithoutSubmissionsInput, TeamUncheckedUpdateWithoutSubmissionsInput>;
  };

  export type TeamUpdateWithoutSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    repoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    demoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    hackathon?: HackathonUpdateOneRequiredWithoutTeamsNestedInput;
    members?: TeamMemberUpdateManyWithoutTeamNestedInput;
    challengeSubmissions?: ChallengeSubmissionUpdateManyWithoutTeamNestedInput;
  };

  export type TeamUncheckedUpdateWithoutSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    hackathonId?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    repoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    demoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    members?: TeamMemberUncheckedUpdateManyWithoutTeamNestedInput;
    challengeSubmissions?: ChallengeSubmissionUncheckedUpdateManyWithoutTeamNestedInput;
  };

  export type TrackUpsertWithoutSubmissionsInput = {
    update: XOR<TrackUpdateWithoutSubmissionsInput, TrackUncheckedUpdateWithoutSubmissionsInput>;
    create: XOR<TrackCreateWithoutSubmissionsInput, TrackUncheckedCreateWithoutSubmissionsInput>;
    where?: TrackWhereInput;
  };

  export type TrackUpdateToOneWithWhereWithoutSubmissionsInput = {
    where?: TrackWhereInput;
    data: XOR<TrackUpdateWithoutSubmissionsInput, TrackUncheckedUpdateWithoutSubmissionsInput>;
  };

  export type TrackUpdateWithoutSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    order?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    hackathon?: HackathonUpdateOneRequiredWithoutTracksNestedInput;
  };

  export type TrackUncheckedUpdateWithoutSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    hackathonId?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    order?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ScoreUpsertWithWhereUniqueWithoutSubmissionInput = {
    where: ScoreWhereUniqueInput;
    update: XOR<ScoreUpdateWithoutSubmissionInput, ScoreUncheckedUpdateWithoutSubmissionInput>;
    create: XOR<ScoreCreateWithoutSubmissionInput, ScoreUncheckedCreateWithoutSubmissionInput>;
  };

  export type ScoreUpdateWithWhereUniqueWithoutSubmissionInput = {
    where: ScoreWhereUniqueInput;
    data: XOR<ScoreUpdateWithoutSubmissionInput, ScoreUncheckedUpdateWithoutSubmissionInput>;
  };

  export type ScoreUpdateManyWithWhereWithoutSubmissionInput = {
    where: ScoreScalarWhereInput;
    data: XOR<ScoreUpdateManyMutationInput, ScoreUncheckedUpdateManyWithoutSubmissionInput>;
  };

  export type SubmissionCreateWithoutScoresInput = {
    id?: string;
    title: string;
    abstract: string;
    repoUrl?: string | null;
    demoUrl?: string | null;
    videoUrl?: string | null;
    files?: SubmissionCreatefilesInput | string[];
    submittedAt?: Date | string | null;
    finalizedAt?: Date | string | null;
    status?: $Enums.SubmissionStatus;
    scoreAggregate?: Decimal | DecimalJsLike | number | string | null;
    rank?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    hackathon: HackathonCreateNestedOneWithoutSubmissionsInput;
    team: TeamCreateNestedOneWithoutSubmissionsInput;
    track?: TrackCreateNestedOneWithoutSubmissionsInput;
  };

  export type SubmissionUncheckedCreateWithoutScoresInput = {
    id?: string;
    hackathonId: string;
    teamId: string;
    trackId?: string | null;
    title: string;
    abstract: string;
    repoUrl?: string | null;
    demoUrl?: string | null;
    videoUrl?: string | null;
    files?: SubmissionCreatefilesInput | string[];
    submittedAt?: Date | string | null;
    finalizedAt?: Date | string | null;
    status?: $Enums.SubmissionStatus;
    scoreAggregate?: Decimal | DecimalJsLike | number | string | null;
    rank?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type SubmissionCreateOrConnectWithoutScoresInput = {
    where: SubmissionWhereUniqueInput;
    create: XOR<SubmissionCreateWithoutScoresInput, SubmissionUncheckedCreateWithoutScoresInput>;
  };

  export type JudgeCreateWithoutScoresInput = {
    id?: string;
    bio?: string | null;
    createdAt?: Date | string;
    user: UserCreateNestedOneWithoutJudgeAssignmentsInput;
    hackathon: HackathonCreateNestedOneWithoutJudgesInput;
  };

  export type JudgeUncheckedCreateWithoutScoresInput = {
    id?: string;
    userId: string;
    hackathonId: string;
    bio?: string | null;
    createdAt?: Date | string;
  };

  export type JudgeCreateOrConnectWithoutScoresInput = {
    where: JudgeWhereUniqueInput;
    create: XOR<JudgeCreateWithoutScoresInput, JudgeUncheckedCreateWithoutScoresInput>;
  };

  export type CriteriaCreateWithoutScoresInput = {
    id?: string;
    name: string;
    description?: string | null;
    maxScore?: number;
    weight?: Decimal | DecimalJsLike | number | string;
    order?: number;
    hackathon: HackathonCreateNestedOneWithoutCriteriaInput;
  };

  export type CriteriaUncheckedCreateWithoutScoresInput = {
    id?: string;
    hackathonId: string;
    name: string;
    description?: string | null;
    maxScore?: number;
    weight?: Decimal | DecimalJsLike | number | string;
    order?: number;
  };

  export type CriteriaCreateOrConnectWithoutScoresInput = {
    where: CriteriaWhereUniqueInput;
    create: XOR<CriteriaCreateWithoutScoresInput, CriteriaUncheckedCreateWithoutScoresInput>;
  };

  export type SubmissionUpsertWithoutScoresInput = {
    update: XOR<SubmissionUpdateWithoutScoresInput, SubmissionUncheckedUpdateWithoutScoresInput>;
    create: XOR<SubmissionCreateWithoutScoresInput, SubmissionUncheckedCreateWithoutScoresInput>;
    where?: SubmissionWhereInput;
  };

  export type SubmissionUpdateToOneWithWhereWithoutScoresInput = {
    where?: SubmissionWhereInput;
    data: XOR<SubmissionUpdateWithoutScoresInput, SubmissionUncheckedUpdateWithoutScoresInput>;
  };

  export type SubmissionUpdateWithoutScoresInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    abstract?: StringFieldUpdateOperationsInput | string;
    repoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    demoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    files?: SubmissionUpdatefilesInput | string[];
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    status?: EnumSubmissionStatusFieldUpdateOperationsInput | $Enums.SubmissionStatus;
    scoreAggregate?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    rank?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    hackathon?: HackathonUpdateOneRequiredWithoutSubmissionsNestedInput;
    team?: TeamUpdateOneRequiredWithoutSubmissionsNestedInput;
    track?: TrackUpdateOneWithoutSubmissionsNestedInput;
  };

  export type SubmissionUncheckedUpdateWithoutScoresInput = {
    id?: StringFieldUpdateOperationsInput | string;
    hackathonId?: StringFieldUpdateOperationsInput | string;
    teamId?: StringFieldUpdateOperationsInput | string;
    trackId?: NullableStringFieldUpdateOperationsInput | string | null;
    title?: StringFieldUpdateOperationsInput | string;
    abstract?: StringFieldUpdateOperationsInput | string;
    repoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    demoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    files?: SubmissionUpdatefilesInput | string[];
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    status?: EnumSubmissionStatusFieldUpdateOperationsInput | $Enums.SubmissionStatus;
    scoreAggregate?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    rank?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type JudgeUpsertWithoutScoresInput = {
    update: XOR<JudgeUpdateWithoutScoresInput, JudgeUncheckedUpdateWithoutScoresInput>;
    create: XOR<JudgeCreateWithoutScoresInput, JudgeUncheckedCreateWithoutScoresInput>;
    where?: JudgeWhereInput;
  };

  export type JudgeUpdateToOneWithWhereWithoutScoresInput = {
    where?: JudgeWhereInput;
    data: XOR<JudgeUpdateWithoutScoresInput, JudgeUncheckedUpdateWithoutScoresInput>;
  };

  export type JudgeUpdateWithoutScoresInput = {
    id?: StringFieldUpdateOperationsInput | string;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutJudgeAssignmentsNestedInput;
    hackathon?: HackathonUpdateOneRequiredWithoutJudgesNestedInput;
  };

  export type JudgeUncheckedUpdateWithoutScoresInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    hackathonId?: StringFieldUpdateOperationsInput | string;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type CriteriaUpsertWithoutScoresInput = {
    update: XOR<CriteriaUpdateWithoutScoresInput, CriteriaUncheckedUpdateWithoutScoresInput>;
    create: XOR<CriteriaCreateWithoutScoresInput, CriteriaUncheckedCreateWithoutScoresInput>;
    where?: CriteriaWhereInput;
  };

  export type CriteriaUpdateToOneWithWhereWithoutScoresInput = {
    where?: CriteriaWhereInput;
    data: XOR<CriteriaUpdateWithoutScoresInput, CriteriaUncheckedUpdateWithoutScoresInput>;
  };

  export type CriteriaUpdateWithoutScoresInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    maxScore?: IntFieldUpdateOperationsInput | number;
    weight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    order?: IntFieldUpdateOperationsInput | number;
    hackathon?: HackathonUpdateOneRequiredWithoutCriteriaNestedInput;
  };

  export type CriteriaUncheckedUpdateWithoutScoresInput = {
    id?: StringFieldUpdateOperationsInput | string;
    hackathonId?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    maxScore?: IntFieldUpdateOperationsInput | number;
    weight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    order?: IntFieldUpdateOperationsInput | number;
  };

  export type UserCreateWithoutOwnedChallengesInput = {
    id?: string;
    email: string;
    emailVerified?: Date | string | null;
    name?: string | null;
    handle?: string | null;
    avatarUrl?: string | null;
    bio?: string | null;
    organization?: string | null;
    password?: string | null;
    roles?: UserCreaterolesInput | $Enums.Role[];
    totpSecret?: string | null;
    totpEnabled?: boolean;
    passwordResetToken?: string | null;
    passwordResetExpires?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastLoginAt?: Date | string | null;
    isActive?: boolean;
    isBanned?: boolean;
    accounts?: AccountCreateNestedManyWithoutUserInput;
    sessions?: SessionCreateNestedManyWithoutUserInput;
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput;
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput;
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput;
    mentorProfiles?: MentorCreateNestedManyWithoutUserInput;
    judgeAssignments?: JudgeCreateNestedManyWithoutUserInput;
    challengeSubmissions?: ChallengeSubmissionCreateNestedManyWithoutUserInput;
    comments?: CommentCreateNestedManyWithoutAuthorInput;
    gamificationProfile?: GamificationProfileCreateNestedOneWithoutUserInput;
    xpEvents?: XpEventCreateNestedManyWithoutUserInput;
    notifications?: NotificationCreateNestedManyWithoutUserInput;
    reports?: ReportCreateNestedManyWithoutReporterInput;
    uploadedFiles?: FileCreateNestedManyWithoutUploadedByInput;
  };

  export type UserUncheckedCreateWithoutOwnedChallengesInput = {
    id?: string;
    email: string;
    emailVerified?: Date | string | null;
    name?: string | null;
    handle?: string | null;
    avatarUrl?: string | null;
    bio?: string | null;
    organization?: string | null;
    password?: string | null;
    roles?: UserCreaterolesInput | $Enums.Role[];
    totpSecret?: string | null;
    totpEnabled?: boolean;
    passwordResetToken?: string | null;
    passwordResetExpires?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastLoginAt?: Date | string | null;
    isActive?: boolean;
    isBanned?: boolean;
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput;
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput;
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput;
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput;
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput;
    mentorProfiles?: MentorUncheckedCreateNestedManyWithoutUserInput;
    judgeAssignments?: JudgeUncheckedCreateNestedManyWithoutUserInput;
    challengeSubmissions?: ChallengeSubmissionUncheckedCreateNestedManyWithoutUserInput;
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput;
    gamificationProfile?: GamificationProfileUncheckedCreateNestedOneWithoutUserInput;
    xpEvents?: XpEventUncheckedCreateNestedManyWithoutUserInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    reports?: ReportUncheckedCreateNestedManyWithoutReporterInput;
    uploadedFiles?: FileUncheckedCreateNestedManyWithoutUploadedByInput;
  };

  export type UserCreateOrConnectWithoutOwnedChallengesInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutOwnedChallengesInput,
      UserUncheckedCreateWithoutOwnedChallengesInput
    >;
  };

  export type ChallengeSubmissionCreateWithoutChallengeInput = {
    id?: string;
    title: string;
    repoUrl?: string | null;
    content: string;
    files?: ChallengeSubmissionCreatefilesInput | string[];
    status?: $Enums.ChallengeSubmissionStatus;
    score?: Decimal | DecimalJsLike | number | string | null;
    feedback?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    user?: UserCreateNestedOneWithoutChallengeSubmissionsInput;
    team?: TeamCreateNestedOneWithoutChallengeSubmissionsInput;
  };

  export type ChallengeSubmissionUncheckedCreateWithoutChallengeInput = {
    id?: string;
    userId?: string | null;
    teamId?: string | null;
    title: string;
    repoUrl?: string | null;
    content: string;
    files?: ChallengeSubmissionCreatefilesInput | string[];
    status?: $Enums.ChallengeSubmissionStatus;
    score?: Decimal | DecimalJsLike | number | string | null;
    feedback?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ChallengeSubmissionCreateOrConnectWithoutChallengeInput = {
    where: ChallengeSubmissionWhereUniqueInput;
    create: XOR<
      ChallengeSubmissionCreateWithoutChallengeInput,
      ChallengeSubmissionUncheckedCreateWithoutChallengeInput
    >;
  };

  export type ChallengeSubmissionCreateManyChallengeInputEnvelope = {
    data:
      | ChallengeSubmissionCreateManyChallengeInput
      | ChallengeSubmissionCreateManyChallengeInput[];
    skipDuplicates?: boolean;
  };

  export type UserUpsertWithoutOwnedChallengesInput = {
    update: XOR<
      UserUpdateWithoutOwnedChallengesInput,
      UserUncheckedUpdateWithoutOwnedChallengesInput
    >;
    create: XOR<
      UserCreateWithoutOwnedChallengesInput,
      UserUncheckedCreateWithoutOwnedChallengesInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutOwnedChallengesInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutOwnedChallengesInput,
      UserUncheckedUpdateWithoutOwnedChallengesInput
    >;
  };

  export type UserUpdateWithoutOwnedChallengesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    handle?: NullableStringFieldUpdateOperationsInput | string | null;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    organization?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    roles?: UserUpdaterolesInput | $Enums.Role[];
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    totpEnabled?: BoolFieldUpdateOperationsInput | boolean;
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    isBanned?: BoolFieldUpdateOperationsInput | boolean;
    accounts?: AccountUpdateManyWithoutUserNestedInput;
    sessions?: SessionUpdateManyWithoutUserNestedInput;
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput;
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput;
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput;
    mentorProfiles?: MentorUpdateManyWithoutUserNestedInput;
    judgeAssignments?: JudgeUpdateManyWithoutUserNestedInput;
    challengeSubmissions?: ChallengeSubmissionUpdateManyWithoutUserNestedInput;
    comments?: CommentUpdateManyWithoutAuthorNestedInput;
    gamificationProfile?: GamificationProfileUpdateOneWithoutUserNestedInput;
    xpEvents?: XpEventUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUpdateManyWithoutUserNestedInput;
    reports?: ReportUpdateManyWithoutReporterNestedInput;
    uploadedFiles?: FileUpdateManyWithoutUploadedByNestedInput;
  };

  export type UserUncheckedUpdateWithoutOwnedChallengesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    handle?: NullableStringFieldUpdateOperationsInput | string | null;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    organization?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    roles?: UserUpdaterolesInput | $Enums.Role[];
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    totpEnabled?: BoolFieldUpdateOperationsInput | boolean;
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    isBanned?: BoolFieldUpdateOperationsInput | boolean;
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput;
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput;
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput;
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput;
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput;
    mentorProfiles?: MentorUncheckedUpdateManyWithoutUserNestedInput;
    judgeAssignments?: JudgeUncheckedUpdateManyWithoutUserNestedInput;
    challengeSubmissions?: ChallengeSubmissionUncheckedUpdateManyWithoutUserNestedInput;
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput;
    gamificationProfile?: GamificationProfileUncheckedUpdateOneWithoutUserNestedInput;
    xpEvents?: XpEventUncheckedUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    reports?: ReportUncheckedUpdateManyWithoutReporterNestedInput;
    uploadedFiles?: FileUncheckedUpdateManyWithoutUploadedByNestedInput;
  };

  export type ChallengeSubmissionUpsertWithWhereUniqueWithoutChallengeInput = {
    where: ChallengeSubmissionWhereUniqueInput;
    update: XOR<
      ChallengeSubmissionUpdateWithoutChallengeInput,
      ChallengeSubmissionUncheckedUpdateWithoutChallengeInput
    >;
    create: XOR<
      ChallengeSubmissionCreateWithoutChallengeInput,
      ChallengeSubmissionUncheckedCreateWithoutChallengeInput
    >;
  };

  export type ChallengeSubmissionUpdateWithWhereUniqueWithoutChallengeInput = {
    where: ChallengeSubmissionWhereUniqueInput;
    data: XOR<
      ChallengeSubmissionUpdateWithoutChallengeInput,
      ChallengeSubmissionUncheckedUpdateWithoutChallengeInput
    >;
  };

  export type ChallengeSubmissionUpdateManyWithWhereWithoutChallengeInput = {
    where: ChallengeSubmissionScalarWhereInput;
    data: XOR<
      ChallengeSubmissionUpdateManyMutationInput,
      ChallengeSubmissionUncheckedUpdateManyWithoutChallengeInput
    >;
  };

  export type ChallengeCreateWithoutSubmissionsInput = {
    id?: string;
    slug: string;
    title: string;
    problemStatement: string;
    ownerOrg?: string | null;
    rewardType?: $Enums.RewardType | null;
    rewardValue?: string | null;
    categories?: ChallengeCreatecategoriesInput | string[];
    skills?: ChallengeCreateskillsInput | string[];
    attachments?: ChallengeCreateattachmentsInput | string[];
    status?: $Enums.ChallengeStatus;
    visibility?: $Enums.ChallengeVisibility;
    deadlineAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    owner: UserCreateNestedOneWithoutOwnedChallengesInput;
  };

  export type ChallengeUncheckedCreateWithoutSubmissionsInput = {
    id?: string;
    slug: string;
    title: string;
    problemStatement: string;
    ownerId: string;
    ownerOrg?: string | null;
    rewardType?: $Enums.RewardType | null;
    rewardValue?: string | null;
    categories?: ChallengeCreatecategoriesInput | string[];
    skills?: ChallengeCreateskillsInput | string[];
    attachments?: ChallengeCreateattachmentsInput | string[];
    status?: $Enums.ChallengeStatus;
    visibility?: $Enums.ChallengeVisibility;
    deadlineAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ChallengeCreateOrConnectWithoutSubmissionsInput = {
    where: ChallengeWhereUniqueInput;
    create: XOR<
      ChallengeCreateWithoutSubmissionsInput,
      ChallengeUncheckedCreateWithoutSubmissionsInput
    >;
  };

  export type UserCreateWithoutChallengeSubmissionsInput = {
    id?: string;
    email: string;
    emailVerified?: Date | string | null;
    name?: string | null;
    handle?: string | null;
    avatarUrl?: string | null;
    bio?: string | null;
    organization?: string | null;
    password?: string | null;
    roles?: UserCreaterolesInput | $Enums.Role[];
    totpSecret?: string | null;
    totpEnabled?: boolean;
    passwordResetToken?: string | null;
    passwordResetExpires?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastLoginAt?: Date | string | null;
    isActive?: boolean;
    isBanned?: boolean;
    accounts?: AccountCreateNestedManyWithoutUserInput;
    sessions?: SessionCreateNestedManyWithoutUserInput;
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput;
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput;
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput;
    mentorProfiles?: MentorCreateNestedManyWithoutUserInput;
    judgeAssignments?: JudgeCreateNestedManyWithoutUserInput;
    comments?: CommentCreateNestedManyWithoutAuthorInput;
    gamificationProfile?: GamificationProfileCreateNestedOneWithoutUserInput;
    xpEvents?: XpEventCreateNestedManyWithoutUserInput;
    notifications?: NotificationCreateNestedManyWithoutUserInput;
    reports?: ReportCreateNestedManyWithoutReporterInput;
    uploadedFiles?: FileCreateNestedManyWithoutUploadedByInput;
    ownedChallenges?: ChallengeCreateNestedManyWithoutOwnerInput;
  };

  export type UserUncheckedCreateWithoutChallengeSubmissionsInput = {
    id?: string;
    email: string;
    emailVerified?: Date | string | null;
    name?: string | null;
    handle?: string | null;
    avatarUrl?: string | null;
    bio?: string | null;
    organization?: string | null;
    password?: string | null;
    roles?: UserCreaterolesInput | $Enums.Role[];
    totpSecret?: string | null;
    totpEnabled?: boolean;
    passwordResetToken?: string | null;
    passwordResetExpires?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastLoginAt?: Date | string | null;
    isActive?: boolean;
    isBanned?: boolean;
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput;
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput;
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput;
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput;
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput;
    mentorProfiles?: MentorUncheckedCreateNestedManyWithoutUserInput;
    judgeAssignments?: JudgeUncheckedCreateNestedManyWithoutUserInput;
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput;
    gamificationProfile?: GamificationProfileUncheckedCreateNestedOneWithoutUserInput;
    xpEvents?: XpEventUncheckedCreateNestedManyWithoutUserInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    reports?: ReportUncheckedCreateNestedManyWithoutReporterInput;
    uploadedFiles?: FileUncheckedCreateNestedManyWithoutUploadedByInput;
    ownedChallenges?: ChallengeUncheckedCreateNestedManyWithoutOwnerInput;
  };

  export type UserCreateOrConnectWithoutChallengeSubmissionsInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutChallengeSubmissionsInput,
      UserUncheckedCreateWithoutChallengeSubmissionsInput
    >;
  };

  export type TeamCreateWithoutChallengeSubmissionsInput = {
    id?: string;
    name: string;
    bio?: string | null;
    logoUrl?: string | null;
    repoUrl?: string | null;
    demoUrl?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    hackathon: HackathonCreateNestedOneWithoutTeamsInput;
    members?: TeamMemberCreateNestedManyWithoutTeamInput;
    submissions?: SubmissionCreateNestedManyWithoutTeamInput;
  };

  export type TeamUncheckedCreateWithoutChallengeSubmissionsInput = {
    id?: string;
    hackathonId: string;
    name: string;
    bio?: string | null;
    logoUrl?: string | null;
    repoUrl?: string | null;
    demoUrl?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    members?: TeamMemberUncheckedCreateNestedManyWithoutTeamInput;
    submissions?: SubmissionUncheckedCreateNestedManyWithoutTeamInput;
  };

  export type TeamCreateOrConnectWithoutChallengeSubmissionsInput = {
    where: TeamWhereUniqueInput;
    create: XOR<
      TeamCreateWithoutChallengeSubmissionsInput,
      TeamUncheckedCreateWithoutChallengeSubmissionsInput
    >;
  };

  export type ChallengeUpsertWithoutSubmissionsInput = {
    update: XOR<
      ChallengeUpdateWithoutSubmissionsInput,
      ChallengeUncheckedUpdateWithoutSubmissionsInput
    >;
    create: XOR<
      ChallengeCreateWithoutSubmissionsInput,
      ChallengeUncheckedCreateWithoutSubmissionsInput
    >;
    where?: ChallengeWhereInput;
  };

  export type ChallengeUpdateToOneWithWhereWithoutSubmissionsInput = {
    where?: ChallengeWhereInput;
    data: XOR<
      ChallengeUpdateWithoutSubmissionsInput,
      ChallengeUncheckedUpdateWithoutSubmissionsInput
    >;
  };

  export type ChallengeUpdateWithoutSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    problemStatement?: StringFieldUpdateOperationsInput | string;
    ownerOrg?: NullableStringFieldUpdateOperationsInput | string | null;
    rewardType?: NullableEnumRewardTypeFieldUpdateOperationsInput | $Enums.RewardType | null;
    rewardValue?: NullableStringFieldUpdateOperationsInput | string | null;
    categories?: ChallengeUpdatecategoriesInput | string[];
    skills?: ChallengeUpdateskillsInput | string[];
    attachments?: ChallengeUpdateattachmentsInput | string[];
    status?: EnumChallengeStatusFieldUpdateOperationsInput | $Enums.ChallengeStatus;
    visibility?: EnumChallengeVisibilityFieldUpdateOperationsInput | $Enums.ChallengeVisibility;
    deadlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    owner?: UserUpdateOneRequiredWithoutOwnedChallengesNestedInput;
  };

  export type ChallengeUncheckedUpdateWithoutSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    problemStatement?: StringFieldUpdateOperationsInput | string;
    ownerId?: StringFieldUpdateOperationsInput | string;
    ownerOrg?: NullableStringFieldUpdateOperationsInput | string | null;
    rewardType?: NullableEnumRewardTypeFieldUpdateOperationsInput | $Enums.RewardType | null;
    rewardValue?: NullableStringFieldUpdateOperationsInput | string | null;
    categories?: ChallengeUpdatecategoriesInput | string[];
    skills?: ChallengeUpdateskillsInput | string[];
    attachments?: ChallengeUpdateattachmentsInput | string[];
    status?: EnumChallengeStatusFieldUpdateOperationsInput | $Enums.ChallengeStatus;
    visibility?: EnumChallengeVisibilityFieldUpdateOperationsInput | $Enums.ChallengeVisibility;
    deadlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type UserUpsertWithoutChallengeSubmissionsInput = {
    update: XOR<
      UserUpdateWithoutChallengeSubmissionsInput,
      UserUncheckedUpdateWithoutChallengeSubmissionsInput
    >;
    create: XOR<
      UserCreateWithoutChallengeSubmissionsInput,
      UserUncheckedCreateWithoutChallengeSubmissionsInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutChallengeSubmissionsInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutChallengeSubmissionsInput,
      UserUncheckedUpdateWithoutChallengeSubmissionsInput
    >;
  };

  export type UserUpdateWithoutChallengeSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    handle?: NullableStringFieldUpdateOperationsInput | string | null;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    organization?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    roles?: UserUpdaterolesInput | $Enums.Role[];
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    totpEnabled?: BoolFieldUpdateOperationsInput | boolean;
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    isBanned?: BoolFieldUpdateOperationsInput | boolean;
    accounts?: AccountUpdateManyWithoutUserNestedInput;
    sessions?: SessionUpdateManyWithoutUserNestedInput;
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput;
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput;
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput;
    mentorProfiles?: MentorUpdateManyWithoutUserNestedInput;
    judgeAssignments?: JudgeUpdateManyWithoutUserNestedInput;
    comments?: CommentUpdateManyWithoutAuthorNestedInput;
    gamificationProfile?: GamificationProfileUpdateOneWithoutUserNestedInput;
    xpEvents?: XpEventUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUpdateManyWithoutUserNestedInput;
    reports?: ReportUpdateManyWithoutReporterNestedInput;
    uploadedFiles?: FileUpdateManyWithoutUploadedByNestedInput;
    ownedChallenges?: ChallengeUpdateManyWithoutOwnerNestedInput;
  };

  export type UserUncheckedUpdateWithoutChallengeSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    handle?: NullableStringFieldUpdateOperationsInput | string | null;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    organization?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    roles?: UserUpdaterolesInput | $Enums.Role[];
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    totpEnabled?: BoolFieldUpdateOperationsInput | boolean;
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    isBanned?: BoolFieldUpdateOperationsInput | boolean;
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput;
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput;
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput;
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput;
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput;
    mentorProfiles?: MentorUncheckedUpdateManyWithoutUserNestedInput;
    judgeAssignments?: JudgeUncheckedUpdateManyWithoutUserNestedInput;
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput;
    gamificationProfile?: GamificationProfileUncheckedUpdateOneWithoutUserNestedInput;
    xpEvents?: XpEventUncheckedUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    reports?: ReportUncheckedUpdateManyWithoutReporterNestedInput;
    uploadedFiles?: FileUncheckedUpdateManyWithoutUploadedByNestedInput;
    ownedChallenges?: ChallengeUncheckedUpdateManyWithoutOwnerNestedInput;
  };

  export type TeamUpsertWithoutChallengeSubmissionsInput = {
    update: XOR<
      TeamUpdateWithoutChallengeSubmissionsInput,
      TeamUncheckedUpdateWithoutChallengeSubmissionsInput
    >;
    create: XOR<
      TeamCreateWithoutChallengeSubmissionsInput,
      TeamUncheckedCreateWithoutChallengeSubmissionsInput
    >;
    where?: TeamWhereInput;
  };

  export type TeamUpdateToOneWithWhereWithoutChallengeSubmissionsInput = {
    where?: TeamWhereInput;
    data: XOR<
      TeamUpdateWithoutChallengeSubmissionsInput,
      TeamUncheckedUpdateWithoutChallengeSubmissionsInput
    >;
  };

  export type TeamUpdateWithoutChallengeSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    repoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    demoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    hackathon?: HackathonUpdateOneRequiredWithoutTeamsNestedInput;
    members?: TeamMemberUpdateManyWithoutTeamNestedInput;
    submissions?: SubmissionUpdateManyWithoutTeamNestedInput;
  };

  export type TeamUncheckedUpdateWithoutChallengeSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    hackathonId?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    repoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    demoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    members?: TeamMemberUncheckedUpdateManyWithoutTeamNestedInput;
    submissions?: SubmissionUncheckedUpdateManyWithoutTeamNestedInput;
  };

  export type HackathonCreateWithoutAnnouncementsInput = {
    id?: string;
    slug: string;
    title: string;
    description: string;
    coverImage?: string | null;
    status?: $Enums.HackathonStatus;
    location?: $Enums.HackathonLocation;
    registrationOpensAt?: Date | string | null;
    registrationClosesAt?: Date | string | null;
    startsAt: Date | string;
    endsAt: Date | string;
    judgingEndsAt?: Date | string | null;
    prizePool?: Decimal | DecimalJsLike | number | string | null;
    maxTeamSize?: number;
    allowSoloTeams?: boolean;
    rules?: string | null;
    schedule?: NullableJsonNullValueInput | InputJsonValue;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    tracks?: TrackCreateNestedManyWithoutHackathonInput;
    teams?: TeamCreateNestedManyWithoutHackathonInput;
    mentors?: MentorCreateNestedManyWithoutHackathonInput;
    judges?: JudgeCreateNestedManyWithoutHackathonInput;
    criteria?: CriteriaCreateNestedManyWithoutHackathonInput;
    submissions?: SubmissionCreateNestedManyWithoutHackathonInput;
  };

  export type HackathonUncheckedCreateWithoutAnnouncementsInput = {
    id?: string;
    slug: string;
    title: string;
    description: string;
    coverImage?: string | null;
    status?: $Enums.HackathonStatus;
    location?: $Enums.HackathonLocation;
    registrationOpensAt?: Date | string | null;
    registrationClosesAt?: Date | string | null;
    startsAt: Date | string;
    endsAt: Date | string;
    judgingEndsAt?: Date | string | null;
    prizePool?: Decimal | DecimalJsLike | number | string | null;
    maxTeamSize?: number;
    allowSoloTeams?: boolean;
    rules?: string | null;
    schedule?: NullableJsonNullValueInput | InputJsonValue;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    tracks?: TrackUncheckedCreateNestedManyWithoutHackathonInput;
    teams?: TeamUncheckedCreateNestedManyWithoutHackathonInput;
    mentors?: MentorUncheckedCreateNestedManyWithoutHackathonInput;
    judges?: JudgeUncheckedCreateNestedManyWithoutHackathonInput;
    criteria?: CriteriaUncheckedCreateNestedManyWithoutHackathonInput;
    submissions?: SubmissionUncheckedCreateNestedManyWithoutHackathonInput;
  };

  export type HackathonCreateOrConnectWithoutAnnouncementsInput = {
    where: HackathonWhereUniqueInput;
    create: XOR<
      HackathonCreateWithoutAnnouncementsInput,
      HackathonUncheckedCreateWithoutAnnouncementsInput
    >;
  };

  export type HackathonUpsertWithoutAnnouncementsInput = {
    update: XOR<
      HackathonUpdateWithoutAnnouncementsInput,
      HackathonUncheckedUpdateWithoutAnnouncementsInput
    >;
    create: XOR<
      HackathonCreateWithoutAnnouncementsInput,
      HackathonUncheckedCreateWithoutAnnouncementsInput
    >;
    where?: HackathonWhereInput;
  };

  export type HackathonUpdateToOneWithWhereWithoutAnnouncementsInput = {
    where?: HackathonWhereInput;
    data: XOR<
      HackathonUpdateWithoutAnnouncementsInput,
      HackathonUncheckedUpdateWithoutAnnouncementsInput
    >;
  };

  export type HackathonUpdateWithoutAnnouncementsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumHackathonStatusFieldUpdateOperationsInput | $Enums.HackathonStatus;
    location?: EnumHackathonLocationFieldUpdateOperationsInput | $Enums.HackathonLocation;
    registrationOpensAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    registrationClosesAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    judgingEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    prizePool?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    maxTeamSize?: IntFieldUpdateOperationsInput | number;
    allowSoloTeams?: BoolFieldUpdateOperationsInput | boolean;
    rules?: NullableStringFieldUpdateOperationsInput | string | null;
    schedule?: NullableJsonNullValueInput | InputJsonValue;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    tracks?: TrackUpdateManyWithoutHackathonNestedInput;
    teams?: TeamUpdateManyWithoutHackathonNestedInput;
    mentors?: MentorUpdateManyWithoutHackathonNestedInput;
    judges?: JudgeUpdateManyWithoutHackathonNestedInput;
    criteria?: CriteriaUpdateManyWithoutHackathonNestedInput;
    submissions?: SubmissionUpdateManyWithoutHackathonNestedInput;
  };

  export type HackathonUncheckedUpdateWithoutAnnouncementsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumHackathonStatusFieldUpdateOperationsInput | $Enums.HackathonStatus;
    location?: EnumHackathonLocationFieldUpdateOperationsInput | $Enums.HackathonLocation;
    registrationOpensAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    registrationClosesAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    judgingEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    prizePool?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    maxTeamSize?: IntFieldUpdateOperationsInput | number;
    allowSoloTeams?: BoolFieldUpdateOperationsInput | boolean;
    rules?: NullableStringFieldUpdateOperationsInput | string | null;
    schedule?: NullableJsonNullValueInput | InputJsonValue;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    tracks?: TrackUncheckedUpdateManyWithoutHackathonNestedInput;
    teams?: TeamUncheckedUpdateManyWithoutHackathonNestedInput;
    mentors?: MentorUncheckedUpdateManyWithoutHackathonNestedInput;
    judges?: JudgeUncheckedUpdateManyWithoutHackathonNestedInput;
    criteria?: CriteriaUncheckedUpdateManyWithoutHackathonNestedInput;
    submissions?: SubmissionUncheckedUpdateManyWithoutHackathonNestedInput;
  };

  export type CommentCreateWithoutThreadInput = {
    id?: string;
    body: string;
    isFlagged?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    author: UserCreateNestedOneWithoutCommentsInput;
    parent?: CommentCreateNestedOneWithoutRepliesInput;
    replies?: CommentCreateNestedManyWithoutParentInput;
  };

  export type CommentUncheckedCreateWithoutThreadInput = {
    id?: string;
    authorId: string;
    parentId?: string | null;
    body: string;
    isFlagged?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    replies?: CommentUncheckedCreateNestedManyWithoutParentInput;
  };

  export type CommentCreateOrConnectWithoutThreadInput = {
    where: CommentWhereUniqueInput;
    create: XOR<CommentCreateWithoutThreadInput, CommentUncheckedCreateWithoutThreadInput>;
  };

  export type CommentCreateManyThreadInputEnvelope = {
    data: CommentCreateManyThreadInput | CommentCreateManyThreadInput[];
    skipDuplicates?: boolean;
  };

  export type CommentUpsertWithWhereUniqueWithoutThreadInput = {
    where: CommentWhereUniqueInput;
    update: XOR<CommentUpdateWithoutThreadInput, CommentUncheckedUpdateWithoutThreadInput>;
    create: XOR<CommentCreateWithoutThreadInput, CommentUncheckedCreateWithoutThreadInput>;
  };

  export type CommentUpdateWithWhereUniqueWithoutThreadInput = {
    where: CommentWhereUniqueInput;
    data: XOR<CommentUpdateWithoutThreadInput, CommentUncheckedUpdateWithoutThreadInput>;
  };

  export type CommentUpdateManyWithWhereWithoutThreadInput = {
    where: CommentScalarWhereInput;
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutThreadInput>;
  };

  export type CommentThreadCreateWithoutCommentsInput = {
    id?: string;
    entityType: $Enums.CommentEntityType;
    entityId: string;
    createdAt?: Date | string;
  };

  export type CommentThreadUncheckedCreateWithoutCommentsInput = {
    id?: string;
    entityType: $Enums.CommentEntityType;
    entityId: string;
    createdAt?: Date | string;
  };

  export type CommentThreadCreateOrConnectWithoutCommentsInput = {
    where: CommentThreadWhereUniqueInput;
    create: XOR<
      CommentThreadCreateWithoutCommentsInput,
      CommentThreadUncheckedCreateWithoutCommentsInput
    >;
  };

  export type UserCreateWithoutCommentsInput = {
    id?: string;
    email: string;
    emailVerified?: Date | string | null;
    name?: string | null;
    handle?: string | null;
    avatarUrl?: string | null;
    bio?: string | null;
    organization?: string | null;
    password?: string | null;
    roles?: UserCreaterolesInput | $Enums.Role[];
    totpSecret?: string | null;
    totpEnabled?: boolean;
    passwordResetToken?: string | null;
    passwordResetExpires?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastLoginAt?: Date | string | null;
    isActive?: boolean;
    isBanned?: boolean;
    accounts?: AccountCreateNestedManyWithoutUserInput;
    sessions?: SessionCreateNestedManyWithoutUserInput;
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput;
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput;
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput;
    mentorProfiles?: MentorCreateNestedManyWithoutUserInput;
    judgeAssignments?: JudgeCreateNestedManyWithoutUserInput;
    challengeSubmissions?: ChallengeSubmissionCreateNestedManyWithoutUserInput;
    gamificationProfile?: GamificationProfileCreateNestedOneWithoutUserInput;
    xpEvents?: XpEventCreateNestedManyWithoutUserInput;
    notifications?: NotificationCreateNestedManyWithoutUserInput;
    reports?: ReportCreateNestedManyWithoutReporterInput;
    uploadedFiles?: FileCreateNestedManyWithoutUploadedByInput;
    ownedChallenges?: ChallengeCreateNestedManyWithoutOwnerInput;
  };

  export type UserUncheckedCreateWithoutCommentsInput = {
    id?: string;
    email: string;
    emailVerified?: Date | string | null;
    name?: string | null;
    handle?: string | null;
    avatarUrl?: string | null;
    bio?: string | null;
    organization?: string | null;
    password?: string | null;
    roles?: UserCreaterolesInput | $Enums.Role[];
    totpSecret?: string | null;
    totpEnabled?: boolean;
    passwordResetToken?: string | null;
    passwordResetExpires?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastLoginAt?: Date | string | null;
    isActive?: boolean;
    isBanned?: boolean;
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput;
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput;
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput;
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput;
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput;
    mentorProfiles?: MentorUncheckedCreateNestedManyWithoutUserInput;
    judgeAssignments?: JudgeUncheckedCreateNestedManyWithoutUserInput;
    challengeSubmissions?: ChallengeSubmissionUncheckedCreateNestedManyWithoutUserInput;
    gamificationProfile?: GamificationProfileUncheckedCreateNestedOneWithoutUserInput;
    xpEvents?: XpEventUncheckedCreateNestedManyWithoutUserInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    reports?: ReportUncheckedCreateNestedManyWithoutReporterInput;
    uploadedFiles?: FileUncheckedCreateNestedManyWithoutUploadedByInput;
    ownedChallenges?: ChallengeUncheckedCreateNestedManyWithoutOwnerInput;
  };

  export type UserCreateOrConnectWithoutCommentsInput = {
    where: UserWhereUniqueInput;
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>;
  };

  export type CommentCreateWithoutRepliesInput = {
    id?: string;
    body: string;
    isFlagged?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    thread: CommentThreadCreateNestedOneWithoutCommentsInput;
    author: UserCreateNestedOneWithoutCommentsInput;
    parent?: CommentCreateNestedOneWithoutRepliesInput;
  };

  export type CommentUncheckedCreateWithoutRepliesInput = {
    id?: string;
    threadId: string;
    authorId: string;
    parentId?: string | null;
    body: string;
    isFlagged?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type CommentCreateOrConnectWithoutRepliesInput = {
    where: CommentWhereUniqueInput;
    create: XOR<CommentCreateWithoutRepliesInput, CommentUncheckedCreateWithoutRepliesInput>;
  };

  export type CommentCreateWithoutParentInput = {
    id?: string;
    body: string;
    isFlagged?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    thread: CommentThreadCreateNestedOneWithoutCommentsInput;
    author: UserCreateNestedOneWithoutCommentsInput;
    replies?: CommentCreateNestedManyWithoutParentInput;
  };

  export type CommentUncheckedCreateWithoutParentInput = {
    id?: string;
    threadId: string;
    authorId: string;
    body: string;
    isFlagged?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    replies?: CommentUncheckedCreateNestedManyWithoutParentInput;
  };

  export type CommentCreateOrConnectWithoutParentInput = {
    where: CommentWhereUniqueInput;
    create: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput>;
  };

  export type CommentCreateManyParentInputEnvelope = {
    data: CommentCreateManyParentInput | CommentCreateManyParentInput[];
    skipDuplicates?: boolean;
  };

  export type CommentThreadUpsertWithoutCommentsInput = {
    update: XOR<
      CommentThreadUpdateWithoutCommentsInput,
      CommentThreadUncheckedUpdateWithoutCommentsInput
    >;
    create: XOR<
      CommentThreadCreateWithoutCommentsInput,
      CommentThreadUncheckedCreateWithoutCommentsInput
    >;
    where?: CommentThreadWhereInput;
  };

  export type CommentThreadUpdateToOneWithWhereWithoutCommentsInput = {
    where?: CommentThreadWhereInput;
    data: XOR<
      CommentThreadUpdateWithoutCommentsInput,
      CommentThreadUncheckedUpdateWithoutCommentsInput
    >;
  };

  export type CommentThreadUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    entityType?: EnumCommentEntityTypeFieldUpdateOperationsInput | $Enums.CommentEntityType;
    entityId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type CommentThreadUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    entityType?: EnumCommentEntityTypeFieldUpdateOperationsInput | $Enums.CommentEntityType;
    entityId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type UserUpsertWithoutCommentsInput = {
    update: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>;
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutCommentsInput = {
    where?: UserWhereInput;
    data: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>;
  };

  export type UserUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    handle?: NullableStringFieldUpdateOperationsInput | string | null;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    organization?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    roles?: UserUpdaterolesInput | $Enums.Role[];
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    totpEnabled?: BoolFieldUpdateOperationsInput | boolean;
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    isBanned?: BoolFieldUpdateOperationsInput | boolean;
    accounts?: AccountUpdateManyWithoutUserNestedInput;
    sessions?: SessionUpdateManyWithoutUserNestedInput;
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput;
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput;
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput;
    mentorProfiles?: MentorUpdateManyWithoutUserNestedInput;
    judgeAssignments?: JudgeUpdateManyWithoutUserNestedInput;
    challengeSubmissions?: ChallengeSubmissionUpdateManyWithoutUserNestedInput;
    gamificationProfile?: GamificationProfileUpdateOneWithoutUserNestedInput;
    xpEvents?: XpEventUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUpdateManyWithoutUserNestedInput;
    reports?: ReportUpdateManyWithoutReporterNestedInput;
    uploadedFiles?: FileUpdateManyWithoutUploadedByNestedInput;
    ownedChallenges?: ChallengeUpdateManyWithoutOwnerNestedInput;
  };

  export type UserUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    handle?: NullableStringFieldUpdateOperationsInput | string | null;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    organization?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    roles?: UserUpdaterolesInput | $Enums.Role[];
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    totpEnabled?: BoolFieldUpdateOperationsInput | boolean;
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    isBanned?: BoolFieldUpdateOperationsInput | boolean;
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput;
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput;
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput;
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput;
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput;
    mentorProfiles?: MentorUncheckedUpdateManyWithoutUserNestedInput;
    judgeAssignments?: JudgeUncheckedUpdateManyWithoutUserNestedInput;
    challengeSubmissions?: ChallengeSubmissionUncheckedUpdateManyWithoutUserNestedInput;
    gamificationProfile?: GamificationProfileUncheckedUpdateOneWithoutUserNestedInput;
    xpEvents?: XpEventUncheckedUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    reports?: ReportUncheckedUpdateManyWithoutReporterNestedInput;
    uploadedFiles?: FileUncheckedUpdateManyWithoutUploadedByNestedInput;
    ownedChallenges?: ChallengeUncheckedUpdateManyWithoutOwnerNestedInput;
  };

  export type CommentUpsertWithoutRepliesInput = {
    update: XOR<CommentUpdateWithoutRepliesInput, CommentUncheckedUpdateWithoutRepliesInput>;
    create: XOR<CommentCreateWithoutRepliesInput, CommentUncheckedCreateWithoutRepliesInput>;
    where?: CommentWhereInput;
  };

  export type CommentUpdateToOneWithWhereWithoutRepliesInput = {
    where?: CommentWhereInput;
    data: XOR<CommentUpdateWithoutRepliesInput, CommentUncheckedUpdateWithoutRepliesInput>;
  };

  export type CommentUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    body?: StringFieldUpdateOperationsInput | string;
    isFlagged?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    thread?: CommentThreadUpdateOneRequiredWithoutCommentsNestedInput;
    author?: UserUpdateOneRequiredWithoutCommentsNestedInput;
    parent?: CommentUpdateOneWithoutRepliesNestedInput;
  };

  export type CommentUncheckedUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    threadId?: StringFieldUpdateOperationsInput | string;
    authorId?: StringFieldUpdateOperationsInput | string;
    parentId?: NullableStringFieldUpdateOperationsInput | string | null;
    body?: StringFieldUpdateOperationsInput | string;
    isFlagged?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type CommentUpsertWithWhereUniqueWithoutParentInput = {
    where: CommentWhereUniqueInput;
    update: XOR<CommentUpdateWithoutParentInput, CommentUncheckedUpdateWithoutParentInput>;
    create: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput>;
  };

  export type CommentUpdateWithWhereUniqueWithoutParentInput = {
    where: CommentWhereUniqueInput;
    data: XOR<CommentUpdateWithoutParentInput, CommentUncheckedUpdateWithoutParentInput>;
  };

  export type CommentUpdateManyWithWhereWithoutParentInput = {
    where: CommentScalarWhereInput;
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutParentInput>;
  };

  export type UserCreateWithoutGamificationProfileInput = {
    id?: string;
    email: string;
    emailVerified?: Date | string | null;
    name?: string | null;
    handle?: string | null;
    avatarUrl?: string | null;
    bio?: string | null;
    organization?: string | null;
    password?: string | null;
    roles?: UserCreaterolesInput | $Enums.Role[];
    totpSecret?: string | null;
    totpEnabled?: boolean;
    passwordResetToken?: string | null;
    passwordResetExpires?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastLoginAt?: Date | string | null;
    isActive?: boolean;
    isBanned?: boolean;
    accounts?: AccountCreateNestedManyWithoutUserInput;
    sessions?: SessionCreateNestedManyWithoutUserInput;
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput;
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput;
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput;
    mentorProfiles?: MentorCreateNestedManyWithoutUserInput;
    judgeAssignments?: JudgeCreateNestedManyWithoutUserInput;
    challengeSubmissions?: ChallengeSubmissionCreateNestedManyWithoutUserInput;
    comments?: CommentCreateNestedManyWithoutAuthorInput;
    xpEvents?: XpEventCreateNestedManyWithoutUserInput;
    notifications?: NotificationCreateNestedManyWithoutUserInput;
    reports?: ReportCreateNestedManyWithoutReporterInput;
    uploadedFiles?: FileCreateNestedManyWithoutUploadedByInput;
    ownedChallenges?: ChallengeCreateNestedManyWithoutOwnerInput;
  };

  export type UserUncheckedCreateWithoutGamificationProfileInput = {
    id?: string;
    email: string;
    emailVerified?: Date | string | null;
    name?: string | null;
    handle?: string | null;
    avatarUrl?: string | null;
    bio?: string | null;
    organization?: string | null;
    password?: string | null;
    roles?: UserCreaterolesInput | $Enums.Role[];
    totpSecret?: string | null;
    totpEnabled?: boolean;
    passwordResetToken?: string | null;
    passwordResetExpires?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastLoginAt?: Date | string | null;
    isActive?: boolean;
    isBanned?: boolean;
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput;
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput;
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput;
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput;
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput;
    mentorProfiles?: MentorUncheckedCreateNestedManyWithoutUserInput;
    judgeAssignments?: JudgeUncheckedCreateNestedManyWithoutUserInput;
    challengeSubmissions?: ChallengeSubmissionUncheckedCreateNestedManyWithoutUserInput;
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput;
    xpEvents?: XpEventUncheckedCreateNestedManyWithoutUserInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    reports?: ReportUncheckedCreateNestedManyWithoutReporterInput;
    uploadedFiles?: FileUncheckedCreateNestedManyWithoutUploadedByInput;
    ownedChallenges?: ChallengeUncheckedCreateNestedManyWithoutOwnerInput;
  };

  export type UserCreateOrConnectWithoutGamificationProfileInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutGamificationProfileInput,
      UserUncheckedCreateWithoutGamificationProfileInput
    >;
  };

  export type UserUpsertWithoutGamificationProfileInput = {
    update: XOR<
      UserUpdateWithoutGamificationProfileInput,
      UserUncheckedUpdateWithoutGamificationProfileInput
    >;
    create: XOR<
      UserCreateWithoutGamificationProfileInput,
      UserUncheckedCreateWithoutGamificationProfileInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutGamificationProfileInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutGamificationProfileInput,
      UserUncheckedUpdateWithoutGamificationProfileInput
    >;
  };

  export type UserUpdateWithoutGamificationProfileInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    handle?: NullableStringFieldUpdateOperationsInput | string | null;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    organization?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    roles?: UserUpdaterolesInput | $Enums.Role[];
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    totpEnabled?: BoolFieldUpdateOperationsInput | boolean;
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    isBanned?: BoolFieldUpdateOperationsInput | boolean;
    accounts?: AccountUpdateManyWithoutUserNestedInput;
    sessions?: SessionUpdateManyWithoutUserNestedInput;
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput;
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput;
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput;
    mentorProfiles?: MentorUpdateManyWithoutUserNestedInput;
    judgeAssignments?: JudgeUpdateManyWithoutUserNestedInput;
    challengeSubmissions?: ChallengeSubmissionUpdateManyWithoutUserNestedInput;
    comments?: CommentUpdateManyWithoutAuthorNestedInput;
    xpEvents?: XpEventUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUpdateManyWithoutUserNestedInput;
    reports?: ReportUpdateManyWithoutReporterNestedInput;
    uploadedFiles?: FileUpdateManyWithoutUploadedByNestedInput;
    ownedChallenges?: ChallengeUpdateManyWithoutOwnerNestedInput;
  };

  export type UserUncheckedUpdateWithoutGamificationProfileInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    handle?: NullableStringFieldUpdateOperationsInput | string | null;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    organization?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    roles?: UserUpdaterolesInput | $Enums.Role[];
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    totpEnabled?: BoolFieldUpdateOperationsInput | boolean;
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    isBanned?: BoolFieldUpdateOperationsInput | boolean;
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput;
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput;
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput;
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput;
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput;
    mentorProfiles?: MentorUncheckedUpdateManyWithoutUserNestedInput;
    judgeAssignments?: JudgeUncheckedUpdateManyWithoutUserNestedInput;
    challengeSubmissions?: ChallengeSubmissionUncheckedUpdateManyWithoutUserNestedInput;
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput;
    xpEvents?: XpEventUncheckedUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    reports?: ReportUncheckedUpdateManyWithoutReporterNestedInput;
    uploadedFiles?: FileUncheckedUpdateManyWithoutUploadedByNestedInput;
    ownedChallenges?: ChallengeUncheckedUpdateManyWithoutOwnerNestedInput;
  };

  export type UserCreateWithoutXpEventsInput = {
    id?: string;
    email: string;
    emailVerified?: Date | string | null;
    name?: string | null;
    handle?: string | null;
    avatarUrl?: string | null;
    bio?: string | null;
    organization?: string | null;
    password?: string | null;
    roles?: UserCreaterolesInput | $Enums.Role[];
    totpSecret?: string | null;
    totpEnabled?: boolean;
    passwordResetToken?: string | null;
    passwordResetExpires?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastLoginAt?: Date | string | null;
    isActive?: boolean;
    isBanned?: boolean;
    accounts?: AccountCreateNestedManyWithoutUserInput;
    sessions?: SessionCreateNestedManyWithoutUserInput;
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput;
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput;
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput;
    mentorProfiles?: MentorCreateNestedManyWithoutUserInput;
    judgeAssignments?: JudgeCreateNestedManyWithoutUserInput;
    challengeSubmissions?: ChallengeSubmissionCreateNestedManyWithoutUserInput;
    comments?: CommentCreateNestedManyWithoutAuthorInput;
    gamificationProfile?: GamificationProfileCreateNestedOneWithoutUserInput;
    notifications?: NotificationCreateNestedManyWithoutUserInput;
    reports?: ReportCreateNestedManyWithoutReporterInput;
    uploadedFiles?: FileCreateNestedManyWithoutUploadedByInput;
    ownedChallenges?: ChallengeCreateNestedManyWithoutOwnerInput;
  };

  export type UserUncheckedCreateWithoutXpEventsInput = {
    id?: string;
    email: string;
    emailVerified?: Date | string | null;
    name?: string | null;
    handle?: string | null;
    avatarUrl?: string | null;
    bio?: string | null;
    organization?: string | null;
    password?: string | null;
    roles?: UserCreaterolesInput | $Enums.Role[];
    totpSecret?: string | null;
    totpEnabled?: boolean;
    passwordResetToken?: string | null;
    passwordResetExpires?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastLoginAt?: Date | string | null;
    isActive?: boolean;
    isBanned?: boolean;
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput;
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput;
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput;
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput;
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput;
    mentorProfiles?: MentorUncheckedCreateNestedManyWithoutUserInput;
    judgeAssignments?: JudgeUncheckedCreateNestedManyWithoutUserInput;
    challengeSubmissions?: ChallengeSubmissionUncheckedCreateNestedManyWithoutUserInput;
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput;
    gamificationProfile?: GamificationProfileUncheckedCreateNestedOneWithoutUserInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    reports?: ReportUncheckedCreateNestedManyWithoutReporterInput;
    uploadedFiles?: FileUncheckedCreateNestedManyWithoutUploadedByInput;
    ownedChallenges?: ChallengeUncheckedCreateNestedManyWithoutOwnerInput;
  };

  export type UserCreateOrConnectWithoutXpEventsInput = {
    where: UserWhereUniqueInput;
    create: XOR<UserCreateWithoutXpEventsInput, UserUncheckedCreateWithoutXpEventsInput>;
  };

  export type UserUpsertWithoutXpEventsInput = {
    update: XOR<UserUpdateWithoutXpEventsInput, UserUncheckedUpdateWithoutXpEventsInput>;
    create: XOR<UserCreateWithoutXpEventsInput, UserUncheckedCreateWithoutXpEventsInput>;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutXpEventsInput = {
    where?: UserWhereInput;
    data: XOR<UserUpdateWithoutXpEventsInput, UserUncheckedUpdateWithoutXpEventsInput>;
  };

  export type UserUpdateWithoutXpEventsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    handle?: NullableStringFieldUpdateOperationsInput | string | null;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    organization?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    roles?: UserUpdaterolesInput | $Enums.Role[];
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    totpEnabled?: BoolFieldUpdateOperationsInput | boolean;
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    isBanned?: BoolFieldUpdateOperationsInput | boolean;
    accounts?: AccountUpdateManyWithoutUserNestedInput;
    sessions?: SessionUpdateManyWithoutUserNestedInput;
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput;
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput;
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput;
    mentorProfiles?: MentorUpdateManyWithoutUserNestedInput;
    judgeAssignments?: JudgeUpdateManyWithoutUserNestedInput;
    challengeSubmissions?: ChallengeSubmissionUpdateManyWithoutUserNestedInput;
    comments?: CommentUpdateManyWithoutAuthorNestedInput;
    gamificationProfile?: GamificationProfileUpdateOneWithoutUserNestedInput;
    notifications?: NotificationUpdateManyWithoutUserNestedInput;
    reports?: ReportUpdateManyWithoutReporterNestedInput;
    uploadedFiles?: FileUpdateManyWithoutUploadedByNestedInput;
    ownedChallenges?: ChallengeUpdateManyWithoutOwnerNestedInput;
  };

  export type UserUncheckedUpdateWithoutXpEventsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    handle?: NullableStringFieldUpdateOperationsInput | string | null;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    organization?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    roles?: UserUpdaterolesInput | $Enums.Role[];
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    totpEnabled?: BoolFieldUpdateOperationsInput | boolean;
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    isBanned?: BoolFieldUpdateOperationsInput | boolean;
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput;
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput;
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput;
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput;
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput;
    mentorProfiles?: MentorUncheckedUpdateManyWithoutUserNestedInput;
    judgeAssignments?: JudgeUncheckedUpdateManyWithoutUserNestedInput;
    challengeSubmissions?: ChallengeSubmissionUncheckedUpdateManyWithoutUserNestedInput;
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput;
    gamificationProfile?: GamificationProfileUncheckedUpdateOneWithoutUserNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    reports?: ReportUncheckedUpdateManyWithoutReporterNestedInput;
    uploadedFiles?: FileUncheckedUpdateManyWithoutUploadedByNestedInput;
    ownedChallenges?: ChallengeUncheckedUpdateManyWithoutOwnerNestedInput;
  };

  export type UserCreateWithoutNotificationsInput = {
    id?: string;
    email: string;
    emailVerified?: Date | string | null;
    name?: string | null;
    handle?: string | null;
    avatarUrl?: string | null;
    bio?: string | null;
    organization?: string | null;
    password?: string | null;
    roles?: UserCreaterolesInput | $Enums.Role[];
    totpSecret?: string | null;
    totpEnabled?: boolean;
    passwordResetToken?: string | null;
    passwordResetExpires?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastLoginAt?: Date | string | null;
    isActive?: boolean;
    isBanned?: boolean;
    accounts?: AccountCreateNestedManyWithoutUserInput;
    sessions?: SessionCreateNestedManyWithoutUserInput;
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput;
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput;
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput;
    mentorProfiles?: MentorCreateNestedManyWithoutUserInput;
    judgeAssignments?: JudgeCreateNestedManyWithoutUserInput;
    challengeSubmissions?: ChallengeSubmissionCreateNestedManyWithoutUserInput;
    comments?: CommentCreateNestedManyWithoutAuthorInput;
    gamificationProfile?: GamificationProfileCreateNestedOneWithoutUserInput;
    xpEvents?: XpEventCreateNestedManyWithoutUserInput;
    reports?: ReportCreateNestedManyWithoutReporterInput;
    uploadedFiles?: FileCreateNestedManyWithoutUploadedByInput;
    ownedChallenges?: ChallengeCreateNestedManyWithoutOwnerInput;
  };

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string;
    email: string;
    emailVerified?: Date | string | null;
    name?: string | null;
    handle?: string | null;
    avatarUrl?: string | null;
    bio?: string | null;
    organization?: string | null;
    password?: string | null;
    roles?: UserCreaterolesInput | $Enums.Role[];
    totpSecret?: string | null;
    totpEnabled?: boolean;
    passwordResetToken?: string | null;
    passwordResetExpires?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastLoginAt?: Date | string | null;
    isActive?: boolean;
    isBanned?: boolean;
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput;
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput;
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput;
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput;
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput;
    mentorProfiles?: MentorUncheckedCreateNestedManyWithoutUserInput;
    judgeAssignments?: JudgeUncheckedCreateNestedManyWithoutUserInput;
    challengeSubmissions?: ChallengeSubmissionUncheckedCreateNestedManyWithoutUserInput;
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput;
    gamificationProfile?: GamificationProfileUncheckedCreateNestedOneWithoutUserInput;
    xpEvents?: XpEventUncheckedCreateNestedManyWithoutUserInput;
    reports?: ReportUncheckedCreateNestedManyWithoutReporterInput;
    uploadedFiles?: FileUncheckedCreateNestedManyWithoutUploadedByInput;
    ownedChallenges?: ChallengeUncheckedCreateNestedManyWithoutOwnerInput;
  };

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput;
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>;
  };

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>;
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput;
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>;
  };

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    handle?: NullableStringFieldUpdateOperationsInput | string | null;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    organization?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    roles?: UserUpdaterolesInput | $Enums.Role[];
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    totpEnabled?: BoolFieldUpdateOperationsInput | boolean;
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    isBanned?: BoolFieldUpdateOperationsInput | boolean;
    accounts?: AccountUpdateManyWithoutUserNestedInput;
    sessions?: SessionUpdateManyWithoutUserNestedInput;
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput;
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput;
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput;
    mentorProfiles?: MentorUpdateManyWithoutUserNestedInput;
    judgeAssignments?: JudgeUpdateManyWithoutUserNestedInput;
    challengeSubmissions?: ChallengeSubmissionUpdateManyWithoutUserNestedInput;
    comments?: CommentUpdateManyWithoutAuthorNestedInput;
    gamificationProfile?: GamificationProfileUpdateOneWithoutUserNestedInput;
    xpEvents?: XpEventUpdateManyWithoutUserNestedInput;
    reports?: ReportUpdateManyWithoutReporterNestedInput;
    uploadedFiles?: FileUpdateManyWithoutUploadedByNestedInput;
    ownedChallenges?: ChallengeUpdateManyWithoutOwnerNestedInput;
  };

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    handle?: NullableStringFieldUpdateOperationsInput | string | null;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    organization?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    roles?: UserUpdaterolesInput | $Enums.Role[];
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    totpEnabled?: BoolFieldUpdateOperationsInput | boolean;
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    isBanned?: BoolFieldUpdateOperationsInput | boolean;
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput;
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput;
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput;
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput;
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput;
    mentorProfiles?: MentorUncheckedUpdateManyWithoutUserNestedInput;
    judgeAssignments?: JudgeUncheckedUpdateManyWithoutUserNestedInput;
    challengeSubmissions?: ChallengeSubmissionUncheckedUpdateManyWithoutUserNestedInput;
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput;
    gamificationProfile?: GamificationProfileUncheckedUpdateOneWithoutUserNestedInput;
    xpEvents?: XpEventUncheckedUpdateManyWithoutUserNestedInput;
    reports?: ReportUncheckedUpdateManyWithoutReporterNestedInput;
    uploadedFiles?: FileUncheckedUpdateManyWithoutUploadedByNestedInput;
    ownedChallenges?: ChallengeUncheckedUpdateManyWithoutOwnerNestedInput;
  };

  export type UserCreateWithoutReportsInput = {
    id?: string;
    email: string;
    emailVerified?: Date | string | null;
    name?: string | null;
    handle?: string | null;
    avatarUrl?: string | null;
    bio?: string | null;
    organization?: string | null;
    password?: string | null;
    roles?: UserCreaterolesInput | $Enums.Role[];
    totpSecret?: string | null;
    totpEnabled?: boolean;
    passwordResetToken?: string | null;
    passwordResetExpires?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastLoginAt?: Date | string | null;
    isActive?: boolean;
    isBanned?: boolean;
    accounts?: AccountCreateNestedManyWithoutUserInput;
    sessions?: SessionCreateNestedManyWithoutUserInput;
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput;
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput;
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput;
    mentorProfiles?: MentorCreateNestedManyWithoutUserInput;
    judgeAssignments?: JudgeCreateNestedManyWithoutUserInput;
    challengeSubmissions?: ChallengeSubmissionCreateNestedManyWithoutUserInput;
    comments?: CommentCreateNestedManyWithoutAuthorInput;
    gamificationProfile?: GamificationProfileCreateNestedOneWithoutUserInput;
    xpEvents?: XpEventCreateNestedManyWithoutUserInput;
    notifications?: NotificationCreateNestedManyWithoutUserInput;
    uploadedFiles?: FileCreateNestedManyWithoutUploadedByInput;
    ownedChallenges?: ChallengeCreateNestedManyWithoutOwnerInput;
  };

  export type UserUncheckedCreateWithoutReportsInput = {
    id?: string;
    email: string;
    emailVerified?: Date | string | null;
    name?: string | null;
    handle?: string | null;
    avatarUrl?: string | null;
    bio?: string | null;
    organization?: string | null;
    password?: string | null;
    roles?: UserCreaterolesInput | $Enums.Role[];
    totpSecret?: string | null;
    totpEnabled?: boolean;
    passwordResetToken?: string | null;
    passwordResetExpires?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastLoginAt?: Date | string | null;
    isActive?: boolean;
    isBanned?: boolean;
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput;
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput;
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput;
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput;
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput;
    mentorProfiles?: MentorUncheckedCreateNestedManyWithoutUserInput;
    judgeAssignments?: JudgeUncheckedCreateNestedManyWithoutUserInput;
    challengeSubmissions?: ChallengeSubmissionUncheckedCreateNestedManyWithoutUserInput;
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput;
    gamificationProfile?: GamificationProfileUncheckedCreateNestedOneWithoutUserInput;
    xpEvents?: XpEventUncheckedCreateNestedManyWithoutUserInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    uploadedFiles?: FileUncheckedCreateNestedManyWithoutUploadedByInput;
    ownedChallenges?: ChallengeUncheckedCreateNestedManyWithoutOwnerInput;
  };

  export type UserCreateOrConnectWithoutReportsInput = {
    where: UserWhereUniqueInput;
    create: XOR<UserCreateWithoutReportsInput, UserUncheckedCreateWithoutReportsInput>;
  };

  export type UserUpsertWithoutReportsInput = {
    update: XOR<UserUpdateWithoutReportsInput, UserUncheckedUpdateWithoutReportsInput>;
    create: XOR<UserCreateWithoutReportsInput, UserUncheckedCreateWithoutReportsInput>;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutReportsInput = {
    where?: UserWhereInput;
    data: XOR<UserUpdateWithoutReportsInput, UserUncheckedUpdateWithoutReportsInput>;
  };

  export type UserUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    handle?: NullableStringFieldUpdateOperationsInput | string | null;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    organization?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    roles?: UserUpdaterolesInput | $Enums.Role[];
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    totpEnabled?: BoolFieldUpdateOperationsInput | boolean;
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    isBanned?: BoolFieldUpdateOperationsInput | boolean;
    accounts?: AccountUpdateManyWithoutUserNestedInput;
    sessions?: SessionUpdateManyWithoutUserNestedInput;
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput;
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput;
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput;
    mentorProfiles?: MentorUpdateManyWithoutUserNestedInput;
    judgeAssignments?: JudgeUpdateManyWithoutUserNestedInput;
    challengeSubmissions?: ChallengeSubmissionUpdateManyWithoutUserNestedInput;
    comments?: CommentUpdateManyWithoutAuthorNestedInput;
    gamificationProfile?: GamificationProfileUpdateOneWithoutUserNestedInput;
    xpEvents?: XpEventUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUpdateManyWithoutUserNestedInput;
    uploadedFiles?: FileUpdateManyWithoutUploadedByNestedInput;
    ownedChallenges?: ChallengeUpdateManyWithoutOwnerNestedInput;
  };

  export type UserUncheckedUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    handle?: NullableStringFieldUpdateOperationsInput | string | null;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    organization?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    roles?: UserUpdaterolesInput | $Enums.Role[];
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    totpEnabled?: BoolFieldUpdateOperationsInput | boolean;
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    isBanned?: BoolFieldUpdateOperationsInput | boolean;
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput;
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput;
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput;
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput;
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput;
    mentorProfiles?: MentorUncheckedUpdateManyWithoutUserNestedInput;
    judgeAssignments?: JudgeUncheckedUpdateManyWithoutUserNestedInput;
    challengeSubmissions?: ChallengeSubmissionUncheckedUpdateManyWithoutUserNestedInput;
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput;
    gamificationProfile?: GamificationProfileUncheckedUpdateOneWithoutUserNestedInput;
    xpEvents?: XpEventUncheckedUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    uploadedFiles?: FileUncheckedUpdateManyWithoutUploadedByNestedInput;
    ownedChallenges?: ChallengeUncheckedUpdateManyWithoutOwnerNestedInput;
  };

  export type UserCreateWithoutUploadedFilesInput = {
    id?: string;
    email: string;
    emailVerified?: Date | string | null;
    name?: string | null;
    handle?: string | null;
    avatarUrl?: string | null;
    bio?: string | null;
    organization?: string | null;
    password?: string | null;
    roles?: UserCreaterolesInput | $Enums.Role[];
    totpSecret?: string | null;
    totpEnabled?: boolean;
    passwordResetToken?: string | null;
    passwordResetExpires?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastLoginAt?: Date | string | null;
    isActive?: boolean;
    isBanned?: boolean;
    accounts?: AccountCreateNestedManyWithoutUserInput;
    sessions?: SessionCreateNestedManyWithoutUserInput;
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput;
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput;
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput;
    mentorProfiles?: MentorCreateNestedManyWithoutUserInput;
    judgeAssignments?: JudgeCreateNestedManyWithoutUserInput;
    challengeSubmissions?: ChallengeSubmissionCreateNestedManyWithoutUserInput;
    comments?: CommentCreateNestedManyWithoutAuthorInput;
    gamificationProfile?: GamificationProfileCreateNestedOneWithoutUserInput;
    xpEvents?: XpEventCreateNestedManyWithoutUserInput;
    notifications?: NotificationCreateNestedManyWithoutUserInput;
    reports?: ReportCreateNestedManyWithoutReporterInput;
    ownedChallenges?: ChallengeCreateNestedManyWithoutOwnerInput;
  };

  export type UserUncheckedCreateWithoutUploadedFilesInput = {
    id?: string;
    email: string;
    emailVerified?: Date | string | null;
    name?: string | null;
    handle?: string | null;
    avatarUrl?: string | null;
    bio?: string | null;
    organization?: string | null;
    password?: string | null;
    roles?: UserCreaterolesInput | $Enums.Role[];
    totpSecret?: string | null;
    totpEnabled?: boolean;
    passwordResetToken?: string | null;
    passwordResetExpires?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    lastLoginAt?: Date | string | null;
    isActive?: boolean;
    isBanned?: boolean;
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput;
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput;
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput;
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput;
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput;
    mentorProfiles?: MentorUncheckedCreateNestedManyWithoutUserInput;
    judgeAssignments?: JudgeUncheckedCreateNestedManyWithoutUserInput;
    challengeSubmissions?: ChallengeSubmissionUncheckedCreateNestedManyWithoutUserInput;
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput;
    gamificationProfile?: GamificationProfileUncheckedCreateNestedOneWithoutUserInput;
    xpEvents?: XpEventUncheckedCreateNestedManyWithoutUserInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    reports?: ReportUncheckedCreateNestedManyWithoutReporterInput;
    ownedChallenges?: ChallengeUncheckedCreateNestedManyWithoutOwnerInput;
  };

  export type UserCreateOrConnectWithoutUploadedFilesInput = {
    where: UserWhereUniqueInput;
    create: XOR<UserCreateWithoutUploadedFilesInput, UserUncheckedCreateWithoutUploadedFilesInput>;
  };

  export type UserUpsertWithoutUploadedFilesInput = {
    update: XOR<UserUpdateWithoutUploadedFilesInput, UserUncheckedUpdateWithoutUploadedFilesInput>;
    create: XOR<UserCreateWithoutUploadedFilesInput, UserUncheckedCreateWithoutUploadedFilesInput>;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutUploadedFilesInput = {
    where?: UserWhereInput;
    data: XOR<UserUpdateWithoutUploadedFilesInput, UserUncheckedUpdateWithoutUploadedFilesInput>;
  };

  export type UserUpdateWithoutUploadedFilesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    handle?: NullableStringFieldUpdateOperationsInput | string | null;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    organization?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    roles?: UserUpdaterolesInput | $Enums.Role[];
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    totpEnabled?: BoolFieldUpdateOperationsInput | boolean;
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    isBanned?: BoolFieldUpdateOperationsInput | boolean;
    accounts?: AccountUpdateManyWithoutUserNestedInput;
    sessions?: SessionUpdateManyWithoutUserNestedInput;
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput;
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput;
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput;
    mentorProfiles?: MentorUpdateManyWithoutUserNestedInput;
    judgeAssignments?: JudgeUpdateManyWithoutUserNestedInput;
    challengeSubmissions?: ChallengeSubmissionUpdateManyWithoutUserNestedInput;
    comments?: CommentUpdateManyWithoutAuthorNestedInput;
    gamificationProfile?: GamificationProfileUpdateOneWithoutUserNestedInput;
    xpEvents?: XpEventUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUpdateManyWithoutUserNestedInput;
    reports?: ReportUpdateManyWithoutReporterNestedInput;
    ownedChallenges?: ChallengeUpdateManyWithoutOwnerNestedInput;
  };

  export type UserUncheckedUpdateWithoutUploadedFilesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    handle?: NullableStringFieldUpdateOperationsInput | string | null;
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    organization?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    roles?: UserUpdaterolesInput | $Enums.Role[];
    totpSecret?: NullableStringFieldUpdateOperationsInput | string | null;
    totpEnabled?: BoolFieldUpdateOperationsInput | boolean;
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    isBanned?: BoolFieldUpdateOperationsInput | boolean;
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput;
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput;
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput;
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput;
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput;
    mentorProfiles?: MentorUncheckedUpdateManyWithoutUserNestedInput;
    judgeAssignments?: JudgeUncheckedUpdateManyWithoutUserNestedInput;
    challengeSubmissions?: ChallengeSubmissionUncheckedUpdateManyWithoutUserNestedInput;
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput;
    gamificationProfile?: GamificationProfileUncheckedUpdateOneWithoutUserNestedInput;
    xpEvents?: XpEventUncheckedUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    reports?: ReportUncheckedUpdateManyWithoutReporterNestedInput;
    ownedChallenges?: ChallengeUncheckedUpdateManyWithoutOwnerNestedInput;
  };

  export type AccountCreateManyUserInput = {
    id?: string;
    type: string;
    provider: string;
    providerAccountId: string;
    refresh_token?: string | null;
    access_token?: string | null;
    expires_at?: number | null;
    token_type?: string | null;
    scope?: string | null;
    id_token?: string | null;
    session_state?: string | null;
  };

  export type SessionCreateManyUserInput = {
    id?: string;
    sessionToken: string;
    expires: Date | string;
  };

  export type ApiKeyCreateManyUserInput = {
    id?: string;
    name: string;
    hashedKey: string;
    scopes?: ApiKeyCreatescopesInput | string[];
    lastUsedAt?: Date | string | null;
    expiresAt?: Date | string | null;
    createdAt?: Date | string;
    isActive?: boolean;
  };

  export type AuditLogCreateManyActorInput = {
    id?: string;
    action: string;
    entityType: string;
    entityId?: string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    ipAddress?: string | null;
    userAgent?: string | null;
    createdAt?: Date | string;
  };

  export type TeamMemberCreateManyUserInput = {
    teamId: string;
    role?: $Enums.TeamMemberRole;
    joinedAt?: Date | string;
  };

  export type MentorCreateManyUserInput = {
    id?: string;
    hackathonId: string;
    bio?: string | null;
    calendlyUrl?: string | null;
    expertise?: MentorCreateexpertiseInput | string[];
    createdAt?: Date | string;
  };

  export type JudgeCreateManyUserInput = {
    id?: string;
    hackathonId: string;
    bio?: string | null;
    createdAt?: Date | string;
  };

  export type ChallengeSubmissionCreateManyUserInput = {
    id?: string;
    challengeId: string;
    teamId?: string | null;
    title: string;
    repoUrl?: string | null;
    content: string;
    files?: ChallengeSubmissionCreatefilesInput | string[];
    status?: $Enums.ChallengeSubmissionStatus;
    score?: Decimal | DecimalJsLike | number | string | null;
    feedback?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type CommentCreateManyAuthorInput = {
    id?: string;
    threadId: string;
    parentId?: string | null;
    body: string;
    isFlagged?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type XpEventCreateManyUserInput = {
    id?: string;
    eventType: string;
    points: number;
    refType?: string | null;
    refId?: string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
  };

  export type NotificationCreateManyUserInput = {
    id?: string;
    type: string;
    data: JsonNullValueInput | InputJsonValue;
    readAt?: Date | string | null;
    createdAt?: Date | string;
  };

  export type ReportCreateManyReporterInput = {
    id?: string;
    entityType: string;
    entityId: string;
    reason: string;
    status?: $Enums.ReportStatus;
    resolution?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type FileCreateManyUploadedByInput = {
    id?: string;
    filename: string;
    mimetype: string;
    size: number;
    key: string;
    url: string;
    type: string;
    entityId?: string | null;
    entityType?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
  };

  export type ChallengeCreateManyOwnerInput = {
    id?: string;
    slug: string;
    title: string;
    problemStatement: string;
    ownerOrg?: string | null;
    rewardType?: $Enums.RewardType | null;
    rewardValue?: string | null;
    categories?: ChallengeCreatecategoriesInput | string[];
    skills?: ChallengeCreateskillsInput | string[];
    attachments?: ChallengeCreateattachmentsInput | string[];
    status?: $Enums.ChallengeStatus;
    visibility?: $Enums.ChallengeVisibility;
    deadlineAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    provider?: StringFieldUpdateOperationsInput | string;
    providerAccountId?: StringFieldUpdateOperationsInput | string;
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null;
    access_token?: NullableStringFieldUpdateOperationsInput | string | null;
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null;
    token_type?: NullableStringFieldUpdateOperationsInput | string | null;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    id_token?: NullableStringFieldUpdateOperationsInput | string | null;
    session_state?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    provider?: StringFieldUpdateOperationsInput | string;
    providerAccountId?: StringFieldUpdateOperationsInput | string;
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null;
    access_token?: NullableStringFieldUpdateOperationsInput | string | null;
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null;
    token_type?: NullableStringFieldUpdateOperationsInput | string | null;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    id_token?: NullableStringFieldUpdateOperationsInput | string | null;
    session_state?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    provider?: StringFieldUpdateOperationsInput | string;
    providerAccountId?: StringFieldUpdateOperationsInput | string;
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null;
    access_token?: NullableStringFieldUpdateOperationsInput | string | null;
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null;
    token_type?: NullableStringFieldUpdateOperationsInput | string | null;
    scope?: NullableStringFieldUpdateOperationsInput | string | null;
    id_token?: NullableStringFieldUpdateOperationsInput | string | null;
    session_state?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    sessionToken?: StringFieldUpdateOperationsInput | string;
    expires?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    sessionToken?: StringFieldUpdateOperationsInput | string;
    expires?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    sessionToken?: StringFieldUpdateOperationsInput | string;
    expires?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ApiKeyUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    hashedKey?: StringFieldUpdateOperationsInput | string;
    scopes?: ApiKeyUpdatescopesInput | string[];
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
  };

  export type ApiKeyUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    hashedKey?: StringFieldUpdateOperationsInput | string;
    scopes?: ApiKeyUpdatescopesInput | string[];
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
  };

  export type ApiKeyUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    hashedKey?: StringFieldUpdateOperationsInput | string;
    scopes?: ApiKeyUpdatescopesInput | string[];
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
  };

  export type AuditLogUpdateWithoutActorInput = {
    id?: StringFieldUpdateOperationsInput | string;
    action?: StringFieldUpdateOperationsInput | string;
    entityType?: StringFieldUpdateOperationsInput | string;
    entityId?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AuditLogUncheckedUpdateWithoutActorInput = {
    id?: StringFieldUpdateOperationsInput | string;
    action?: StringFieldUpdateOperationsInput | string;
    entityType?: StringFieldUpdateOperationsInput | string;
    entityId?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AuditLogUncheckedUpdateManyWithoutActorInput = {
    id?: StringFieldUpdateOperationsInput | string;
    action?: StringFieldUpdateOperationsInput | string;
    entityType?: StringFieldUpdateOperationsInput | string;
    entityId?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type TeamMemberUpdateWithoutUserInput = {
    role?: EnumTeamMemberRoleFieldUpdateOperationsInput | $Enums.TeamMemberRole;
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    team?: TeamUpdateOneRequiredWithoutMembersNestedInput;
  };

  export type TeamMemberUncheckedUpdateWithoutUserInput = {
    teamId?: StringFieldUpdateOperationsInput | string;
    role?: EnumTeamMemberRoleFieldUpdateOperationsInput | $Enums.TeamMemberRole;
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type TeamMemberUncheckedUpdateManyWithoutUserInput = {
    teamId?: StringFieldUpdateOperationsInput | string;
    role?: EnumTeamMemberRoleFieldUpdateOperationsInput | $Enums.TeamMemberRole;
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type MentorUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    calendlyUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    expertise?: MentorUpdateexpertiseInput | string[];
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    hackathon?: HackathonUpdateOneRequiredWithoutMentorsNestedInput;
    sessions?: MentorSessionUpdateManyWithoutMentorNestedInput;
  };

  export type MentorUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    hackathonId?: StringFieldUpdateOperationsInput | string;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    calendlyUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    expertise?: MentorUpdateexpertiseInput | string[];
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    sessions?: MentorSessionUncheckedUpdateManyWithoutMentorNestedInput;
  };

  export type MentorUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    hackathonId?: StringFieldUpdateOperationsInput | string;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    calendlyUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    expertise?: MentorUpdateexpertiseInput | string[];
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type JudgeUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    hackathon?: HackathonUpdateOneRequiredWithoutJudgesNestedInput;
    scores?: ScoreUpdateManyWithoutJudgeNestedInput;
  };

  export type JudgeUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    hackathonId?: StringFieldUpdateOperationsInput | string;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    scores?: ScoreUncheckedUpdateManyWithoutJudgeNestedInput;
  };

  export type JudgeUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    hackathonId?: StringFieldUpdateOperationsInput | string;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ChallengeSubmissionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    repoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    content?: StringFieldUpdateOperationsInput | string;
    files?: ChallengeSubmissionUpdatefilesInput | string[];
    status?:
      | EnumChallengeSubmissionStatusFieldUpdateOperationsInput
      | $Enums.ChallengeSubmissionStatus;
    score?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    feedback?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    challenge?: ChallengeUpdateOneRequiredWithoutSubmissionsNestedInput;
    team?: TeamUpdateOneWithoutChallengeSubmissionsNestedInput;
  };

  export type ChallengeSubmissionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    challengeId?: StringFieldUpdateOperationsInput | string;
    teamId?: NullableStringFieldUpdateOperationsInput | string | null;
    title?: StringFieldUpdateOperationsInput | string;
    repoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    content?: StringFieldUpdateOperationsInput | string;
    files?: ChallengeSubmissionUpdatefilesInput | string[];
    status?:
      | EnumChallengeSubmissionStatusFieldUpdateOperationsInput
      | $Enums.ChallengeSubmissionStatus;
    score?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    feedback?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ChallengeSubmissionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    challengeId?: StringFieldUpdateOperationsInput | string;
    teamId?: NullableStringFieldUpdateOperationsInput | string | null;
    title?: StringFieldUpdateOperationsInput | string;
    repoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    content?: StringFieldUpdateOperationsInput | string;
    files?: ChallengeSubmissionUpdatefilesInput | string[];
    status?:
      | EnumChallengeSubmissionStatusFieldUpdateOperationsInput
      | $Enums.ChallengeSubmissionStatus;
    score?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    feedback?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type CommentUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string;
    body?: StringFieldUpdateOperationsInput | string;
    isFlagged?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    thread?: CommentThreadUpdateOneRequiredWithoutCommentsNestedInput;
    parent?: CommentUpdateOneWithoutRepliesNestedInput;
    replies?: CommentUpdateManyWithoutParentNestedInput;
  };

  export type CommentUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string;
    threadId?: StringFieldUpdateOperationsInput | string;
    parentId?: NullableStringFieldUpdateOperationsInput | string | null;
    body?: StringFieldUpdateOperationsInput | string;
    isFlagged?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    replies?: CommentUncheckedUpdateManyWithoutParentNestedInput;
  };

  export type CommentUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string;
    threadId?: StringFieldUpdateOperationsInput | string;
    parentId?: NullableStringFieldUpdateOperationsInput | string | null;
    body?: StringFieldUpdateOperationsInput | string;
    isFlagged?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type XpEventUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventType?: StringFieldUpdateOperationsInput | string;
    points?: IntFieldUpdateOperationsInput | number;
    refType?: NullableStringFieldUpdateOperationsInput | string | null;
    refId?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type XpEventUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventType?: StringFieldUpdateOperationsInput | string;
    points?: IntFieldUpdateOperationsInput | number;
    refType?: NullableStringFieldUpdateOperationsInput | string | null;
    refId?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type XpEventUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    eventType?: StringFieldUpdateOperationsInput | string;
    points?: IntFieldUpdateOperationsInput | number;
    refType?: NullableStringFieldUpdateOperationsInput | string | null;
    refId?: NullableStringFieldUpdateOperationsInput | string | null;
    metadata?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    data?: JsonNullValueInput | InputJsonValue;
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    data?: JsonNullValueInput | InputJsonValue;
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    data?: JsonNullValueInput | InputJsonValue;
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ReportUpdateWithoutReporterInput = {
    id?: StringFieldUpdateOperationsInput | string;
    entityType?: StringFieldUpdateOperationsInput | string;
    entityId?: StringFieldUpdateOperationsInput | string;
    reason?: StringFieldUpdateOperationsInput | string;
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus;
    resolution?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ReportUncheckedUpdateWithoutReporterInput = {
    id?: StringFieldUpdateOperationsInput | string;
    entityType?: StringFieldUpdateOperationsInput | string;
    entityId?: StringFieldUpdateOperationsInput | string;
    reason?: StringFieldUpdateOperationsInput | string;
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus;
    resolution?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ReportUncheckedUpdateManyWithoutReporterInput = {
    id?: StringFieldUpdateOperationsInput | string;
    entityType?: StringFieldUpdateOperationsInput | string;
    entityId?: StringFieldUpdateOperationsInput | string;
    reason?: StringFieldUpdateOperationsInput | string;
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus;
    resolution?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type FileUpdateWithoutUploadedByInput = {
    id?: StringFieldUpdateOperationsInput | string;
    filename?: StringFieldUpdateOperationsInput | string;
    mimetype?: StringFieldUpdateOperationsInput | string;
    size?: IntFieldUpdateOperationsInput | number;
    key?: StringFieldUpdateOperationsInput | string;
    url?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    entityId?: NullableStringFieldUpdateOperationsInput | string | null;
    entityType?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
  };

  export type FileUncheckedUpdateWithoutUploadedByInput = {
    id?: StringFieldUpdateOperationsInput | string;
    filename?: StringFieldUpdateOperationsInput | string;
    mimetype?: StringFieldUpdateOperationsInput | string;
    size?: IntFieldUpdateOperationsInput | number;
    key?: StringFieldUpdateOperationsInput | string;
    url?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    entityId?: NullableStringFieldUpdateOperationsInput | string | null;
    entityType?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
  };

  export type FileUncheckedUpdateManyWithoutUploadedByInput = {
    id?: StringFieldUpdateOperationsInput | string;
    filename?: StringFieldUpdateOperationsInput | string;
    mimetype?: StringFieldUpdateOperationsInput | string;
    size?: IntFieldUpdateOperationsInput | number;
    key?: StringFieldUpdateOperationsInput | string;
    url?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    entityId?: NullableStringFieldUpdateOperationsInput | string | null;
    entityType?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
  };

  export type ChallengeUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    problemStatement?: StringFieldUpdateOperationsInput | string;
    ownerOrg?: NullableStringFieldUpdateOperationsInput | string | null;
    rewardType?: NullableEnumRewardTypeFieldUpdateOperationsInput | $Enums.RewardType | null;
    rewardValue?: NullableStringFieldUpdateOperationsInput | string | null;
    categories?: ChallengeUpdatecategoriesInput | string[];
    skills?: ChallengeUpdateskillsInput | string[];
    attachments?: ChallengeUpdateattachmentsInput | string[];
    status?: EnumChallengeStatusFieldUpdateOperationsInput | $Enums.ChallengeStatus;
    visibility?: EnumChallengeVisibilityFieldUpdateOperationsInput | $Enums.ChallengeVisibility;
    deadlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    submissions?: ChallengeSubmissionUpdateManyWithoutChallengeNestedInput;
  };

  export type ChallengeUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    problemStatement?: StringFieldUpdateOperationsInput | string;
    ownerOrg?: NullableStringFieldUpdateOperationsInput | string | null;
    rewardType?: NullableEnumRewardTypeFieldUpdateOperationsInput | $Enums.RewardType | null;
    rewardValue?: NullableStringFieldUpdateOperationsInput | string | null;
    categories?: ChallengeUpdatecategoriesInput | string[];
    skills?: ChallengeUpdateskillsInput | string[];
    attachments?: ChallengeUpdateattachmentsInput | string[];
    status?: EnumChallengeStatusFieldUpdateOperationsInput | $Enums.ChallengeStatus;
    visibility?: EnumChallengeVisibilityFieldUpdateOperationsInput | $Enums.ChallengeVisibility;
    deadlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    submissions?: ChallengeSubmissionUncheckedUpdateManyWithoutChallengeNestedInput;
  };

  export type ChallengeUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    problemStatement?: StringFieldUpdateOperationsInput | string;
    ownerOrg?: NullableStringFieldUpdateOperationsInput | string | null;
    rewardType?: NullableEnumRewardTypeFieldUpdateOperationsInput | $Enums.RewardType | null;
    rewardValue?: NullableStringFieldUpdateOperationsInput | string | null;
    categories?: ChallengeUpdatecategoriesInput | string[];
    skills?: ChallengeUpdateskillsInput | string[];
    attachments?: ChallengeUpdateattachmentsInput | string[];
    status?: EnumChallengeStatusFieldUpdateOperationsInput | $Enums.ChallengeStatus;
    visibility?: EnumChallengeVisibilityFieldUpdateOperationsInput | $Enums.ChallengeVisibility;
    deadlineAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type TrackCreateManyHackathonInput = {
    id?: string;
    title: string;
    description?: string | null;
    order?: number;
    createdAt?: Date | string;
  };

  export type TeamCreateManyHackathonInput = {
    id?: string;
    name: string;
    bio?: string | null;
    logoUrl?: string | null;
    repoUrl?: string | null;
    demoUrl?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type MentorCreateManyHackathonInput = {
    id?: string;
    userId: string;
    bio?: string | null;
    calendlyUrl?: string | null;
    expertise?: MentorCreateexpertiseInput | string[];
    createdAt?: Date | string;
  };

  export type JudgeCreateManyHackathonInput = {
    id?: string;
    userId: string;
    bio?: string | null;
    createdAt?: Date | string;
  };

  export type CriteriaCreateManyHackathonInput = {
    id?: string;
    name: string;
    description?: string | null;
    maxScore?: number;
    weight?: Decimal | DecimalJsLike | number | string;
    order?: number;
  };

  export type SubmissionCreateManyHackathonInput = {
    id?: string;
    teamId: string;
    trackId?: string | null;
    title: string;
    abstract: string;
    repoUrl?: string | null;
    demoUrl?: string | null;
    videoUrl?: string | null;
    files?: SubmissionCreatefilesInput | string[];
    submittedAt?: Date | string | null;
    finalizedAt?: Date | string | null;
    status?: $Enums.SubmissionStatus;
    scoreAggregate?: Decimal | DecimalJsLike | number | string | null;
    rank?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type AnnouncementCreateManyHackathonInput = {
    id?: string;
    scope: $Enums.AnnouncementScope;
    title: string;
    body: string;
    pinned?: boolean;
    publishedAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type TrackUpdateWithoutHackathonInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    order?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    submissions?: SubmissionUpdateManyWithoutTrackNestedInput;
  };

  export type TrackUncheckedUpdateWithoutHackathonInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    order?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    submissions?: SubmissionUncheckedUpdateManyWithoutTrackNestedInput;
  };

  export type TrackUncheckedUpdateManyWithoutHackathonInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    order?: IntFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type TeamUpdateWithoutHackathonInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    repoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    demoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    members?: TeamMemberUpdateManyWithoutTeamNestedInput;
    submissions?: SubmissionUpdateManyWithoutTeamNestedInput;
    challengeSubmissions?: ChallengeSubmissionUpdateManyWithoutTeamNestedInput;
  };

  export type TeamUncheckedUpdateWithoutHackathonInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    repoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    demoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    members?: TeamMemberUncheckedUpdateManyWithoutTeamNestedInput;
    submissions?: SubmissionUncheckedUpdateManyWithoutTeamNestedInput;
    challengeSubmissions?: ChallengeSubmissionUncheckedUpdateManyWithoutTeamNestedInput;
  };

  export type TeamUncheckedUpdateManyWithoutHackathonInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    repoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    demoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type MentorUpdateWithoutHackathonInput = {
    id?: StringFieldUpdateOperationsInput | string;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    calendlyUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    expertise?: MentorUpdateexpertiseInput | string[];
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutMentorProfilesNestedInput;
    sessions?: MentorSessionUpdateManyWithoutMentorNestedInput;
  };

  export type MentorUncheckedUpdateWithoutHackathonInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    calendlyUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    expertise?: MentorUpdateexpertiseInput | string[];
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    sessions?: MentorSessionUncheckedUpdateManyWithoutMentorNestedInput;
  };

  export type MentorUncheckedUpdateManyWithoutHackathonInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    calendlyUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    expertise?: MentorUpdateexpertiseInput | string[];
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type JudgeUpdateWithoutHackathonInput = {
    id?: StringFieldUpdateOperationsInput | string;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutJudgeAssignmentsNestedInput;
    scores?: ScoreUpdateManyWithoutJudgeNestedInput;
  };

  export type JudgeUncheckedUpdateWithoutHackathonInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    scores?: ScoreUncheckedUpdateManyWithoutJudgeNestedInput;
  };

  export type JudgeUncheckedUpdateManyWithoutHackathonInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    bio?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type CriteriaUpdateWithoutHackathonInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    maxScore?: IntFieldUpdateOperationsInput | number;
    weight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    order?: IntFieldUpdateOperationsInput | number;
    scores?: ScoreUpdateManyWithoutCriterionNestedInput;
  };

  export type CriteriaUncheckedUpdateWithoutHackathonInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    maxScore?: IntFieldUpdateOperationsInput | number;
    weight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    order?: IntFieldUpdateOperationsInput | number;
    scores?: ScoreUncheckedUpdateManyWithoutCriterionNestedInput;
  };

  export type CriteriaUncheckedUpdateManyWithoutHackathonInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    maxScore?: IntFieldUpdateOperationsInput | number;
    weight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string;
    order?: IntFieldUpdateOperationsInput | number;
  };

  export type SubmissionUpdateWithoutHackathonInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    abstract?: StringFieldUpdateOperationsInput | string;
    repoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    demoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    files?: SubmissionUpdatefilesInput | string[];
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    status?: EnumSubmissionStatusFieldUpdateOperationsInput | $Enums.SubmissionStatus;
    scoreAggregate?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    rank?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    team?: TeamUpdateOneRequiredWithoutSubmissionsNestedInput;
    track?: TrackUpdateOneWithoutSubmissionsNestedInput;
    scores?: ScoreUpdateManyWithoutSubmissionNestedInput;
  };

  export type SubmissionUncheckedUpdateWithoutHackathonInput = {
    id?: StringFieldUpdateOperationsInput | string;
    teamId?: StringFieldUpdateOperationsInput | string;
    trackId?: NullableStringFieldUpdateOperationsInput | string | null;
    title?: StringFieldUpdateOperationsInput | string;
    abstract?: StringFieldUpdateOperationsInput | string;
    repoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    demoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    files?: SubmissionUpdatefilesInput | string[];
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    status?: EnumSubmissionStatusFieldUpdateOperationsInput | $Enums.SubmissionStatus;
    scoreAggregate?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    rank?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    scores?: ScoreUncheckedUpdateManyWithoutSubmissionNestedInput;
  };

  export type SubmissionUncheckedUpdateManyWithoutHackathonInput = {
    id?: StringFieldUpdateOperationsInput | string;
    teamId?: StringFieldUpdateOperationsInput | string;
    trackId?: NullableStringFieldUpdateOperationsInput | string | null;
    title?: StringFieldUpdateOperationsInput | string;
    abstract?: StringFieldUpdateOperationsInput | string;
    repoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    demoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    files?: SubmissionUpdatefilesInput | string[];
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    status?: EnumSubmissionStatusFieldUpdateOperationsInput | $Enums.SubmissionStatus;
    scoreAggregate?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    rank?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AnnouncementUpdateWithoutHackathonInput = {
    id?: StringFieldUpdateOperationsInput | string;
    scope?: EnumAnnouncementScopeFieldUpdateOperationsInput | $Enums.AnnouncementScope;
    title?: StringFieldUpdateOperationsInput | string;
    body?: StringFieldUpdateOperationsInput | string;
    pinned?: BoolFieldUpdateOperationsInput | boolean;
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AnnouncementUncheckedUpdateWithoutHackathonInput = {
    id?: StringFieldUpdateOperationsInput | string;
    scope?: EnumAnnouncementScopeFieldUpdateOperationsInput | $Enums.AnnouncementScope;
    title?: StringFieldUpdateOperationsInput | string;
    body?: StringFieldUpdateOperationsInput | string;
    pinned?: BoolFieldUpdateOperationsInput | boolean;
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AnnouncementUncheckedUpdateManyWithoutHackathonInput = {
    id?: StringFieldUpdateOperationsInput | string;
    scope?: EnumAnnouncementScopeFieldUpdateOperationsInput | $Enums.AnnouncementScope;
    title?: StringFieldUpdateOperationsInput | string;
    body?: StringFieldUpdateOperationsInput | string;
    pinned?: BoolFieldUpdateOperationsInput | boolean;
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type SubmissionCreateManyTrackInput = {
    id?: string;
    hackathonId: string;
    teamId: string;
    title: string;
    abstract: string;
    repoUrl?: string | null;
    demoUrl?: string | null;
    videoUrl?: string | null;
    files?: SubmissionCreatefilesInput | string[];
    submittedAt?: Date | string | null;
    finalizedAt?: Date | string | null;
    status?: $Enums.SubmissionStatus;
    scoreAggregate?: Decimal | DecimalJsLike | number | string | null;
    rank?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type SubmissionUpdateWithoutTrackInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    abstract?: StringFieldUpdateOperationsInput | string;
    repoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    demoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    files?: SubmissionUpdatefilesInput | string[];
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    status?: EnumSubmissionStatusFieldUpdateOperationsInput | $Enums.SubmissionStatus;
    scoreAggregate?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    rank?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    hackathon?: HackathonUpdateOneRequiredWithoutSubmissionsNestedInput;
    team?: TeamUpdateOneRequiredWithoutSubmissionsNestedInput;
    scores?: ScoreUpdateManyWithoutSubmissionNestedInput;
  };

  export type SubmissionUncheckedUpdateWithoutTrackInput = {
    id?: StringFieldUpdateOperationsInput | string;
    hackathonId?: StringFieldUpdateOperationsInput | string;
    teamId?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    abstract?: StringFieldUpdateOperationsInput | string;
    repoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    demoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    files?: SubmissionUpdatefilesInput | string[];
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    status?: EnumSubmissionStatusFieldUpdateOperationsInput | $Enums.SubmissionStatus;
    scoreAggregate?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    rank?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    scores?: ScoreUncheckedUpdateManyWithoutSubmissionNestedInput;
  };

  export type SubmissionUncheckedUpdateManyWithoutTrackInput = {
    id?: StringFieldUpdateOperationsInput | string;
    hackathonId?: StringFieldUpdateOperationsInput | string;
    teamId?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    abstract?: StringFieldUpdateOperationsInput | string;
    repoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    demoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    files?: SubmissionUpdatefilesInput | string[];
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    status?: EnumSubmissionStatusFieldUpdateOperationsInput | $Enums.SubmissionStatus;
    scoreAggregate?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    rank?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type TeamMemberCreateManyTeamInput = {
    userId: string;
    role?: $Enums.TeamMemberRole;
    joinedAt?: Date | string;
  };

  export type SubmissionCreateManyTeamInput = {
    id?: string;
    hackathonId: string;
    trackId?: string | null;
    title: string;
    abstract: string;
    repoUrl?: string | null;
    demoUrl?: string | null;
    videoUrl?: string | null;
    files?: SubmissionCreatefilesInput | string[];
    submittedAt?: Date | string | null;
    finalizedAt?: Date | string | null;
    status?: $Enums.SubmissionStatus;
    scoreAggregate?: Decimal | DecimalJsLike | number | string | null;
    rank?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ChallengeSubmissionCreateManyTeamInput = {
    id?: string;
    challengeId: string;
    userId?: string | null;
    title: string;
    repoUrl?: string | null;
    content: string;
    files?: ChallengeSubmissionCreatefilesInput | string[];
    status?: $Enums.ChallengeSubmissionStatus;
    score?: Decimal | DecimalJsLike | number | string | null;
    feedback?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type TeamMemberUpdateWithoutTeamInput = {
    role?: EnumTeamMemberRoleFieldUpdateOperationsInput | $Enums.TeamMemberRole;
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutTeamMembershipsNestedInput;
  };

  export type TeamMemberUncheckedUpdateWithoutTeamInput = {
    userId?: StringFieldUpdateOperationsInput | string;
    role?: EnumTeamMemberRoleFieldUpdateOperationsInput | $Enums.TeamMemberRole;
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type TeamMemberUncheckedUpdateManyWithoutTeamInput = {
    userId?: StringFieldUpdateOperationsInput | string;
    role?: EnumTeamMemberRoleFieldUpdateOperationsInput | $Enums.TeamMemberRole;
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type SubmissionUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    abstract?: StringFieldUpdateOperationsInput | string;
    repoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    demoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    files?: SubmissionUpdatefilesInput | string[];
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    status?: EnumSubmissionStatusFieldUpdateOperationsInput | $Enums.SubmissionStatus;
    scoreAggregate?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    rank?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    hackathon?: HackathonUpdateOneRequiredWithoutSubmissionsNestedInput;
    track?: TrackUpdateOneWithoutSubmissionsNestedInput;
    scores?: ScoreUpdateManyWithoutSubmissionNestedInput;
  };

  export type SubmissionUncheckedUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string;
    hackathonId?: StringFieldUpdateOperationsInput | string;
    trackId?: NullableStringFieldUpdateOperationsInput | string | null;
    title?: StringFieldUpdateOperationsInput | string;
    abstract?: StringFieldUpdateOperationsInput | string;
    repoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    demoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    files?: SubmissionUpdatefilesInput | string[];
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    status?: EnumSubmissionStatusFieldUpdateOperationsInput | $Enums.SubmissionStatus;
    scoreAggregate?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    rank?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    scores?: ScoreUncheckedUpdateManyWithoutSubmissionNestedInput;
  };

  export type SubmissionUncheckedUpdateManyWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string;
    hackathonId?: StringFieldUpdateOperationsInput | string;
    trackId?: NullableStringFieldUpdateOperationsInput | string | null;
    title?: StringFieldUpdateOperationsInput | string;
    abstract?: StringFieldUpdateOperationsInput | string;
    repoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    demoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    files?: SubmissionUpdatefilesInput | string[];
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    status?: EnumSubmissionStatusFieldUpdateOperationsInput | $Enums.SubmissionStatus;
    scoreAggregate?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    rank?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ChallengeSubmissionUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    repoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    content?: StringFieldUpdateOperationsInput | string;
    files?: ChallengeSubmissionUpdatefilesInput | string[];
    status?:
      | EnumChallengeSubmissionStatusFieldUpdateOperationsInput
      | $Enums.ChallengeSubmissionStatus;
    score?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    feedback?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    challenge?: ChallengeUpdateOneRequiredWithoutSubmissionsNestedInput;
    user?: UserUpdateOneWithoutChallengeSubmissionsNestedInput;
  };

  export type ChallengeSubmissionUncheckedUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string;
    challengeId?: StringFieldUpdateOperationsInput | string;
    userId?: NullableStringFieldUpdateOperationsInput | string | null;
    title?: StringFieldUpdateOperationsInput | string;
    repoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    content?: StringFieldUpdateOperationsInput | string;
    files?: ChallengeSubmissionUpdatefilesInput | string[];
    status?:
      | EnumChallengeSubmissionStatusFieldUpdateOperationsInput
      | $Enums.ChallengeSubmissionStatus;
    score?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    feedback?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ChallengeSubmissionUncheckedUpdateManyWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string;
    challengeId?: StringFieldUpdateOperationsInput | string;
    userId?: NullableStringFieldUpdateOperationsInput | string | null;
    title?: StringFieldUpdateOperationsInput | string;
    repoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    content?: StringFieldUpdateOperationsInput | string;
    files?: ChallengeSubmissionUpdatefilesInput | string[];
    status?:
      | EnumChallengeSubmissionStatusFieldUpdateOperationsInput
      | $Enums.ChallengeSubmissionStatus;
    score?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    feedback?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type MentorSessionCreateManyMentorInput = {
    id?: string;
    title?: string | null;
    startsAt: Date | string;
    endsAt: Date | string;
    capacity?: number;
    booked?: number;
    meetingUrl?: string | null;
    createdAt?: Date | string;
  };

  export type MentorSessionUpdateWithoutMentorInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: NullableStringFieldUpdateOperationsInput | string | null;
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    capacity?: IntFieldUpdateOperationsInput | number;
    booked?: IntFieldUpdateOperationsInput | number;
    meetingUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type MentorSessionUncheckedUpdateWithoutMentorInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: NullableStringFieldUpdateOperationsInput | string | null;
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    capacity?: IntFieldUpdateOperationsInput | number;
    booked?: IntFieldUpdateOperationsInput | number;
    meetingUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type MentorSessionUncheckedUpdateManyWithoutMentorInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: NullableStringFieldUpdateOperationsInput | string | null;
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    capacity?: IntFieldUpdateOperationsInput | number;
    booked?: IntFieldUpdateOperationsInput | number;
    meetingUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ScoreCreateManyJudgeInput = {
    id?: string;
    submissionId: string;
    criterionId: string;
    score: number;
    feedback?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ScoreUpdateWithoutJudgeInput = {
    id?: StringFieldUpdateOperationsInput | string;
    score?: IntFieldUpdateOperationsInput | number;
    feedback?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    submission?: SubmissionUpdateOneRequiredWithoutScoresNestedInput;
    criterion?: CriteriaUpdateOneRequiredWithoutScoresNestedInput;
  };

  export type ScoreUncheckedUpdateWithoutJudgeInput = {
    id?: StringFieldUpdateOperationsInput | string;
    submissionId?: StringFieldUpdateOperationsInput | string;
    criterionId?: StringFieldUpdateOperationsInput | string;
    score?: IntFieldUpdateOperationsInput | number;
    feedback?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ScoreUncheckedUpdateManyWithoutJudgeInput = {
    id?: StringFieldUpdateOperationsInput | string;
    submissionId?: StringFieldUpdateOperationsInput | string;
    criterionId?: StringFieldUpdateOperationsInput | string;
    score?: IntFieldUpdateOperationsInput | number;
    feedback?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ScoreCreateManyCriterionInput = {
    id?: string;
    submissionId: string;
    judgeId: string;
    score: number;
    feedback?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ScoreUpdateWithoutCriterionInput = {
    id?: StringFieldUpdateOperationsInput | string;
    score?: IntFieldUpdateOperationsInput | number;
    feedback?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    submission?: SubmissionUpdateOneRequiredWithoutScoresNestedInput;
    judge?: JudgeUpdateOneRequiredWithoutScoresNestedInput;
  };

  export type ScoreUncheckedUpdateWithoutCriterionInput = {
    id?: StringFieldUpdateOperationsInput | string;
    submissionId?: StringFieldUpdateOperationsInput | string;
    judgeId?: StringFieldUpdateOperationsInput | string;
    score?: IntFieldUpdateOperationsInput | number;
    feedback?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ScoreUncheckedUpdateManyWithoutCriterionInput = {
    id?: StringFieldUpdateOperationsInput | string;
    submissionId?: StringFieldUpdateOperationsInput | string;
    judgeId?: StringFieldUpdateOperationsInput | string;
    score?: IntFieldUpdateOperationsInput | number;
    feedback?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ScoreCreateManySubmissionInput = {
    id?: string;
    judgeId: string;
    criterionId: string;
    score: number;
    feedback?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ScoreUpdateWithoutSubmissionInput = {
    id?: StringFieldUpdateOperationsInput | string;
    score?: IntFieldUpdateOperationsInput | number;
    feedback?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    judge?: JudgeUpdateOneRequiredWithoutScoresNestedInput;
    criterion?: CriteriaUpdateOneRequiredWithoutScoresNestedInput;
  };

  export type ScoreUncheckedUpdateWithoutSubmissionInput = {
    id?: StringFieldUpdateOperationsInput | string;
    judgeId?: StringFieldUpdateOperationsInput | string;
    criterionId?: StringFieldUpdateOperationsInput | string;
    score?: IntFieldUpdateOperationsInput | number;
    feedback?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ScoreUncheckedUpdateManyWithoutSubmissionInput = {
    id?: StringFieldUpdateOperationsInput | string;
    judgeId?: StringFieldUpdateOperationsInput | string;
    criterionId?: StringFieldUpdateOperationsInput | string;
    score?: IntFieldUpdateOperationsInput | number;
    feedback?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ChallengeSubmissionCreateManyChallengeInput = {
    id?: string;
    userId?: string | null;
    teamId?: string | null;
    title: string;
    repoUrl?: string | null;
    content: string;
    files?: ChallengeSubmissionCreatefilesInput | string[];
    status?: $Enums.ChallengeSubmissionStatus;
    score?: Decimal | DecimalJsLike | number | string | null;
    feedback?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ChallengeSubmissionUpdateWithoutChallengeInput = {
    id?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    repoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    content?: StringFieldUpdateOperationsInput | string;
    files?: ChallengeSubmissionUpdatefilesInput | string[];
    status?:
      | EnumChallengeSubmissionStatusFieldUpdateOperationsInput
      | $Enums.ChallengeSubmissionStatus;
    score?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    feedback?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneWithoutChallengeSubmissionsNestedInput;
    team?: TeamUpdateOneWithoutChallengeSubmissionsNestedInput;
  };

  export type ChallengeSubmissionUncheckedUpdateWithoutChallengeInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: NullableStringFieldUpdateOperationsInput | string | null;
    teamId?: NullableStringFieldUpdateOperationsInput | string | null;
    title?: StringFieldUpdateOperationsInput | string;
    repoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    content?: StringFieldUpdateOperationsInput | string;
    files?: ChallengeSubmissionUpdatefilesInput | string[];
    status?:
      | EnumChallengeSubmissionStatusFieldUpdateOperationsInput
      | $Enums.ChallengeSubmissionStatus;
    score?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    feedback?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ChallengeSubmissionUncheckedUpdateManyWithoutChallengeInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: NullableStringFieldUpdateOperationsInput | string | null;
    teamId?: NullableStringFieldUpdateOperationsInput | string | null;
    title?: StringFieldUpdateOperationsInput | string;
    repoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    content?: StringFieldUpdateOperationsInput | string;
    files?: ChallengeSubmissionUpdatefilesInput | string[];
    status?:
      | EnumChallengeSubmissionStatusFieldUpdateOperationsInput
      | $Enums.ChallengeSubmissionStatus;
    score?:
      | NullableDecimalFieldUpdateOperationsInput
      | Decimal
      | DecimalJsLike
      | number
      | string
      | null;
    feedback?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type CommentCreateManyThreadInput = {
    id?: string;
    authorId: string;
    parentId?: string | null;
    body: string;
    isFlagged?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type CommentUpdateWithoutThreadInput = {
    id?: StringFieldUpdateOperationsInput | string;
    body?: StringFieldUpdateOperationsInput | string;
    isFlagged?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    author?: UserUpdateOneRequiredWithoutCommentsNestedInput;
    parent?: CommentUpdateOneWithoutRepliesNestedInput;
    replies?: CommentUpdateManyWithoutParentNestedInput;
  };

  export type CommentUncheckedUpdateWithoutThreadInput = {
    id?: StringFieldUpdateOperationsInput | string;
    authorId?: StringFieldUpdateOperationsInput | string;
    parentId?: NullableStringFieldUpdateOperationsInput | string | null;
    body?: StringFieldUpdateOperationsInput | string;
    isFlagged?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    replies?: CommentUncheckedUpdateManyWithoutParentNestedInput;
  };

  export type CommentUncheckedUpdateManyWithoutThreadInput = {
    id?: StringFieldUpdateOperationsInput | string;
    authorId?: StringFieldUpdateOperationsInput | string;
    parentId?: NullableStringFieldUpdateOperationsInput | string | null;
    body?: StringFieldUpdateOperationsInput | string;
    isFlagged?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type CommentCreateManyParentInput = {
    id?: string;
    threadId: string;
    authorId: string;
    body: string;
    isFlagged?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type CommentUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string;
    body?: StringFieldUpdateOperationsInput | string;
    isFlagged?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    thread?: CommentThreadUpdateOneRequiredWithoutCommentsNestedInput;
    author?: UserUpdateOneRequiredWithoutCommentsNestedInput;
    replies?: CommentUpdateManyWithoutParentNestedInput;
  };

  export type CommentUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string;
    threadId?: StringFieldUpdateOperationsInput | string;
    authorId?: StringFieldUpdateOperationsInput | string;
    body?: StringFieldUpdateOperationsInput | string;
    isFlagged?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    replies?: CommentUncheckedUpdateManyWithoutParentNestedInput;
  };

  export type CommentUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string;
    threadId?: StringFieldUpdateOperationsInput | string;
    authorId?: StringFieldUpdateOperationsInput | string;
    body?: StringFieldUpdateOperationsInput | string;
    isFlagged?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  /**
   * Aliases for legacy arg types
   */
  /**
   * @deprecated Use UserCountOutputTypeDefaultArgs instead
   */
  export type UserCountOutputTypeArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = UserCountOutputTypeDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use HackathonCountOutputTypeDefaultArgs instead
   */
  export type HackathonCountOutputTypeArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = HackathonCountOutputTypeDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use TrackCountOutputTypeDefaultArgs instead
   */
  export type TrackCountOutputTypeArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = TrackCountOutputTypeDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use TeamCountOutputTypeDefaultArgs instead
   */
  export type TeamCountOutputTypeArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = TeamCountOutputTypeDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use MentorCountOutputTypeDefaultArgs instead
   */
  export type MentorCountOutputTypeArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = MentorCountOutputTypeDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use JudgeCountOutputTypeDefaultArgs instead
   */
  export type JudgeCountOutputTypeArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = JudgeCountOutputTypeDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use CriteriaCountOutputTypeDefaultArgs instead
   */
  export type CriteriaCountOutputTypeArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = CriteriaCountOutputTypeDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use SubmissionCountOutputTypeDefaultArgs instead
   */
  export type SubmissionCountOutputTypeArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = SubmissionCountOutputTypeDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use ChallengeCountOutputTypeDefaultArgs instead
   */
  export type ChallengeCountOutputTypeArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = ChallengeCountOutputTypeDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use CommentThreadCountOutputTypeDefaultArgs instead
   */
  export type CommentThreadCountOutputTypeArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = CommentThreadCountOutputTypeDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use CommentCountOutputTypeDefaultArgs instead
   */
  export type CommentCountOutputTypeArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = CommentCountOutputTypeDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use UserDefaultArgs instead
   */
  export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    UserDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use AccountDefaultArgs instead
   */
  export type AccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    AccountDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use SessionDefaultArgs instead
   */
  export type SessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    SessionDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use VerificationTokenDefaultArgs instead
   */
  export type VerificationTokenArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = VerificationTokenDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use ApiKeyDefaultArgs instead
   */
  export type ApiKeyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    ApiKeyDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use AuditLogDefaultArgs instead
   */
  export type AuditLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    AuditLogDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use HackathonDefaultArgs instead
   */
  export type HackathonArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    HackathonDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use TrackDefaultArgs instead
   */
  export type TrackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    TrackDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use TeamDefaultArgs instead
   */
  export type TeamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    TeamDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use TeamMemberDefaultArgs instead
   */
  export type TeamMemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    TeamMemberDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use MentorDefaultArgs instead
   */
  export type MentorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    MentorDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use MentorSessionDefaultArgs instead
   */
  export type MentorSessionArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = MentorSessionDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use JudgeDefaultArgs instead
   */
  export type JudgeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    JudgeDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use CriteriaDefaultArgs instead
   */
  export type CriteriaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    CriteriaDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use SubmissionDefaultArgs instead
   */
  export type SubmissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    SubmissionDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use ScoreDefaultArgs instead
   */
  export type ScoreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    ScoreDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use ChallengeDefaultArgs instead
   */
  export type ChallengeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    ChallengeDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use ChallengeSubmissionDefaultArgs instead
   */
  export type ChallengeSubmissionArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = ChallengeSubmissionDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use AnnouncementDefaultArgs instead
   */
  export type AnnouncementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    AnnouncementDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use CommentThreadDefaultArgs instead
   */
  export type CommentThreadArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = CommentThreadDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use CommentDefaultArgs instead
   */
  export type CommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    CommentDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use GamificationProfileDefaultArgs instead
   */
  export type GamificationProfileArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = GamificationProfileDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use BadgeDefaultArgs instead
   */
  export type BadgeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    BadgeDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use XpEventDefaultArgs instead
   */
  export type XpEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    XpEventDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use LeaderboardSnapshotDefaultArgs instead
   */
  export type LeaderboardSnapshotArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = LeaderboardSnapshotDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use NotificationDefaultArgs instead
   */
  export type NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    NotificationDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use ReportDefaultArgs instead
   */
  export type ReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    ReportDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use FileDefaultArgs instead
   */
  export type FileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    FileDefaultArgs<ExtArgs>;

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number;
  };

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF;
}
